  tcontrol=twin->icontrol;
  //fprintf(stderr,"looking for FTControl %s in window %s\n",name,twin->name);
  //  fprintf(stderr,"tcontrol->name=%p\n",tcontrol->name);
  //  fprintf(stderr,"tcontrol->name=%s\n",tcontrol->name);
    if (tcontrol->name!=0 && strcmp(tcontrol->name,name)==0) {
    //  fprintf(stderr,"got FTControl %s\n",tcontrol->name);
//if (tcontrol->next!=0)
  //fprintf(stderr,"got here %p\n",tcontrol->next);
    tcontrol=tcontrol->next;
//  if (tcontrol->next==0) {ex=1;}
//  else {tcontrol=(FTControl *)tcontrol->next;}
  else twin=twin->next;  //go to next window
//if (twin->next==0) {ex0=1;}
//else {twin=(FTWindow *)twin->next;}
//if (c->type==CTLabel || c->type==CTFileMenu) {
//twin=GetFTWindowN(c->win);
twin=c->window;
tcontrol=twin->icontrol;
tab=c->tab;
//c will not = tcontrol if the same FTControl - im not sure why this is
//if (strcmp(c->name,tcontrol->name) && tcontrol->tab==tab && tab>0) {
if (c!=tcontrol && tcontrol->tab==tab && tab>0) {
	//fprintf(stderr,"%s and %s have the same tab (%d).\n",c->name,tcontrol->name,tab);
if (tcontrol->tab>max) max=tcontrol->tab;
tcontrol=tcontrol->next;
if (dup==0 && tab>0) return(tab);//no duplicate and is not 0 or -1
//if (dup) fprintf(stderr,"Tab %d is already taken. Giving FTControl %s new tab.\n",tab,tcontrol->name);
tcontrol=twin->icontrol;
if (tcontrol->tab==tab) dup=1; //already taken
tcontrol=tcontrol->next;
if (tcontrol->next==0)
    tcontrol=twin->icontrol;
    //fprintf(stderr,"assigned FTControl %s with tab %d\n",tcontrol->name,tab);
else (tcontrol=tcontrol->next);
//fprintf(stderr,"assigned FTControl %s with tab %d\n",tcontrol->name,tab);
//GetNextTab is different from GotoNextTab in that this just returns the next tab, without setting the twin->focus to the next tab
tcontrol=twin->icontrol;
if (tcontrol->tab!=0) {//exclude labels
  if (tcontrol->tab>tab && (tcontrol->tab<=next || next==tab)) {
		if (!(tcontrol->Bits&CNoTab) && tcontrol->type!=CTLabel && 
			!(tcontrol->Bits&(CVScrollUp|CVScrollDown|CVScrollBack|CVScrollSlide|CHScrollLeft|CHScrollRight|CHScrollBack|CHScrollSlide)) && tcontrol->type!=CTFrame && tcontrol->type!=CTTimeLine) {
				 next=tcontrol->tab;
	} //tcontrol->tab>tab
  if (tcontrol->tab<min) {
		min=tcontrol->tab;
tcontrol=tcontrol->next;
tcontrol=twin->icontrol;
if (tcontrol->tab!=0) {//exclude labels
  if (tcontrol->tab<tab && (tcontrol->tab>prev || prev==tab)) {
		if (!(tcontrol->Bits&CNoTab) && tcontrol->type!=CTLabel && 
				!(tcontrol->Bits&(CVScrollUp|CVScrollDown|CVScrollBack|CVScrollSlide|CHScrollLeft|CHScrollRight|CHScrollBack|CHScrollSlide)) && tcontrol->type!=CTFrame && tcontrol->type!=CTTimeLine) {
					prev=tcontrol->tab;
	} //tcontrol->tab<tab
  if (tcontrol->tab>max) max=tcontrol->tab; //if this tab is > than max, make this new max
tcontrol=tcontrol->next;
tcontrol=twin->icontrol;
  if (tcontrol->tab==tab) return(tcontrol);
tcontrol=tcontrol->next;
tcontrol=twin->icontrol;
start=twin->focus;
next=GetNextTab(twin,twin->focus);
    //if (tcontrol->type==CTFileMenu && !(tcontrol->Bits&CSubMenu)) return(tcontrol);
		if (tcontrol->type==CTFileMenu) return(tcontrol);
tcontrol=twin->icontrol;
start=twin->focus;
prev=GetPrevTab(twin,twin->focus);
//    if (tcontrol->type==CTFileMenu && !(tcontrol->Bits&CSubMenu)) return(tcontrol);
			//fprintf(stderr,"tab %d tcontrol=%s\n",prev,tcontrol2->name);
			if (tcontrol2->type==CTFileMenu) return(tcontrol2);
tcontrol=PStatus.iwindow->icontrol;
//fprintf(stderr,"%s=%s\n",tcontrol->name,tstr);
if (strcmp(tcontrol->name,tstr)==0) isfree=0;
if (tcontrol->next==0)
    tcontrol=PStatus.iwindow->icontrol;
else tcontrol=tcontrol->next;
 // fprintf(stderr,"add FTControl: %s\n",c->name);
	//fprintf(stderr,"data00=%p\n",c->data);
	//c->data has to be malloc'd by the caller
	c->next=0;  //for now AddFTControl is the only source of next pointers
	//twin=GetFTWindowN(c->winnum);
	c->window=twin;
//	c->winnum=twin->num;
	if (twin->icontrol==0) {  //first FTControl for window
		twin->icontrol=malloc(sizeof(FTControl));
		//fprintf(stderr,"malloc %d %p %s\n",sizeof(FTControl),twin->icontrol,c->name);
		tcontrol=twin->icontrol;
		tcontrol=twin->icontrol;
		while(tcontrol->next!=0) {				
			if (!strcmp(tcontrol->name,c->name)) {
				fprintf(stderr,"Error:  Tried to add FTControl with same name \"%s\"\n",tcontrol->name);
			tcontrol=tcontrol->next;
		tcontrol->next=malloc(sizeof(FTControl));
		tcontrol=tcontrol->next;
	} //twin->icontrol==0
//      if (c->type==CTTextBox || c->type==CTButton)
  if (tcontrol->type!=CTLabel && !(tcontrol->Bits&CNoTab)) {
    tcontrol->tab=CheckTab(tcontrol);//->win,c->tab);
//				    tcontrol->tab=CheckTab(c);//->win,c->tab);
		//fprintf(stderr,"%s has tab %d\n",tcontrol->name,tcontrol->tab);
  tcontrol->next=0;
  if (tcontrol->Bits&(CVScroll|CHScroll))	{
	if (tcontrol->type==CTFileOpen) { //FileOpen Controls require associated Name, Size and Date buttons
		//add Folder and file images - these should perhaps be compiled in libfreethought - but gives people the chance to customize
		tcontrol->image=LoadBitmapAndScale(path,tcontrol->font->max_bounds.ascent+tcontrol->font->max_bounds.descent,tcontrol->font->max_bounds.ascent+tcontrol->font->max_bounds.descent);
		if (tcontrol->image==0) {
		tcontrol->image2=LoadBitmapAndScale(path,tcontrol->font->max_bounds.ascent+tcontrol->font->max_bounds.descent,tcontrol->font->max_bounds.ascent+tcontrol->font->max_bounds.descent);
		if (tcontrol->image2==0) {
		if (tcontrol->Bits&CFOName || tcontrol->Bits&CFOSize || tcontrol->Bits&CFODate)
	if (tcontrol->type==CTData) {
		//fprintf(stderr,"Add x1=%d x2=%d\n",tcontrol->x1,tcontrol->x2);
    fprintf(stderr,"added FTControl %s\n",tcontrol->name);
	//twin=GetFTWindowN(tcontrol->win);
	cw=tcontrol->x2-tcontrol->x1;
	if (tcontrol->Bits&CFOName) {
		x[0]=tcontrol->x1; 
		if (tcontrol->Bits&CFOSize) {
			x[1]=(int)((float)(tcontrol->x2-tcontrol->x1)/2.0);
			if (tcontrol->Bits&CFODate) { 	
				x[2]=(int)((float)(tcontrol->x2-tcontrol->x1)*3.0/4.0);
			} else x[2]=tcontrol->x2;//CFODate
			x[1]=tcontrol->x2;
			x[2]=tcontrol->x2;
	 if (tcontrol->Bits&CFOSize) {
			x[1]=tcontrol->x1;
			if (tcontrol->Bits&CFODate) { 	
				x[2]=(int)((float)(tcontrol->x2-tcontrol->x1)/2.0);
			} else x[2]=tcontrol->x2; //CFODate
			if (tcontrol->Bits&CFODate) { 	
				x[2]=tcontrol->x1;
			} else x[2]=tcontrol->x2;
	if (tcontrol->Bits&CFOName) {  //CFOName
	sprintf(tstr,"%s%s",PStatus.PrefixName,tcontrol->name);
	//sprintf(tstr,"FO_Name_%s",tcontrol->name);
	fh=tcontrol2.font->max_bounds.ascent+tcontrol2.font->max_bounds.descent+4;
	//verify y1-fh>0
	if (tcontrol->y1-fh>0) {
		tcontrol2.y1=tcontrol->y1-fh;//46;
	tcontrol2.x2=x[1];//10+tcontrol2.font->max_bounds.width*20;
	tcontrol2.y2=tcontrol->y1;//46+(tcontrol2.font->max_bounds.ascent+tcontrol2.font->max_bounds.descent+4); 
	tcontrol2.x3=tcontrol2.x2-tcontrol2.x1;  //hold on to original size
	tcontrol2.z=-100; //above other controls
	tcontrol2.sx2=(float)(tcontrol2.x2-tcontrol2.x1)/(float)cw;//0.4; //still need?
	//tcontrol2.gx2=-40;
	//tcontrol2.gy2=-70;
	//tcontrol2.win=twin->num;
	if (tcontrol->Bits&CFOSize) {  //CFOSize
	//sprintf(tstr,"FO_Size_%s",tcontrol->name);
	sprintf(tstr,"%s%s",PStatus.PrefixSize,tcontrol->name);
	fh=tcontrol2.font->max_bounds.ascent+tcontrol2.font->max_bounds.descent+4;
	tcontrol2.x1=x[1];//10+tcontrol2.font->max_bounds.width*20;
	if (tcontrol->y1-fh>0) {
		tcontrol2.y1=tcontrol->y1-fh;//46;
	tcontrol2.x2=x[2];//10+tcontrol2.font->max_bounds.width*28;
	tcontrol2.y2=tcontrol->y1;//46+(tcontrol2.font->max_bounds.ascent+tcontrol2.font->max_bounds.descent+4); 
	tcontrol2.x3=tcontrol2.x2-tcontrol2.x1;  //hold on to original size
	tcontrol2.z=-100; //above other controls
	tcontrol2.sx1=(float)(tcontrol2.x2-tcontrol2.x1)/(float)cw;//.3;
	tcontrol2.sx2=(float)(tcontrol2.x2-tcontrol2.x1)/(float)cw;//.3;
//	fprintf(stderr,"b sx2=%f cw=%d x2-x1=%d\n",tcontrol2.sx2,cw,tcontrol2.x2-tcontrol2.x1);
	//tcontrol2.gx2=-40;
	//tcontrol2.gy2=-70;
	//tcontrol2.win=twin->num;
	if (tcontrol->Bits&CFODate) {  //CFODate
	sprintf(tstr,"%s%s",PStatus.PrefixDate,tcontrol->name);
	//sprintf(tstr,"FO_Date_%s",tcontrol->name);
	fh=tcontrol2.font->max_bounds.ascent+tcontrol2.font->max_bounds.descent+4;
	tcontrol2.x1=x[2];//10+tcontrol2.font->max_bounds.width*28;
	if (tcontrol->y1-fh>0) {
		tcontrol2.y1=tcontrol->y1-fh;//46;
	tcontrol2.x2=tcontrol->x2;//10+tcontrol2.font->max_bounds.width*50;
	tcontrol2.y2=tcontrol->y1;//46+(tcontrol2.font->max_bounds.ascent+tcontrol2.font->max_bounds.descent+4); 
	tcontrol2.x3=tcontrol2.x2-tcontrol2.x1;  //hold on to original size
	tcontrol2.z=-100; //above other controls
	tcontrol2.sx1=(float)(tcontrol2.x2-tcontrol2.x1)/(float)cw;//.3; //need? - change to correct proportion then for resize
	tcontrol2.sx2=(float)(tcontrol2.x2-tcontrol2.x1)/(float)cw;//.3;
	//tcontrol2.gx2=-40;
	//tcontrol2.gy2=-70;
	//tcontrol2.win=twin->num;
//twin=GetFTWindowN(tcontrol->win);
if (tcontrol->Bits&CVScroll) { // || tcontrol->Bits&CHScroll)
sprintf(tstr,"%s%s",PStatus.PrefixVScrollUp,tcontrol->name);
//sprintf(tstr,"ScrollUp_%s",tcontrol->name);
tcontrol2.x1=tcontrol->x2;
tcontrol2.y1=tcontrol->y1;
tcontrol2.z=-100; //above other controls
//tcontrol2.tab=-1;
//tcontrol2.Bits|=(tcontrol->Bits&(CGrowX1|CGrowY1|CGrowX2|CGrowX2));
//tcontrol2.gx1=-40;//tcontrol2.x1-twin->w;
//tcontrol2.gx2=-24;//tcontrol2.x2-twin->w;
//tcontrol2.win=twin->num;
tcontrol2.image=LoadBitmapAndScale(path,tcontrol2.x2-tcontrol2.x1,tcontrol2.y2-tcontrol2.y1);
//tcontrol2.image=LoadBitmap("images/gray.bmp",tcontrol2.x2-tcontrol2.x1,tcontrol2.y2-tcontrol2.y1);
sprintf(tstr,"%s%s",PStatus.PrefixVScrollDown,tcontrol->name);
//sprintf(tstr,"ScrollDown_%s",tcontrol->name);
tcontrol2.x1=tcontrol->x2;
tcontrol2.y1=tcontrol->y2-16;
tcontrol2.y2=tcontrol->y2;
tcontrol2.z=-100; //above other controls
tcontrol2.image=LoadBitmapAndScale(path,tcontrol2.x2-tcontrol2.x1,tcontrol2.y2-tcontrol2.y1);
//tcontrol2.gx1=tcontrol2.x1-twin->w;
//tcontrol2.gy1=tcontrol2.y1-twin->h;
//tcontrol2.gx2=tcontrol2.x2-twin->w;
//tcontrol2.gy2=tcontrol2.y2-twin->h;
//tcontrol2.gx1=-40;
//tcontrol2.gy1=-86;
//tcontrol2.gx2=-24;
//tcontrol2.gy2=-70;
//tcontrol2.win=twin->num;
sprintf(tstr,"%s%s",PStatus.PrefixVScrollBack,tcontrol->name);
//sprintf(tstr,"ScrollBack_%s",tcontrol->name);
tcontrol2.x1=tcontrol->x2;
tcontrol2.y1=tcontrol->y1+16;  //should get from scroll up
tcontrol2.y2=tcontrol->y2-16; //should get from scroll down
tcontrol2.z=-199; //above scrollbar back button
//tcontrol2.tab=-1;
//tcontrol2.gx1=-40;
//tcontrol2.gx2=-24;
//tcontrol2.gy2=-86;
//tcontrol2.win=twin->num;
sprintf(tstr,"%s%s",PStatus.PrefixVScrollSlide,tcontrol->name);
//sprintf(tstr,"ScrollSlide_%s",tcontrol->name);
tcontrol2.x1=tcontrol->x2;
tcontrol2.y1=tcontrol->y1+16;  //should get from scroll 
tcontrol2.y2=tcontrol->y2-16;  //should get from scroll 
tcontrol2.z=-200; //above other controls
if (tcontrol->Bits&CHScroll) { 
sprintf(tstr,"%s%s",PStatus.PrefixHScrollLeft,tcontrol->name);
//sprintf(tstr,"ScrollUp_%s",tcontrol->name);
tcontrol2.x1=tcontrol->x1;
tcontrol2.y1=tcontrol->y2;
tcontrol2.z=-200; //above other controls
//tcontrol2.tab=-1;
tcontrol2.image=LoadBitmapAndScale(path,tcontrol2.x2-tcontrol2.x1,tcontrol2.y2-tcontrol2.y1);
//tcontrol2.image=LoadBitmap("images/gray.bmp",tcontrol2.x2-tcontrol2.x1,tcontrol2.y2-tcontrol2.y1);
sprintf(tstr,"%s%s",PStatus.PrefixHScrollRight,tcontrol->name);
//sprintf(tstr,"ScrollDown_%s",tcontrol->name);
tcontrol2.x1=tcontrol->x2-16;
tcontrol2.y1=tcontrol->y2;
tcontrol2.z=-200; //above other controls
//tcontrol2.tab=-1;
tcontrol2.image=LoadBitmapAndScale(path,tcontrol2.x2-tcontrol2.x1,tcontrol2.y2-tcontrol2.y1);
sprintf(tstr,"%s%s",PStatus.PrefixHScrollBack,tcontrol->name);
//sprintf(tstr,"ScrollBack_%s",tcontrol->name);
tcontrol2.x1=tcontrol->x1+16;
tcontrol2.y1=tcontrol->y2;  //should get from scroll up
tcontrol2.x2=tcontrol->x2-16;
tcontrol2.z=-199; //above scrollbar back button
//tcontrol2.tab=-1;
//tcontrol2.win=twin->num;
sprintf(tstr,"%s%s",PStatus.PrefixHScrollSlide,tcontrol->name);
//sprintf(tstr,"ScrollSlide_%s",tcontrol->name);
tcontrol2.x1=tcontrol->x1+16;
tcontrol2.y1=tcontrol->y2;  //should get from scroll 
tcontrol2.x2=tcontrol->x2-16;
tcontrol2.z=-200; //above other controls
tcontrolf=tcontrol->parent;  //fileopen
    tcontrol->x3=tcontrol->x2-tcontrol->x1; //this FTControl is being resized, store new size 
    if (tcontrol->x1>tcontrolf->x2) tcontrol->x1=tcontrolf->x2;  //if resize goes over fileopen FTControl
    if (tcontrol->x2>tcontrolf->x2) tcontrol->x2=tcontrolf->x2;
    if (tcontrol->x1<tcontrolf->x1) tcontrol->x1=tcontrolf->x1;
    if (tcontrol->x2<tcontrolf->x1) tcontrol->x2=tcontrolf->x1;
//  if (tcontrolf->Bits&CFOSize) { //has Size
    sprintf(tstr,"%s%s",PStatus.PrefixSize,tcontrolf->name);
      bw=tcontrol2->x3;  //original size
      tcontrol2->x1=tcontrol->x2; //adjust button 2
      if (tcontrol2->x1+bw<tcontrolf->x2) tcontrol2->x2=tcontrol2->x1+bw;
      else tcontrol2->x2=tcontrolf->x2;
//  if (tcontrolf->Bits&CFODate) { //has Date
    sprintf(tstr,"%s%s",PStatus.PrefixDate,tcontrolf->name);
      bw=tcontrol3->x3; //original size
      //bw=tcontrol4->x2-tcontrol4->x1;  //original size
      tcontrol3->x1=tcontrol2->x2; //adjust button 3
      if (tcontrol3->x1+bw<tcontrolf->x2) tcontrol3->x2=tcontrol3->x1+bw;
      else tcontrol3->x2=tcontrolf->x2;
      if (tcontrol3->x2<tcontrolf->x2) tcontrol3->x2=tcontrolf->x2;
  if (tcontrol->ilist2!=0) {
    tFTItem=tcontrol->ilist2->item;
      tcontrol2=GetFTControl(tFTItem->name);  //get button 1 (name)
      tcontrol2->x3=tcontrol2->x2-tcontrol2->x1; //this FTControl is being resized, store new size 
//      fprintf(stderr,"1=%s\n",tcontrol2->name);
        if (tcontrol2->x1>tcontrol->x2) tcontrol2->x1=tcontrol->x2;  //if resize goes over fileopen FTControl
        if (tcontrol2->x2>tcontrol->x2) tcontrol2->x2=tcontrol->x2;
        if (tcontrol2->x1<tcontrol->x1) tcontrol2->x1=tcontrol->x1;
        if (tcontrol2->x2<tcontrol->x1) tcontrol2->x2=tcontrol->x1;
        tFTItem=(FTItem *)tFTItem->next;
          tcontrol3=GetFTControl(tFTItem->name);  //get button 2 (size)
//          fprintf(stderr,"2=%s\n",tcontrol3->name); 
            bw=tcontrol3->x3;  //original size
            //bw=tcontrol3->x2-tcontrol3->x1;  //original size
            tcontrol3->x1=tcontrol2->x2; //adjust button 2
            if (tcontrol3->x1+bw<tcontrol->x2) tcontrol3->x2=tcontrol3->x1+bw;
            else tcontrol3->x2=tcontrol->x2;
            tFTItem=(FTItem *)tFTItem->next;
              tcontrol4=GetFTControl(tFTItem->name);  //get button 3 (date)
//              fprintf(stderr,"3=%s\n",tcontrol4->name); 
                bw=tcontrol4->x3; //original size
                //bw=tcontrol4->x2-tcontrol4->x1;  //original size
                tcontrol4->x1=tcontrol3->x2; //adjust button 3
                if (tcontrol4->x1+bw<tcontrol->x2) tcontrol4->x2=tcontrol4->x1+bw;
                else tcontrol4->x2=tcontrol->x2;
                if (tcontrol4->x2<tcontrol->x2) tcontrol4->x2=tcontrol->x2;
  } //tFTItem->ilist2!=0
  tcontrolf=tcontrol->parent;
  fw=tcontrol->font->max_bounds.width; //was ascent
  //sprintf(tstr,"%s%s",PStatus.PrefixName,tcontrolf->name);
	sprintf(tstr,"%s%s",PStatus.PrefixName,tcontrolf->name);
  sprintf(tstr,"%s%s",PStatus.PrefixDate,tcontrolf->name);
    if (tcontrol->x1>tcontrolf->x2) tcontrol->x1=tcontrolf->x2;  
    if (tcontrol->x2>tcontrolf->x2) tcontrol->x2=tcontrolf->x2;
    if (tcontrol->x1<tcontrol2->x1+fw) tcontrol->x1=tcontrol2->x1+fw;  
    if (tcontrol->x2<tcontrolf->x1) tcontrol->x2=tcontrolf->x1;
    tcontrol->x3=tcontrol->x2-tcontrol->x1; //this FTControl is being resized, store new size 
    bw=tcontrol->x3;  //original size
//              fprintf(stderr,"2=%s\n",tcontrol3->name); 
       tcontrol2->x2=tcontrol->x1; //adjust button 1
//       if (tcontrol->x1+bw<tcontrolf->x2) tcontrol->x2=tcontrol->x1+bw;
       if (tcontrol->x1<tcontrol2->x1+fw) tcontrol->x1=tcontrol2->x2+fw;
//       else tcontrol->x2=tcontrolf->x2;
       if (tcontrol->x1>tcontrol->x2-fw) tcontrol->x1=tcontrol->x2-fw;
      if (tcontrol->x2<tcontrol->x1+fw) tcontrol->x2=tcontrol->x1+fw;
      if (tcontrol->x2>tcontrolf->x2-fw) tcontrol->x2=tcontrolf->x2-fw;
//              fprintf(stderr,"3=%s\n",tcontrol4->name); 
      bw=tcontrol3->x3; //original size
      tcontrol3->x1=tcontrol->x2; //adjust button 3
//      if (tcontrol3->x1+bw<tcontrolf->x2) tcontrol3->x2=tcontrol3->x1+bw;
      if (tcontrol3->x1+fw<tcontrolf->x2) tcontrol3->x2=tcontrol3->x1+fw;
      else tcontrol3->x2=tcontrolf->x2;
      if (tcontrol3->x2<tcontrolf->x2) tcontrol3->x2=tcontrolf->x2;
  if (tcontrol->ilist2!=0) {
    tFTItem=tcontrol->ilist2->item;
      tcontrol2=GetFTControl(tFTItem->name);  //get button 1 (name)
//      fprintf(stderr,"1=%s\n",tcontrol2->name);
        tFTItem=(FTItem *)tFTItem->next;
          tcontrol3=GetFTControl(tFTItem->name);  //get button 2 (size)
//          fprintf(stderr,"2=%s\n",tcontrol3->name); 
            if (tcontrol3->x1>tcontrol->x2) tcontrol3->x1=tcontrol->x2;  
            if (tcontrol3->x2>tcontrol->x2) tcontrol3->x2=tcontrol->x2;
            if (tcontrol3->x1<tcontrol2->x1+8) tcontrol3->x1=tcontrol2->x1+8;  
            if (tcontrol3->x2<tcontrol->x1) tcontrol3->x2=tcontrol->x1;
            tcontrol3->x3=tcontrol3->x2-tcontrol3->x1; //this FTControl is being resized, store new size 
            bw=tcontrol3->x3;  //original size
            //bw=tcontrol3->x2-tcontrol3->x1;  //original size
//              fprintf(stderr,"2=%s\n",tcontrol3->name); 
              tcontrol2->x2=tcontrol3->x1; //adjust button 1
              if (tcontrol3->x1+bw<tcontrol->x2) tcontrol3->x2=tcontrol3->x1+bw;
              else tcontrol3->x2=tcontrol->x2;
//              if (tcontrol3->x1+bw<tcontrol->x2) tcontrol3->x2=tcontrol3->x1+bw;
//              else tcontrol3->x2=tcontrol->x2;
              if (tcontrol3->x2<tcontrol3->x1) tcontrol3->x2=tcontrol3->x1;
//              else tcontrol3->x1=tcontrol->x1;
            tFTItem=(FTItem *)tFTItem->next;
              tcontrol4=GetFTControl(tFTItem->name);  //get button 3 (date)
//              fprintf(stderr,"3=%s\n",tcontrol4->name); 
                bw=tcontrol4->x3; //original size
                //bw=tcontrol4->x2-tcontrol4->x1;  //original size
                tcontrol4->x1=tcontrol3->x2; //adjust button 3
                if (tcontrol4->x1+bw<tcontrol->x2) tcontrol4->x2=tcontrol4->x1+bw;
                else tcontrol4->x2=tcontrol->x2;
                if (tcontrol4->x2<tcontrol->x2) tcontrol4->x2=tcontrol->x2;
  } //tFTItem->ilist2!=0
  tcontrolf=tcontrol->parent;
  fw=tcontrol->font->max_bounds.width;//was ascent;
//  sprintf(tstr,"%s%s",PStatus.PrefixName,tcontrolf->name);
  sprintf(tstr,"%s%s",PStatus.PrefixSize,tcontrolf->name);
    if (tcontrol->x1>tcontrolf->x2-fw) tcontrol->x1=tcontrolf->x2-fw;  
    if (tcontrol->x1<tcontrol2->x1+fw) tcontrol->x1=tcontrol2->x1+fw;  
    tcontrol->x3=tcontrol->x2-tcontrol->x1; //this FTControl is being resized, store new size 
    bw=tcontrol->x3;  //original size
       tcontrol2->x2=tcontrol->x1; //adjust button 2
//       if (tcontrol->x1+bw<tcontrolf->x2) tcontrol->x2=tcontrol->x1+bw;
//       else tcontrol->x2=tcontrolf->x2;
//       if (tcontrol->x1>tcontrol->x2-fw) tcontrol->x1=tcontrol->x2-fw;
  if (tcontrol->ilist2!=0) {
    tFTItem=tcontrol->ilist2->item;
      tcontrol2=GetFTControl(tFTItem->name);  //get button 1 (name)
//      fprintf(stderr,"1=%s\n",tcontrol2->name);
        tFTItem=(FTItem *)tFTItem->next;
          tcontrol3=GetFTControl(tFTItem->name);  //get button 2 (size)
//          fprintf(stderr,"2=%s\n",tcontrol3->name); 
            tFTItem=(FTItem *)tFTItem->next;
              tcontrol4=GetFTControl(tFTItem->name);  //get button 3 (date)
              tcontrol4->x3=tcontrol4->x2-tcontrol4->x1; //this FTControl is being resized, store new size 
//              fprintf(stderr,"3=%s\n",tcontrol4->name); 
//is last FTControl in header, will always have x2=tcontrol->x2
                if (tcontrol4->x1>tcontrol->x2) tcontrol4->x1=tcontrol->x2;  
                if (tcontrol4->x2>tcontrol->x2) tcontrol4->x2=tcontrol->x2;
                if (tcontrol4->x1<tcontrol3->x1) tcontrol4->x1=tcontrol3->x1;  
//                if (tcontrol4->x2<tcontrol3->x1) tcontrol4->x2=tcontrol3->x1;
                tcontrol3->x2=tcontrol4->x1; //adjust button 2
                bw=tcontrol4->x3;  //original size
                if (tcontrol4->x1+bw<tcontrol->x2) tcontrol4->x2=tcontrol4->x1+bw;
                else tcontrol4->x2=tcontrol->x2;
                if (tcontrol4->x2<tcontrol->x2) tcontrol4->x2=tcontrol->x2;
  } //tFTItem->ilist2!=0
tcontrol=tcontrol->parent;
if (tcontrol->i[2]&0x1) tcontrol->i[2]&=~0x1;  //change direction of sort
else tcontrol->i[2]|=0x1;
tcontrol->i[1]=0; //Sort by Name
if (tcontrol->ilist!=0)  tcontrol->ilist->Bits|=FTIL_REREAD;
fprintf(stderr,"after name sort %d\n",tcontrol->i[2]);
tcontrol=tcontrol->parent;
if (tcontrol->i[2]&0x2) tcontrol->i[2]&=~0x2;  //change direction of sort
else tcontrol->i[2]|=0x2;
tcontrol->i[1]=1;  //Sort by Size
if (tcontrol->ilist!=0)  tcontrol->ilist->Bits|=FTIL_REREAD;
tcontrol=tcontrol->parent;
if (tcontrol->i[2]&0x4) tcontrol->i[2]&=~0x4;  //change direction of sort
else tcontrol->i[2]|=0x4;
tcontrol->i[1]=2;  //Sort by Date
if (tcontrol->ilist!=0)  tcontrol->ilist->Bits|=FTIL_REREAD;
	tcontrol=twin->icontrol;
		//fprintf(stderr,"DelFTControl %s\n",tcontrol->name);
		ncontrol=tcontrol->next; //after DelFTControl tcontrol=0 so preserve tcontrol->next
//		fprintf(stderr,"in DelAllFTControls next is %s %p\n",ncontrol->name,ncontrol);
		DelFTControl2(&tcontrol,0);  //0=do not delete associated controls -since these will be deleted in this loop
//		fprintf(stderr,"in DelAllFTControls after DelFTControl, next is %s %p\n",ncontrol->name,ncontrol);
//  DelFTControl(&twin->icontrol);
	if (tcontrol->ilist!=0) {
		CloseFTItemListAll(tcontrol->ilist); //destroy this itemlist and all subitemlists recursively
  tcontrol=twin->icontrol;
  twin2=GetFTWindow(tcontrol->submenu);  //perhaps submenu should be a pointer
//    fprintf(stderr,"submenu=%s\n",tcontrol->submenu);
    fprintf(stderr,"Close %s\n",twin2->name);
     //have to adjust in PStatus->iwindow for GetInput(void)
    //DestroyFTWindowByNum(twin2->num);
  DelFTControl(&twin->icontrol);
		fprintf(stderr,"DelFTControl %s\n",(*tcontrol)->name);
	//  fprintf(stderr,"(*tcontrol)->next=%p\n",(*tcontrol)->next);
	dcontrol=*tcontrol;  //icontrol=&twin->icontrol
	//if this control has a vertical or horizontal scroll bar control attached - delete those controls too
		if (DelAC && ((dcontrol->Bits&CVScroll) || (dcontrol->Bits&CHScroll))) {
	//if this control has a a filen name, size, or date button attached - delete those controls too
		if (DelAC && ((dcontrol->Bits&CFOName) || (dcontrol->Bits&CFOSize) || (dcontrol->Bits&CFODate))) {
	//but if this is the first control - we would have to get the window to set icontrol=0
	//twin=GetFTWindowN(dcontrol->win);
	twin=dcontrol->window;
	//fprintf(stderr,"twin->icontrol=%p\n",twin->icontrol);
	lcontrol=twin->icontrol;
	//fprintf(stderr,"FTControl %s\n",lFTControl->name);
//		  fprintf(stderr,"Deleting FTControl %s\n",dcontrol->name);
	//    fprintf(stderr,"twin->icontrol=%p\n",twin->icontrol);
//		fprintf(stderr,"Moving last %s next pointer\n",last->name);
//		fprintf(stderr,"Moving last %s next pointer=%p\n",last->name,lcontrol->next);
	//if this is the first control - set window first control to next control
		if (twin->icontrol==lcontrol) twin->icontrol=lcontrol->next;
		else last->next=lcontrol->next;  //remove tcontrol from FTControl list  
	//    fprintf(stderr,"Deleting2 FTControl %s\n",dFTControl->name);
	//    fprintf(stderr,"ilist=%p\n",dFTControl->ilist);
	//    fprintf(stderr,"ilist2=%p\n",dFTControl->ilist2);
	//  if (tcontrol->ilist) FreeFTItemList(&dFTControl->ilist);
	//  if (tcontrol->ilist) FreeFTItemList(tcontrol->ilist);
		//CloseFTWindow does not free the FTWindow structure for itemlist windows -
		if (dcontrol->ilist) {
			DelFTItemList(dcontrol->ilist);      
			dcontrol->ilist=0;
	//tcontrol is being deleted - so don't worry about setting tcontrol->ilist=0 
	//  if (dFTControl->ilist2) FreeFTItemList(&dFTControl->ilist2);
		//fprintf(stderr,"tcontrol->ilist=%p\n",tcontrol->ilist);
	//    fprintf(stderr,"2twin->icontrol=%p\n",twin->icontrol);
		if (dcontrol->data!=0)
		  //fprintf(stderr,"tcontrol=%p &tcontrol->data=%p tcontrol->data=%p\n",tcontrol,&tcontrol->data,tcontrol->data);
	//    if (tcontrol->win==0) {//this is a delete of a special "track" FTControl, 
	//      tcontrol2=PStatus.iwindow->icontrol;
		      tcontrol2=twin2->icontrol;
		     	  if (tcontrol2->data!=0 && tcontrol2->data==dcontrol->data) {
		         //fprintf(stderr,"Data still used by FTControl %s\n",tcontrol2->name);
		        tcontrol2=tcontrol2->next;
		      twin2=twin2->next;
		         //fprintf(stderr,"free tcontrol->data %p",tcontrol->data);
		         free(dcontrol->data);
		         dcontrol->data=0;
							if (dcontrol->Bits2&CDataFileOpen) {
								fclose(dcontrol->datafptr);
								dcontrol->Bits2&=~CDataFileOpen;
		     }  //end if tcontrol->data!=0 (FTControl has data)
	//    fprintf(stderr,"3twin->icontrol=%p\n",twin->icontrol);
		      if(dcontrol->image!=0) {  //when something is freed it may not == 0 after
		         XDestroyImage(dcontrol->image);
		         //(*tcontrol)->image=0; //doesn't matter tcontrol is being destroyed anyway
		      if(dcontrol->image2!=0) {  //when something is freed it may not == 0 after
		         XDestroyImage(dcontrol->image2);
		         //(*tcontrol)->image2=0;
		      if(dcontrol->erase!=0) {  //when something is freed it may not == 0 after
		         XDestroyImage(dcontrol->erase);
		         //(*tcontrol)->erase=0;
		      if(dcontrol->bmpinfo!=0) {  
		         free(dcontrol->bmpinfo);
		         //(*tcontrol)->bmpinfo=0;
	//        if (lFTControl==tcontrol && tcontrol->next==0) 
	//        fprintf(stderr,"last->name=%s\n",last->name);
	//twin->icontrol
	//        last->next=dFTControl->next;  
	//        fprintf(stderr,"last->next=%p\n",last->next);
//	        fprintf(stderr,"free dcontrol %p %s\n",dcontrol,dcontrol->name);
		      *tcontrol=0; //doesn't matter - but calling program will have to know that control was deleted and address not valid anymore even if not 0 - just less confusing not to have to pass pointer
		lcontrol=lcontrol->next;
//	fprintf(stderr,"Going to next control to delete: lcontrol->next=%p %s\n",lcontrol,lcontrol->name);
//if a fileopen control is deleted - there are associated (sub) controls that need to be deleted too
  if ((*tcontrol)->Bits&CFOName) {
    sprintf(tstr,"%s%s",PStatus.PrefixName,(*tcontrol)->name);
			//better to have a double-linked list
    (*tcontrol)->Bits&=~CFOName; //remove name flag from this control
  if ((*tcontrol)->Bits&CFOSize) {
    sprintf(tstr,"%s%s",PStatus.PrefixSize,(*tcontrol)->name);
    (*tcontrol)->Bits&=~CFOSize;
  if ((*tcontrol)->Bits&CFODate) {
    sprintf(tstr,"%s%s",PStatus.PrefixDate,(*tcontrol)->name);
    (*tcontrol)->Bits&=~CFODate;
  if ((*tcontrol)->Bits&CVScroll) {
    sprintf(tstr,"%s%s",PStatus.PrefixVScrollUp,(*tcontrol)->name);
    sprintf(tstr,"%s%s",PStatus.PrefixVScrollDown,(*tcontrol)->name);
    sprintf(tstr,"%s%s",PStatus.PrefixVScrollBack,(*tcontrol)->name);
    sprintf(tstr,"%s%s",PStatus.PrefixVScrollSlide,(*tcontrol)->name);
   (*tcontrol)->Bits&=~CVScroll;
//maintain tcontrol->num here? or each time AddFTItem?
if (litem->name==0) {
  fprintf(stderr,"AddFTItem %s\n",litem->name);
if ((*litemList)->item==0) { //is just the FTItemList no initial FTItem
  (*litemList)->item=(FTItem *)malloc(sizeof(FTItem));
  litem2=(*litemList)->item; 
  litem2=(*litemList)->item;
  while(litem2->next!=0) {
    litem2=litem2->next;
  litem2->next=(FTItem *)malloc(sizeof(FTItem));
  //fprintf(stderr,"malloc litem->next %d %p\n",sizeof(FTItem),litem->next); 
  ////fprintf(stderr,"malloc=%p\n",litem->next);
  litem2=litem2->next;
if (strlen(litem->name)>0) {
  litem2->name=(char *)malloc(strlen(litem->name)+1);
  //fprintf(stderr,"malloc litem->name %d %p\n",strlen(name),litem->name);
  ////fprintf(stderr,"malloc=%p\n",litem->name);
  strcpy(litem2->name,litem->name); 
  litem2->name=(char *)malloc(1);
  //fprintf(stderr,"malloc FTItem->name 1 %p\n",litem->name);
  litem2->name[0]=0;
if (litem->submenu!=0 && strlen(litem->submenu)>0) {
  litem2->submenu=(char *)malloc(strlen(litem->submenu)+1);
  strcpy(litem2->submenu,litem->submenu);
  //fprintf(stderr,"malloc litem->name %d %p\n",strlen(name),litem->name); 
litem2->i=(last!=0)?last->i+1:0;//1;  
litem2->next=0;
(*litemList)->num++;
//fprintf(stderr,"added FTItem %s with i=%d\n",litem->name,litem->i);
  fprintf(stderr,"AddFTItem Done %d\n",litem2->i);
//Instead of AddFTItem(control, name, clickfunction1, clickfunction2, etc) - simply
  fprintf(stderr,"AddFTItem %s\n",titem->name);
if (tcontrol->ilist==0) { //no FTItems yet
	//fprintf(stderr,"no FTItems in %s yet\n",tcontrol->name);
	tcontrol->ilist=(FTItemList *)malloc(sizeof(FTItemList));
	memset(tcontrol->ilist,0,sizeof(FTItemList));
	tcontrol->ilist->control=tcontrol;
	tcontrol->ilist->cur=0;
	tcontrol->ilist->orig=0;
	tcontrol->ilist->font=tcontrol->font;
	if (tcontrol->type==CTCombo) {
		//for Combo controls, unlike other itemlist windows - the width is only the size of the control
//actually I don't know - the window could be bigger, or their could be a scroll bar
		tcontrol->ilist->width=tcontrol->x2-tcontrol->x1; 
} //tcontrol->ilist==0
litem=tcontrol->ilist->item;
maxwidth=FTstrlen(titem->name); //get length of new item name
	if (FTstrlen(litem->name)>maxwidth) { //this item name length is longer than any other
		maxwidth=FTstrlen(litem->name);
	litem=(FTItem *)litem->next;
if (tcontrol->ilist->num==0) {//first item in itemlist
	tcontrol->ilist->item=litem;
	last->next=litem;
tcontrol->ilist->num++;
litem->parent=tcontrol->ilist;
tcontrol->ilist->height=tcontrol->ilist->num*(tcontrol->ilist->font->max_bounds.ascent+tcontrol->ilist->font->max_bounds.descent+PStatus.PadY); //one extra PadY for bottom area
if (tcontrol->type!=CTCombo) {
	tcontrol->ilist->width=(maxwidth+1)*tcontrol->ilist->font->max_bounds.width;//+PStatus.PadX);
	//fprintf(stderr,"ilist width=%d\n",tcontrol->ilist->width);
litem->num=tcontrol->ilist->num; //set item number
//fprintf(stderr,"added FTItem %s with i=%d\n",litem->name,litem->i);
//AddFTSubItem - add a subitem to an item
//Perhaps just one AddFTItem(tlist,item,num)- and doing away with AddFTSubItem(), but then the problem of choosing which item will have the subitemlist - this "SubItem" function is the most logical method I can think of for now.
if (titem->ilist==0) {  //no subitems on this item yet
	titem->ilist=(FTItemList *)malloc(sizeof(FTItemList));
	memset(titem->ilist,0,sizeof(FTItemList));
	titemlist=titem->ilist;
	titemlist->parent=titem->parent;
	titemlist->control=titem->parent->control; //set control to parent control for LostFocus to close
	titemlist->font=titemlist->parent->font;
	titemlist->cur=0;
	titemlist->orig=0;
litem=titem->ilist->item;
maxwidth=FTstrlen(titem2->name); //length of name of item being added
	if (FTstrlen(litem->name)>maxwidth) {  //this item name is longer than all others
		maxwidth=FTstrlen(litem->name);
	litem=litem->next;
if (titem->ilist->num==0) {//first item in itemlist
	titem->ilist->item=litem;
	last->next=litem;
titem->ilist->num++;
litem->parent=titem->ilist;
litem->num=titem->ilist->num; 
titemlist=litem->parent;
titemlist->width=(maxwidth+1)*titemlist->font->max_bounds.width;//+PStatus.PadX*2);
titemlist->height=titemlist->num*(titemlist->font->max_bounds.ascent+titemlist->font->max_bounds.descent+PStatus.PadY);
//FTstrlen - strlen that excludes &
//maintain tcontrol->num here? or each time AddFTItem?
  //fprintf(stderr,"tcontrol->ilist=%p\n",tcontrol->ilist);
  //fprintf(stderr,"tcontrol->ilist->item=%p\n",tcontrol->ilist->item);
  //fprintf(stderr,"tcontrol->ilist->item->name=%s\n",tcontrol->ilist->item->name);
titem=tcontrol->ilist->item;
	if (strcmp(titem->name,name)==0) {
titem=titem->next;
titem=tcontrol->ilist->item;
titem=titem->next;
titem=tlist->item;
	if (strcmp(titem->name,name)==0) {
titem=titem->next;
titem=tlist->item;
titem=titem->next;
		if (titem->parent!=0) {
			tlist=titem->parent;				
			tcontrol2=tlist->control;
				tcontrol2->value=titem->num;
				strcpy(tcontrol2->text,titem->name);
		} //titem->parent!=0
		if (titem->parent!=0) {
			tlist=titem->parent;				
			tcontrol2=tlist->control;
				tcontrol2->value=titem->num;
				strcpy(tcontrol2->text,titem->name);
		} //titem->parent!=0
//for a mouse click - 
//GetSelectedFTItem - go through an itemlist (and all open subitemlist windows) and return the current (itemlist->cur) selected item
	if (tlist->cur==0) { //no current item in tlist
		titem=GetFTSubItemByNum(tlist,tlist->cur);
		if (titem->ilist!=0) { //there is a subitemlist
			tlist2=titem->ilist;
			if (tlist2->window!=0) {//itemlist has a window
				twin=tlist2->window;
				if (twin->Bits&WOpen) {  //subitemlist window is open
				}//twin->Bits&WOpen
			} //tlist2->window!=0
		} else { //titem->ilist!=0 item has no subitemlist
		} //titem->ilist		
	} //tlist->cur==0
//GetSelectedFTItemList - returns most recent open ItemList
if (tcontrol->Bits&CItemListOpen) {
	return(GetSelectedFTItemList(tcontrol->ilist));
} //tcontrol->Bits
//GetSelectedFTItemList - returns the current FTItemList that has a selection
//GetTopFTItemList - returns the topmost FTItemList - even if it has no selected item
//(possibly PStatus.ilist - current ilist with selection?)
//- this is replaced by using PStatus.SelectedFTItem - which does not need recursion
	if (tlist->window!=0) {
		twin=tlist->window;
		if (twin->Bits&WOpen) {//window is open
			if (tlist->cur==0) { //itemlist has no selected item
				if (tlist->parent==0) {//this is the top level
				} else { //this is a subitemlist - if no selection return 0
					return(0); //return 0 - because we only want itemlist with selection
				} //tlist->parent==0
			} else { //tlist->cur==0
				titem=GetFTSubItemByNum(tlist,tlist->cur);
				if (titem->ilist!=0) { //item has subitemlist
					return(GetSelectedFTItemList(titem->ilist));
				} //titem->ilist!=0 - item has subitemlist
			} //tlist->cur==0 			
		} else {//twin->Bits&WOpen
			//window is not open - return 0
		}  //twin->Bits&WOpen window is open
	} else { //tlist->window!=0 itemlist has an assocaited window
		return(0);  //itemlist has no window -return(0)
	} //tlist->window!=0 itemlist has an assocaited window
litem=tcontrol->ilist->item;
		litem->num--;
	//if items have same name - just delete first
		if (strcmp(litem->name,name)==0) {
				tcontrol->ilist->item=litem->next;
				last->next=litem->next;
			tcontrol->ilist->num--; //decrease number of items in this control item list
			if (litem->ilist!=0) {  //there are subitems which need to be deleted 
				DelFTItemList(litem->ilist);
				litem->ilist=0;
				//dont worry about setting litem->ilist=0 since this itemlist is being deleted anyway
			} //litem->item 
			if (tcontrol->ilist->num==0) {
				free(tcontrol->ilist);  //no more items in this control item list, free the list head
				tcontrol->ilist=0;
				tlist=tcontrol->ilist;
				tlist->height=tlist->num*(tlist->font->max_bounds.ascent+tlist->font->max_bounds.descent+PStatus.PadY);
				litem2=tlist->item;
					if (strlen(litem2->name)>maxwidth) {
						maxwidth=strlen(litem->name);
					litem2=litem2->next;
				tlist->width=maxwidth*tlist->font->max_bounds.width;//+PStatus.PadX*2);
			} //tcontrol->ilist->num==0					
litem=litem->next;
litem=tcontrol->ilist->item;
		litem->num--;
				tcontrol->ilist->item=litem->next;
				last->next=litem->next;
			tcontrol->ilist->num--; //decrease number of items in this control item list
			if (litem->ilist!=0) {  //there are subitems which need to be deleted 
				DelFTItemList(litem->ilist);
				litem->ilist=0;
			} //litem->item 
			if (tcontrol->ilist->num==0) {
				free(tcontrol->ilist);  //no more items in this control item list, free the list head
				tcontrol->ilist=0;
				tlist=tcontrol->ilist;
				tlist->height=tlist->num*(tlist->font->max_bounds.ascent+tlist->font->max_bounds.descent+PStatus.PadY);
				litem2=tlist->item;
					if (strlen(litem2->name)>maxwidth) {
						maxwidth=strlen(litem->name);
					litem2=litem2->next;
				tlist->width=maxwidth*tlist->font->max_bounds.width;//+PStatus.PadX*2);
			} //tcontrol->ilist->num==0					
litem=litem->next;
//DelAllFTItems - delete all items from a control recursively
DelFTItemList(tcontrol->ilist);
tcontrol->ilist=0;
tcontrol->value=0;
//DelFTItemList - delete all items in a list recursively
//could be problem because deleting tlist in a control will not set control->ilist=0
	litem=tlist->item;
		if (litem->ilist!=0) { //this FTItem has a subitem that needs to be deleted
			DelFTItemList(litem->ilist);
			litem->ilist=0;
		litem=litem->next;
	if (tlist->window!=0) {  //there is a window associated with this itemlist
		twin=tlist->window;
//no need for these two calls (close+destroy) since CloseFTWindow calls DestroyFTWindow		if (twin->Bits&WOpen) {
			//we need to explicitly destroy the FTWindow structure here - 
			//just CloseFTItemList does not destroy the FTWindow structure - 
			tlist->window=0;
//		} //twin->Bits&WOpen
//		fprintf(stderr,"DestroyFTWindow in DelFTItemList %s\n",twin->name);
	} //tlist->window!=0
if (tlist->parent==0) {
	if (tlist->control!=0) {
		tlist->control->ilist=0; //this ilist will now be freed
		tlist->control->value=0;
	} //tlist->control!=0
} else {//tlist->parent==0
//perhaps tlist->parent should be FTItem descended from
	titem=tlist->parent->item;
		if (titem->ilist==tlist) {
			titem->ilist=0; //freeing this ilist
		titem=titem->next;
//	tlist->parent->ilist=0; //this sub ilist will now be freed
}  //tlist->parent==0
if (titem->ilist==0) {
litem=titem->ilist->item;
		litem->num--;
		if (strcmp(litem->name,name)==0) {
				titem->ilist->item=litem->next;
				last->next=litem->next;
			titem->ilist->num--; //decrease number of items in this control item list
			if (litem->ilist!=0) {  //there are subitems which need to be deleted 
				DelFTItemList(litem->ilist);
				litem->ilist=0;
			} //litem->item 
			if (titem->ilist->num==0) {
				free(titem->ilist);  //no more items in this control item list, free the list head
				titem->ilist=0;
				tlist=titem->ilist;
				tlist->height=tlist->num*(tlist->font->max_bounds.ascent+tlist->font->max_bounds.descent+PStatus.PadY);
				litem2=tlist->item;
					if (strlen(litem2->name)>maxwidth) {
						maxwidth=strlen(litem->name);
					litem2=litem2->next;
				tlist->width=maxwidth*tlist->font->max_bounds.width;//+PStatus.PadX*2);
			} //titem->ilist->num==0					
litem=litem->next;
if (titem->ilist==0) {
litem=titem->ilist->item;
		litem->num--;
				titem->ilist->item=litem->next;
				last->next=litem->next;
			titem->ilist->num--; //decrease number of items in this control item list
			if (litem->ilist!=0) {  //there are subitems which need to be deleted 
				DelFTItemList(litem->ilist);
				litem->ilist=0;
			} //litem->item 
			if (titem->ilist->num==0) {
				free(titem->ilist);  //no more items in this control item list, free the list head
				titem->ilist=0;
				tlist=titem->ilist;
				tlist->height=tlist->num*(tlist->font->max_bounds.ascent+tlist->font->max_bounds.descent+PStatus.PadY);
				litem2=tlist->item;
					if (strlen(litem2->name)>maxwidth) {
						maxwidth=strlen(litem->name);
					litem2=litem2->next;
				tlist->width=maxwidth*tlist->font->max_bounds.width;//+PStatus.PadX*2);
			} //titem->ilist->num==0					
litem=litem->next;
litem=(*litemList)->item;
  while(litem!=0 && strcmp(litem->name,name)!=0) {
    litem=(FTItem *)litem->next;
  //fprintf(stderr,"free litem->name %p",litem->name);
  free(litem->name);
  if (litem->submenu!=0) free(litem->submenu);
  if (last!=0) last->next=litem->next;
  (*litemList)->num--;
while(litem!=0 && litem->i!=num) {
  litem=(FTItem *)litem->next;
//fprintf(stderr,"free litem->name %p",litem->name);
free(litem->name);
if (litem->submenu!=0) free(litem->submenu);
if (last!=0) last->next=litem->next;
(*litemList)->num--;
litem=(*litemList)->item;
  next=(FTItem *)litem->next;
  //fprintf(stderr,"free litem->name %p\n",litem->name);
  free(litem->name);
  if (litem->submenu!=0) free(litem->submenu);
litem=(*litemList)->item;
  next=(FTItem *)litem->next;
  //fprintf(stderr,"free litem->name %p\n",litem->name);
  free(litem->name);
  if (litem->submenu!=0) free(litem->submenu);
(*litemList)->item=0;
(*litemList)->num=0;
  litem=tlist->item;
    if (litem->next!=0) {
      litem2=(FTItem *)litem->next;
      if (!(litem->Bits&FTI_FOLDER) && litem2->Bits&FTI_FOLDER) swap=1;
      if (!swap && (litem->Bits&FTI_FOLDER)==(litem2->Bits&FTI_FOLDER)) {
            if (strcmp(litem->name,litem2->name)>0 && !td) swap=1;
              if (strcmp(litem->name,litem2->name)<0 && td) swap=1;
            if (litem->size>litem2->size && !td) swap=1;
              if (litem->size<litem2->size && td) swap=1;
              sprintf(tstr1,"%02d%02d%02d%02d%02d%02d",litem->idate.tm_year-100,litem->idate.tm_mon+1,litem->idate.tm_mday,litem->idate.tm_hour,litem->idate.tm_min,litem->idate.tm_sec);
              sprintf(tstr2,"%02d%02d%02d%02d%02d%02d",litem2->idate.tm_year-100,litem2->idate.tm_mon+1,litem2->idate.tm_mday,litem2->idate.tm_hour,litem2->idate.tm_min,litem2->idate.tm_sec);
//      if ((strcmp(litem->name,litem2->name)>0 && (litem->Bits&FTI_FOLDER)==(litem2->Bits&FTI_FOLDER)) || (!(litem->Bits&FTI_FOLDER) && litem2->Bits&FTI_FOLDER)) {
     //     fprintf(stderr,"swap %s %s\n",litem->name,litem2->name);
//         fprintf(stderr,"swap %d %d\n",litem->size,litem2->size);
          memcpy(&titem,litem,sizeof(FTItem));  //t<-a
          memcpy(litem,litem2,sizeof(FTItem));  //a<-b
          memcpy(litem2,&titem,sizeof(FTItem));  //b<-t
          litem2->next=litem->next;  
          litem2->num=litem->num;  
          litem->next=(FTItem *)titem.next;
          litem->num=titem.num;
    litem=litem->next;
//returns currently selected itemlist - although titem=GetSelectedFTItem, then titem->parent can be used - infact make GetCurrentFTItemList GetSelectedFTItem(tcontrol->ilist) then return titem->parent;
		if (titem->click(0)!=0) {
			(*titem->click(0)) (titem->window,titem->control,0,0);
//OpenNextFileControl - if there is a next tabbed file control, close this itemlist of this control and open the itemlist of the next one
//twin=GetFTWindowN(tcontrol->win);
twin=tcontrol->window;  
	//filemenus are ignored in tabbing - although perhaps could be included too
	if (tcontrol!=tcontrol2) { //if the same control - don't bother to close and open same itemlist
		fprintf(stderr,"next tab is %s\n",tcontrol2->name);
		//twin2=GetFTWindowN(tcontrol2->win); //could presume control is on same window
		twin2=tcontrol2->window; //could presume control is on same window
		twin2->focus=tcontrol2->tab;
		CloseFTItemList(tcontrol->ilist); //close current itemlist
		OpenFTItemList(tcontrol2->ilist); //open next tab itemlist
//OpenPrevFileControl - if there is a previous tabbed file control, close this itemlist of this control and open the itemlist of the previous one
//twin=GetFTWindowN(tcontrol->win);
twin=tcontrol->window;  
	//filemenus are ignored in tabbing - although perhaps could be included too
	if (tcontrol!=tcontrol2) { //if the same control - don't bother to close and open same itemlist
		fprintf(stderr,"previous tab is %s\n",tcontrol2->name);
		//twin2=GetFTWindowN(tcontrol2->win); //could presume control is on same window
		twin2=tcontrol2->window; //could presume control is on same window
		twin2->focus=tcontrol2->tab;
		CloseFTItemList(tcontrol->ilist); //close current itemlist
		OpenFTItemList(tcontrol2->ilist); //open next tab itemlist
tcontrol=twin->icontrol;
  if (tcontrol->Bits&CTTextBox || tcontrol->Bits&CTButton)
  if (tcontrol->next==0)  ex=1;
  else tcontrol=tcontrol->next;
    if (twin->num==i) {
      twin=twin->next;
//CreateFTWindow - mallocs the FTWindow memory, adds controls
  fprintf(stderr,"CreateFTWindow %s\n",w->name);
//   fprintf(stderr,"win x=%d y=%d\n",w->x,w->y);
nw=-1;
	//fprintf(stderr,"twin->name=%p\n",twin->name);
	twin->num=0;// first window is 0 but because PStatus.ExclWin=winnum change to 1,2,3,etc?
	twin->focus=0;  //should be 0? or -1?
	twin->icontrol=0;
	twin->next=0;
	//twin->Bits|=WNotVisible; //technically window not visible yet
	//twin->ow=w->w;   //store original w,h
	//twin->oh=w->h;
	if (twin->AddFTControls!=0) (*twin->AddFTControls) (twin);
  if (twin->icontrol!=0) twin->focus=1; //for now set FTControl that has tab=1 as FTControl w
		while (twin->next!=0) {
		  twin=(FTWindow *)twin->next;
		twin->next=(FTWindow *)malloc(sizeof(FTWindow));
		    //fprintf(stderr,"malloc twin->next %d %p\n",sizeof(FTWindow),twin->next);
		//    fprintf(stderr,"after malloc %p\n",twin->next);
		    twin=(FTWindow *)twin->next;
		    twin->icontrol=0;
		    twin->focus=0;
		    twin->num=winnum;//numwindows;
		    twin->next=0;
		    //twin->Bits|=WNotVisible; //technically window not visible yet
	//      twin->ow=w->w;   //store original w,h
	//      twin->oh=w->h;
	//      CreateFTWindowFTControls(twin->num);
		    if (twin->AddFTControls!=0) (*twin->AddFTControls) (twin);
		    if (twin->icontrol!=0) twin->focus=1; //for now set FTControl that has tab=1 as FTControl w init focus
	//        fprintf(stderr,"twin->Bits=%x\n",twin->Bits);
  fprintf(stderr,"End CreateFTWindow %s\n",twin->name);
if (twin->num==num)
  //fprintf(stderr,"got here return %d\n",twin->num);
  if (twin->next==0) ex=1;
  else  twin=(FTWindow *)twin->next;
//possibly if WClose bit is set - call DestroyFTWindow first
if (twin->inst==inst && strcmp(twin->name,name)==0)
  //fprintf(stderr,"got here return %d\n",twin->num);
	//there are problems when a user destroys an FTWindow and then FT tries to finish operations on it - so for now they are not unallocated until the main window is closed.
	//I have pretty much decided that windows should be freed on Close - but have not implemented yet
//	if (twin->Bits&WOpen) {
 twin=(FTWindow *)twin->next;
//CreateFTWindow creates the FTWindow data structure, Open creates the XWindow - and draws the window
  fprintf(stderr,"OpenFTWindow %s (%d)\n",twin->name,twin->num);
if (twin->Bits&WOpen) {
	fprintf(stderr,"Error: OpenFTWindow %s already open or did not close properly\n",twin->name);
if (twin->w==0) {
	fprintf(stderr,"Window %s width=0 setting to 100\n",twin->name);
	twin->w=100;
if (twin->h==0) {
	fprintf(stderr,"Window %s height=0 setting to 100\n",twin->name);
	twin->h=100;
  fprintf(stderr,"Creating XWindow %d %d\n",twin->w,twin->h);
//fprintf(stderr,"twin->Bits=%x\n",twin->Bits);
if (twin->Bits&(WItemList|WSplash)) {
//if ((twin->Bits&WItemList) || (twin->Bits&WSplash)) {
	twin->Bits|=WExclusive; //just in case not already set
//InputOutput - can be drawn to
//InputOnly- cannot be drawn to
//  fprintf(stderr,"x=%d y=%d w=%d h=%d\n",twin->x,twin->y,twin->w,twin->h);
//this is an itemlist (menu) window - with no titlebar
  twin->xwindow = XCreateWindow(PStatus.xdisplay,
      RootWindow(PStatus.xdisplay,PStatus.xscreen),twin->x,twin->y,twin->w,twin->h,1,
  twin->xwindow = XCreateSimpleWindow(PStatus.xdisplay,
                RootWindow(PStatus.xdisplay,PStatus.xscreen),twin->x,twin->y,twin->w,twin->h,BORDER_WIDTH,
//possibly each window should have an option to be a subwindow - in which case there will be no taskbar icon
	//fprintf(stderr,"CreateWindow at %d,%d\n",twin->x,twin->y);
  twin->xwindow = XCreateWindow(PStatus.xdisplay,
      RootWindow(PStatus.xdisplay,PStatus.xscreen),twin->x,twin->y,twin->w,twin->h,1,
//  XChangeProperty(PStatus.xdisplay,twin->xwindow,XA_NET_WM_WINDOW_TYPE,XA_ATOM,32,
if (twin->xwindow == 0)
 fprintf (stderr, "Could not open window %d\n",twin->num);
if (!(twin->Bits&(WItemList|WSplash))) {
	XReparentWindow(PStatus.xdisplay,twin->xwindow,RootWindow(PStatus.xdisplay,PStatus.xscreen),twin->x,twin->y); //make all windows have main root window as parent - otherwise wm changes position relative to initial window
 //  fprintf(stderr,"win x=%d y=%d\n",twin->x,twin->y);
 //unbelievable ->title<10 chars????
XSetStandardProperties(PStatus.xdisplay,twin->xwindow,twin->title,twin->ititle,None,NULL,0,NULL);
XSelectInput(PStatus.xdisplay,twin->xwindow,xeventmask);
hints.x=twin->x; //obsolete - but what replaces?
hints.y=twin->y;
XSetWMNormalHints(PStatus.xdisplay,twin->xwindow,&hints);
XMapRaised(PStatus.xdisplay,twin->xwindow);
//XMoveWindow(PStatus.xdisplay,twin->xwindow,twin->x,twin->y);
   wc.x = twin->x;
   wc.y = twin->y;
   XConfigureWindow(PStatus.xdisplay,twin->xwindow,CWX|CWY,&wc);
twin->xgc= XCreateGC(PStatus.xdisplay, twin->xwindow, 0, 0);
//  XSetFont(PStatus.xdisplay,twin->xgc,tcontrol->font->fid);
//	rect.x      = -40;
//	rect.y      = -40;
//	XSetClipRectangles(PStatus.xdisplay,twin->xgc,0,0,&rect,1,Unsorted) ;
XSetWMProtocols(PStatus.xdisplay,twin->xwindow,&XA_WM_DeleteETE_WINDOW,1);
//XSetWMProtocols(PStatus.xdisplay,twin->xwindow,&XA_WM_TAKE_FOCUS,1);
//    XChangeProperty(PStatus.xdisplay,twin->xwindow,XA_WM_PROTOCOLS, XA_ATOM, 32,
XClearWindow(PStatus.xdisplay,twin->xwindow);
//   DrawFTWindow(twin->num);
//if (!(twin->Bits&WItemList)) {
	if (twin->Bits&WExclusive) {  //if this window has exclusive FTControl
	//if (twin->Bits&WItemList) {  //if this window is an itemlist window
//icontrol is the control list - not the control with exlusive control
		//PStatus.ExclusiveFTControl=twin->icontrol;  //even though itemlists are not controls, this was an easy way of connecting an itemlist window with its parent control for closing on LostFocus
//} //if twin->xwindow ==0
twin->Bits|=WOpen; //important to make sure this is set before calling DrawFTWindow - or infinite windows are opened
//XSync doesn't work - it doesn't wait for a window to be done drawing - possibly I have an older version
twin->Bits|=WWaitUntilDoneDrawing;
while(twin->Bits&WWaitUntilDoneDrawing) {
if (!(twin->Bits&(WItemList|WSplash))) {
  while (twin->xwindow!=xwin) { //was while but hanged on itemlist
//was before drawing window and FTControls -
//but I thought - a window can be modified before being Drawn
  if (twin->OnOpen!=0) {
		fprintf(stderr,"twin->name=%s\n",twin->name);
		//fprintf(stderr,"twin->OnOpen=%p\n",twin->OnOpen);
		//fprintf(stderr,"*twin->OnOpen=%p\n",*twin->OnOpen);
    (*twin->OnOpen) (twin);
	  fprintf(stderr,"End OpenFTWindow %s (%d)\n",twin->name,twin->num);
	if (twin->xwindow!=0) {
		XResizeWindow(PStatus.xdisplay,twin->xwindow,twin->w,twin->h);
		hints.x=twin->x; //obsolete - but what replaces?
		hints.y=twin->y;
		XSetWMNormalHints(PStatus.xdisplay,twin->xwindow,&hints);
	//	XMapRaised(PStatus.xdisplay,twin->xwindow);
		//XMoveWindow(PStatus.xdisplay,twin->xwindow,twin->x,twin->y);
			 wc.x = twin->x;
			 wc.y = twin->y;
			 XConfigureWindow(PStatus.xdisplay,twin->xwindow,CWX|CWY,&wc);
		} //twin->xwindow!=0
strcpy(winname,twin->name);
  fprintf(stderr,"DrawFTWindow %s (%d)\n",twin->name,twin->num);
//if (!(twin->Bits&WOpen) || (twin->Bits&WNotVisible)) {
if (!(twin->Bits&WOpen)) {
  fprintf(stderr,"DrawFTWindow %s needs to be opened\n",twin->name);
	OpenFTWindow(twin); //Window has not been opened yet - or was hidden and XWindow needs to be recreated
//fprintf("DrawFTWindow %s has WOpen\n",twin->name);
//  fprintf(stderr,"twin %s twin->Bits&WNotVisible %d \n",twin->name,twin->Bits&WNotVisible);
//perhaps DrawFTWindow should erase twin->Bits&WNotVisible bit
//twin->Bits&=~WNotVisible; //window not visible when added
	  XSetForeground(PStatus.xdisplay,twin->xgc,wingray16);
	  XSetForeground(PStatus.xdisplay,twin->xgc,wingray);
XFillRectangle(PStatus.xdisplay,twin->xwindow,twin->xgc,0,0,twin->w,twin->h);
  if (twin->image !=0) {//there is an image on the window 
//    XPutImage(PStatus.xdisplay,twin->xwindow,twin->xgc,twin->image,0,0,twin->x1,twin->y1,twin->w,twin->h);
    XPutImage(PStatus.xdisplay,twin->xwindow,twin->xgc,twin->image,0,0,0,0,twin->w,twin->h);
	if (twin->Bits&WItemList) {  //this is an ItemList Window
		if (twin->ilist!=0) {
			DrawFTItemList(twin->ilist);		
// DrawFTControls(twin->num,0);
  if (twin->OnDraw!=0) {
		(*twin->OnDraw) (twin);
  if (!(strcmp(twin->name,name) && twin->inst>inst)) inst=twin->inst;
twin=twin->next;
//Possibly call DestroyFTWindow too - no need to keep FTWindow (twin) structure
//CloseFTWindowNum - DestroyFTWindow for a window by number
//CloseFTWindow - closes FTWindow and destroys XWindow - but does not destroy FTWindow or FTControls
			//if this FTWindows were double-linked lists we would not have to go down list
			//possibly implement ->last link back to previous FTWindow - then remember to set PStatus->iwindow=0 if first FTWindow
						PStatus.iwindow=twin->next;
						last->next=twin->next;
				  if (twin->image!=0) {
				    XDestroyImage(twin->image);
				    //twin->image=0; //dont bother - window is destroyed anyway
				  if (twin->bmpinfo!=0) {
				    free(twin->bmpinfo);
				  if (twin->xwindow!=0) {
				    XFreeGC(PStatus.xdisplay,twin->xgc);
				    XUnmapWindow(PStatus.xdisplay,twin->xwindow);
				    XDestroyWindow(PStatus.xdisplay,twin->xwindow);
						twin->xwindow=0;
						twin->Bits&=~WOpen;
						//root window may not be first window opened - for example splash or some other window
					  //PStatus.ExclWin=0;//-1;//0;  //this presumed that no window can be number 0, but first window=0, changed to -1 - not clear what this variable is for anymore
						if (twin->ilist!=0) {
							if (twin->ilist->parent==0) { //this window is the first descendant of a filemenu or combo - so close PItemListOpen bit
				    fprintf(stderr,"Closed FTWindow '%s'.\n",twin->name);
//one method: no FTWindow is actually destroyed until the last window closes - just WClose is changed to WOpen (this protects code running after user closes window like on exit button)
//possibly only set destroy bit - because exit button can get buttonup - 
//and more processing happens on windows and control - like call buttonup function
//					if (!(twin->Bits&(WItemList|WSplash))) {
					if (!(twin->Bits&WItemList)) {
						//CloseFTWindow does not destroy ItemList windows because they belong to controls on other window - itemlist windows are created and destroyed with the window that has their parent control.
//					twin->Bits|=WClose; //Close when done processing buttonup, etc - in ProcessEvents
						DestroyFTWindow(twin); //for now destroy FTWindow too - its too confusing for users to have to CloseWindow and the DestroyWindow too
//possibly after button up and user function calls - check to see if twin==0 or return if it does
//				twin2=twin2->next;
      //twin->xwindow=0;
//DestroyFTWindow - Frees the FTWindow malloc'd structure, and deletes the FTWindow from the linked list descending from PStatus
if (PStatus.Bits&PInfo) fprintf(stderr,"DestroyFTWindow %s\n",twin->name);
	if (twin->Bits&WOpen) {
	} //twin->Bits&WOpen
	//double-linked list would be faster - would not have to go through each window
      fprintf(stderr,"Before DelFTControlAll for %s\n",twin->name);   
				PStatus.iwindow=twin->next;
				last->next=twin->next;
		  if (twin->image!=0) {
		    XDestroyImage(twin->image);
		    //twin->image=0; //dont bother - window is destroyed anyway
		  if (twin->bmpinfo!=0) {
		    free(twin->bmpinfo);
				//root window may not be first window opened - for example splash or some other window
			//fprintf(stderr,"Before free(twin) %s\n",twin->name);
	twin2=twin2->next;
twin=(FTWindow *)twin->next;
//font_name="*-helvetica-*-12-*";
strcpy(font_name,"-adobe-courier-bold*12*");
//strcpy(font_name,"*mono-medium*12*");
tcontrol->font=XLoadQueryFont(PStatus.xdisplay,font_name);
if (!tcontrol->font)
   tcontrol->font=XLoadQueryFont(PStatus.xdisplay,font_name);
   if (!tcontrol->font)
tcontrol=twin->icontrol;
  if (tcontrol->Bits&CItemListOpen) {
  tcontrol=tcontrol->next;
//if key==FTControl->hotkey, or FTControl->FTItem->hotkey, move focus to that FTControl
//if (twin->Bits&WItemListOpen) {
//if (twin->Bits&WExclusive) {
		titem=tlist->item;
			//if item has an ilist - open - or else close all itemlist windows
				if (titem->ilist!=0) { //item has subitemlist
					if (titem->ilist->window!=0) { //subitemlist has window
						twin=titem->ilist->window;
						if (twin->Bits&WOpen) CloseFTItemList(titem->ilist); //close opened subitemlist
							tlist->cur=titem->num;
							OpenFTItemList(titem->ilist); //open closed subitemlist
							DrawSelectedFTItem(tlist,titem->num);	//select item	- sets tlist->cur
						tlist->cur=titem->num;
						OpenFTItemList(titem->ilist); //open closed subitemlist
						DrawSelectedFTItem(tlist,titem->num);  //select item 
					}//titem->ilist->window
				} else { //titem->ilist!=0
					//no subitemlist - close all itemlists
					  CloseFTItemList(tcontrol->ilist);
				} //titem->ilist!=0
				if (titem->click[0]!=0) {
					(*titem->click[0]) (tlist->window,tlist->control,0,0);
					//if (tlist->control==0 || tlist->window==0) return; //user deleted control or window
				} //titem->click(button)
			titem=titem->next;
	//control does not need to have focus to have a hotkey recognized - this is certainly true for filemenu controls
  tcontrol=twin->icontrol;
  //if (!(twin->Bits&WItemListOpen) || (tcontrol->type==CTFileMenu && !(tcontrol->Bits&CSubMenu))) {
//  fprintf(stderr,"%d %d\n",PStatus.Bits&PAlt,tcontrol->hotkey&PAlt || tcontrol->hotkey2&PAlt);
    //pretend a click down-up on the FTControl
//OpenItemList sets twin->focus=tcontrol->tab
			OpenFTItemList(tcontrol->ilist);
  tcontrol=tcontrol->next;
//clear alt, cntl -but not if 2 shift keys or 2 alt keys, 2 cntl keys
//if (key!=-30 && key!=-30 && key!=-23 && key!=126 && key!=-28 && key!=-29) PStatus.Bits&=~(PAlt|PControl);
	if ((tcontrol->hotkey[i]&0xff)==key) { //key portion matches
		if (!(tcontrol->hotkey[i]&PControl) && !(tcontrol->hotkey[i]&PAlt) && !(tcontrol->hotkey[i]&PShift)) return(1);//match=1;  //no control, alt or shift
		if (PStatus.Bits&PAlt && tcontrol->hotkey[i]&PAlt) { //test Alt key 
			if ((tcontrol->hotkey[i]&PControl && tcontrol->hotkey[i]&PControl) || 
					(~(tcontrol->hotkey[i]&PControl) && ~(tcontrol->hotkey[i]&PControl))) {
				if ((tcontrol->hotkey[i]&PShift && tcontrol->hotkey[i]&PShift) || 
					(~(tcontrol->hotkey[i]&PShift) && ~(tcontrol->hotkey[i]&PShift))) {
		if (PStatus.Bits&PControl && tcontrol->hotkey[i]&PControl) { //test Control key 
			if ((tcontrol->hotkey[i]&PAlt && tcontrol->hotkey[i]&PAlt) || 
					(~(tcontrol->hotkey[i]&PAlt) && ~(tcontrol->hotkey[i]&PAlt))) {
				if ((tcontrol->hotkey[i]&PShift && tcontrol->hotkey[i]&PShift) || 
					(~(tcontrol->hotkey[i]&PShift) && ~(tcontrol->hotkey[i]&PShift))) {
		if (PStatus.Bits&PShift && tcontrol->hotkey[i]&PShift) { //test Shift key 
			if ((tcontrol->hotkey[i]&PAlt && tcontrol->hotkey[i]&PAlt) || 
					(~(tcontrol->hotkey[i]&PAlt) && ~(tcontrol->hotkey[i]&PAlt))) {
				if ((tcontrol->hotkey[i]&PControl && tcontrol->hotkey[i]&PControl) || 
					(~(tcontrol->hotkey[i]&PControl) && ~(tcontrol->hotkey[i]&PControl))) {
		if (tcontrol->hotkey[i]&PAlt && tcontrol->hotkey[i]&PControl) return(1);//match=1;
		if (tcontrol->hotkey[i]&PAlt && !(tcontrol->hotkey[i]&PControl)) return(1);//match=1;
		if (!(tcontrol->hotkey[i]&PAlt) && tcontrol->hotkey[i]&PControl) return(1);//match=1;
if ((PStatus.Bits&PAlt) && (tcontrol->altkey==key || tcontrol->altkey2==key)) {
if ((PStatus.Bits&PControl) && (tcontrol->ctlkey==key || tcontrol->ctlkey2==key)) {
if ((tcontrol->hotkey2&0xff)==key) {
//if (!(tcontrol->hotkey2&(PControl|PAlt))) match=1;  //no alt or FTControl
if (!(tcontrol->hotkey2&PControl || tcontrol->hotkey2&PAlt)) return(1);//match=1;  //no alt or FTControl
  if (tcontrol->hotkey2&PAlt && tcontrol->hotkey2&PControl) return(1);//match=1;
  if (tcontrol->hotkey2&PAlt && !(tcontrol->hotkey2&PControl)) return(1);//match=1;
  if (!(tcontrol->hotkey2&PAlt) && tcontrol->hotkey2&PControl) return(1);//match=1;
if (tFTItem->hotkey[0]==key || tFTItem->hotkey[1]==key) {
//the key matches - do the alt,cntl,none match?
if ((tFTItem->hotkey&0xff)==key) {
if (!(tFTItem->hotkey&(PControl|PAlt))) return(1);//match=1;  //no alt or FTControl
  if (tFTItem->hotkey&PAlt && tFTItem->hotkey&PControl) return(1);//match=1;
  if (tFTItem->hotkey&PAlt && !(tFTItem->hotkey&PControl)) return(1);//match=1;
  if (!(tFTItem->hotkey&PAlt) && tFTItem->hotkey&PControl) return(1);//match=1;
if ((tFTItem->hotkey2&0xff)==key) {
if (!(tFTItem->hotkey2&(PControl|PAlt))) return(1);//match=1;  //no alt or FTControl
  if (tFTItem->hotkey2&PAlt && tFTItem->hotkey2&PControl) return(1);//match=1;
  if (tFTItem->hotkey2&PAlt && !(tFTItem->hotkey2&PControl)) return(1);//match=1;
  if (!(tFTItem->hotkey2&PAlt) && tFTItem->hotkey2&PControl) return(1);//match=1;
      twin=GetFTWindowN(tcontrol->win);
      fprintf(stderr,"window=%s FTControl=%s\n",twin->name,tcontrol->name);
      tcontrol->Bits|=CMouseOver;
//      ty=tcontrol->y1+(float)(tcontrol->y2-tcontrol->y1)*((float)tFTItem->i/(float)tcontrol->ilist->num);
      if (tcontrol->ilist->num>0) {
        fprintf(stderr,"tcontrol y1=%d y2=%d\n",tcontrol->y1,tcontrol->y2);
//        ty=(float)(tcontrol->y2-tcontrol->y1)*((float)(tFTItem->i)/(float)tcontrol->ilist->num);
        ty=(float)tcontrol->y2*((float)(tFTItem->i)/(float)tcontrol->ilist->num);
//      ty+=(((tcontrol->type==CTCombo)+1)*(tcontrol->font->max_bounds.ascent+tcontrol->font->max_bounds.ascent)/2);  //to put click in closer to center
        ty+=tcontrol->font->max_bounds.ascent;  
        fprintf(stderr,"tcontrol=%s tFTItem->i=%d ty=%d\n",tcontrol->name,tFTItem->i,ty);
        CheckFTWindowButtonDown(twin,tcontrol->x1+tcontrol->font->max_bounds.width+1,ty,0);  //is only button 0 for now
        tcontrol->Bits&=~CMouseOver;
        CheckFTWindowButtonUp(twin,tcontrol->x1+tcontrol->font->max_bounds.width+1,ty,0);
//twin=GetFTWindowN(tcontrol->win);
twin=tcontrol->window;
strcpy(winname,twin->name);
strcpy(conname,tcontrol->name);
//twin->focus=tcontrol->tab;
//CheckFTWindowMouseMove(tcontrol->win,tcontrol->x1+1,tcontrol->y1+1);
tcontrol->Bits|=CMouseOver;
CheckFTWindowButtonDown(twin,tcontrol->x1+1,tcontrol->y1+1,0);  //button 0 only for now
tcontrol->Bits&=~CMouseOver;
CheckFTWindowButtonUp(twin,tcontrol->x1+1,tcontrol->y1+1,0);  //button 0 for now
if (twin->Bits&WItemListOpen) {
  tcontrol=twin->icontrol;
    if (tcontrol->type==CTFileMenu && !(tcontrol->Bits&CSubMenu) && tcontrol->Bits&CItemListOpen) return  (tcontrol);
    tcontrol=tcontrol->next;
//DrawFTItemListWindow() - Draws strings inside
	if (tlist->window==0) { //no FTWindow attached to this itemlist yet
		sprintf(tstr,"%s_s",tlist->control->name); //"FTControl"_s = name of window with items
		nwin.icontrol=tlist->control; //save for LostFocus to close control itemlist windows
	//if from control - will start just under control
	//if from item - will start left or right of selected item
//		if (tlist->control!=0) { //descended from control
//similar thing exists with AddSubItem - perhaps should only be one AddItem(ItemList,item) 
		if (tlist->parent==0) { //descended from control
			tcontrol=tlist->control;
			twin=tcontrol->window;
			twin->focus=tcontrol->tab;
			tcontrol->Bits|=CItemListOpen;
			nwin.x=tcontrol->x1+twin->x;
			nwin.y=tcontrol->y2+twin->y;		
//			fprintf(stderr,"ItemList descended from control %s at (%d,%d)\n",tcontrol->name,nwin.x,nwin.y);
				nwin.z=twin->z-1;
//			nwin.focus=tcontrol->tab; //set window focus to this control
			if (tcontrol->type==CTFileMenu) {
//				twin->Bits|=WFileMenuOpen;
			//get x from window of parent itemlist - determine to open right or left to keep on screen
			tlist2=tlist->parent;
				twin2=tlist2->window;
					sprintf(tstr,"%s_%d",twin2->name,tlist2->cur); //"FTControl_s"_# = name of window with subitems
					nwin.x=twin2->x+twin2->w-PStatus.PadX;
					nwin.y=twin2->y+1*(tlist2->cur>1); //I don't know why we need to add 1 pixel here - perhaps PadY
					nwin.z=twin2->z-1;  //the lower the number, the higher the window 
//				nwin.y+=(tlist2->cur-1)*(tlist->font->max_bounds.ascent+tlist->font->max_bounds.descent+PStatus.PadY);
				nwin.y+=(tlist2->cur-1)*(tlist->font->max_bounds.ascent+tlist->font->max_bounds.descent+PStatus.PadY);										
		} //titemlist->parent==0 //titemlist->control!=0 
		nwin.w=tlist->width;
		nwin.h=tlist->height;
			//fprintf(stderr,"ItemList width=%d height=%d\n",tlist->width,tlist->height);
		nwin.font=tlist->font; //new window inherits font of itemlist (which inherits font from control)
		//fprintf(stderr,"Got itemlist window %s= %p\n",twin->name,twin);
		tlist->window=twin;
	} else { //tlist->window==0
		PStatus.FocusFTWindow=tlist->window;
		if (!(tlist->window->Bits&WOpen)) {
			if (tlist->parent==0) { //descended from control
				tcontrol=tlist->control;
				twin=tcontrol->window;
				twin->focus=tcontrol->tab; //set window focus to filemenu/combo control
//				twin->Bits|=WFileMenuOpen;
				tcontrol->Bits|=CItemListOpen;
				twin2=tlist->window;
				twin2->x=twin->x+tcontrol->x1;
				twin2->y=twin->y+tcontrol->y2;		
//				twin2->z=0;
				twin2->z=twin->z-1;  
//				twin2->focus=tcontrol->tab; //set window focus to this control 
	//			fprintf(stderr,"ItemList descended from control %s at (%d,%d)\n",tcontrol->name,nwin.x,nwin.y);
			DrawFTWindow(tlist->window);
			//fprintf(stderr,"WOpen still set on tlist->window\n");
		} //tlist->window->Bits&WOpen
	} //tlist->window==0
// DrawFTItemList only draws a single ItemList window - it does not recursively redraws the text in all open subitemlist windows too - this is done by DrawFTItemListAll()
// Because when mouse moves over new item - we only want to redraw the individual subitemlist
//	fprintf(stderr,"getting tlist->window\n");
	twin=tlist->window;
//	fprintf(stderr,"got tlist->window\n");
	//  twin->Bits|=WItemListOpen; //no other FTControls can be clicked with this bit set 
//	fprintf(stderr,"twin->xgc=%p\n",(void *)twin->xgc);
	//XSetForeground(PStatus.xdisplay, twin->xgc,tcontrol->textcolor[1]);
	XSetForeground(PStatus.xdisplay,twin->xgc,white);
	//twin->x and twin->y are relative to desktop? or main window - use 0,0 for XFillRectangle which uses co-ordinates relative to twin window
//	fprintf(stderr,"twin->xwindow=%p\n",(void *)twin->xwindow);
	XFillRectangle(PStatus.xdisplay,twin->xwindow,twin->xgc,0,0,twin->w,twin->h);
	//XSetForeground(PStatus.xdisplay,twin->xgc,tcontrol->textcolor[0]);
	XSetForeground(PStatus.xdisplay,twin->xgc,black);
//	fprintf(stderr,"tlist->font=%p\n",tlist->font);
//	fprintf(stderr,"tlist->font->max_bounds.width=%d\n",tlist->font->max_bounds.width);
	titem=tlist->item;
//	fw=titem->font->max_bounds.width;
	fw=tlist->font->max_bounds.width;
	//fh=titem->font->max_bounds.ascent+titem->font->max_bounds.descent+PStatus.PadY;
	fh=tlist->font->max_bounds.ascent+tlist->font->max_bounds.descent+PStatus.PadY;
	cy=fh-PStatus.PadY;
//		fprintf(stderr,"cur=%d i=%d\n",tlist->cur,i);
		maxchar=twin->w/fw;
		if (tlist->cur==i) {  //this item is selected
//			fprintf(stderr,"2cur=%d i=%d\n",tlist->cur,i);
	//		XSetForeground(PStatus.xdisplay, twin->xgc, tcontrol->textcolor[3]);  
	//		XSetBackground(PStatus.xdisplay, twin->xgc, tcontrol->textcolor[4]);
//twin->x is relative to desktop(?) and does not = 0
			//fprintf(stderr,"cur=%d x=%d y=%d w=%d h=%d\n",i,twin->x,cy-fh,twin->w,fh+PStatus.PadY);
			XSetForeground(PStatus.xdisplay,twin->xgc,blue);  
			XFillRectangle(PStatus.xdisplay,twin->xwindow,twin->xgc,0,cy-fh+PStatus.PadY,twin->w,fh);
			XSetForeground(PStatus.xdisplay,twin->xgc,white);  
		} //tlist->cur
//		fprintf(stderr,"item name = %s\n",titem->name);
		while(ci<strlen(titem->name)) { //for each character
		  if (titem->name[ci]==0x26) { //& underline
				XDrawLine(PStatus.xdisplay,twin->xwindow,twin->xgc,cx,cy+1,cx+fw,cy+1);
				XDrawString(PStatus.xdisplay,twin->xwindow,twin->xgc,cx,cy,&titem->name[ci],1);
		} //while cx<strlen - for each character		
		if (tlist->cur==i) {  //this item is selected
	//		XSetForeground(PStatus.xdisplay, twin->xgc, tcontrol->textcolor[3]);  
	//		XSetBackground(PStatus.xdisplay, twin->xgc, tcontrol->textcolor[4]);
			XSetForeground(PStatus.xdisplay,twin->xgc,black);  
			XSetBackground(PStatus.xdisplay,twin->xgc,white);
		} //tlist->cur
		titem=titem->next;
//Looks better to draw only selected and unselected item - otherwise flicker is seen
	twin=tlist->window;
		fw=tlist->font->max_bounds.width;
		fh=tlist->font->max_bounds.ascent+tlist->font->max_bounds.descent;
		cy=fh*num+PStatus.PadY*(num-1);
		tcontrol=tlist->control;//PStatus.ExclusiveFTControl;
			//fprintf(stderr,"titem->name=%s\n",titem->name);
			if (tcontrol->type==CTFileOpen || tcontrol->type==CTCombo) {
				strcpy(tcontrol->text,titem->name); //tcontrol->text gets both filename and folder name (for CTFileOpen)
			if (!(titem->Bits&FTI_FOLDER)) {
				//fprintf(stderr,"filename titem->name=%s\n",titem->name);
				strcpy(tcontrol->filename,titem->name); //filename gets only files (for CTFileOpen)
			} //!(litem->Bits&FTI_FOLDER
			if (tcontrol->OnChange!=0) {
				(*tcontrol->OnChange) (twin,tcontrol);
			} //tcontrol->OnChange
		XSetForeground(PStatus.xdisplay,twin->xgc,blue);  
		XFillRectangle(PStatus.xdisplay,twin->xwindow,twin->xgc,0,cy-fh,twin->w,fh+PStatus.PadY);
		XSetForeground(PStatus.xdisplay,twin->xgc,white);  
//		fprintf(stderr,"item name = %s\n",titem->name);
		//check for maximum character unecessary - is done in addFTItem
		while(ci<strlen(titem->name)) { //for each character
		  if (titem->name[ci]==0x26) { //& underline
				XDrawLine(PStatus.xdisplay,twin->xwindow,twin->xgc,cx,cy+1,cx+fw,cy+1);
				XDrawString(PStatus.xdisplay,twin->xwindow,twin->xgc,cx,cy,&titem->name[ci],1);
		} //while ci<strlen - for each character		
//			XSetForeground(PStatus.xdisplay,twin->xgc,black);  
//			XSetBackground(PStatus.xdisplay,twin->xgc,white);
//Looks better to draw only selected and unselected item - otherwise flicker is seen
	twin=tlist->window;
		fw=tlist->font->max_bounds.width;
		fh=tlist->font->max_bounds.ascent+tlist->font->max_bounds.descent;
		cy=fh*num+PStatus.PadY*(num-1);
		XSetForeground(PStatus.xdisplay,twin->xgc,white);  
		XFillRectangle(PStatus.xdisplay,twin->xwindow,twin->xgc,0,cy-fh,twin->w,fh+PStatus.PadY);
		XSetForeground(PStatus.xdisplay,twin->xgc,black);  
//			if (tcontrol->OnChange!=0) {
//				(*tcontrol->OnChange) (twin,tcontrol);
//			} //tcontrol->OnChange
//		fprintf(stderr,"item name = %s\n",titem->name);
		//check for maximum character unecessary - is done in addFTItem
		while(ci<strlen(titem->name)) { //for each character
		  if (titem->name[ci]==0x26) { //& underline
				XDrawLine(PStatus.xdisplay,twin->xwindow,twin->xgc,cx,cy+1,cx+fw,cy+1);
				XDrawString(PStatus.xdisplay,twin->xwindow,twin->xgc,cx,cy,&titem->name[ci],1);
		} //while ci<strlen - for each character		
//			XSetForeground(PStatus.xdisplay,twin->xgc,black);  
//			XSetBackground(PStatus.xdisplay,twin->xgc,white);
	if (tlist->window!=0) { //itemlist has a window
		twin=tlist->window;
		if (twin->Bits&WOpen) { //itemlist window is open - so redraw
			titem=tlist->item;
				if (titem->ilist!=0) {//this item has a subitemlist
					//Draw this ItemList - recursively
					DrawFTItemListAll(titem->ilist);
				} //titem->ilist!=0
				titem=titem->next;
		} //twin2->Bits&WOpen
	} //tlist->window!=0
	if (tlist->parent==0) {
		tcontrol=tlist->control; //get parent control
		if (tcontrol->type==CTFileMenu) {
			twin=tcontrol->window;
			twin->Bits&=~WFileMenuOpen; //erase filemenuopen bit in window control belongs to- so that CheckFTWindowMouseMove will know that there is no filemenu open
	} //tlist->parent==0
	titem=tlist->item;
		if (titem->ilist!=0) {  //item has subitemlist
			CloseFTItemList(titem->ilist); //recursively close subitemlist windows
		} //titem->ilist!=0	
		titem=titem->next;
//			fprintf(stderr,"Close itemlist tlist->window=%p\n",tlist->window);
	if (tlist->window!=0) {	//there is an FTWindow attached to this tlist
		twin=tlist->window;		
//			fprintf(stderr,"Close itemlist window0 %s\n",twin->name);
		if (twin->Bits&WOpen) {
			//fprintf(stderr,"Close itemlist window %s\n",twin->name);
			//important - if using model of CloseFTWindow does not call DestroyFTWindow - 
			//tlist->window=0 needs to be removed:
			//tlist->window=0; //need to pass address to make this stored after leaving CloseFTItemList?
			if (tlist->parent==0) { //parent is control (not itemlist)
				tcontrol=tlist->control;
				tcontrol->Bits&=~CItemListOpen;
//				twin2=tcontrol->window;
					twin2->Bits&=~WFileMenuOpen; //erase filemenuopen bit in window control belongs to- so that CheckFTWindowMouseMove will know that there is no filemenu open
				PStatus.SelectedFTItem=GetFTSubItemByNum(tlist->parent,tlist->parent->cur);
				PStatus.SelectedFTItemList=tlist->parent;
			} //tlist->parent==0
		} //twin->Bits&WOpen
	} //tlist->window!=0
tlist->cur=0; //reset any selected item
//CloseFTItemListControl - for convenience and clarity - is the same as CloseFTItemList
	CloseFTItemList(tcontrol->ilist);
//CloseAllItemLists - When a window loses focus, all itemlists (filemenus) are closed
		CloseFTItemList(PStatus.ExclusiveFTControl->ilist);
} //PStatus.Bits&PExclusive - a window has exclusive control
//twin=GetFTWindowN(tcontrol->win);
twin=GetFTWindowN(tcontrol->win);
if (tcontrol->type==CTFileMenu && !(tcontrol->Bits&CSubMenu) && twin->Bits&WItemListOpen) {
  if (strlen(tcontrol->submenu)>0) {
    twin=GetFTWindow(tcontrol->submenu);
      tcontrol2=twin->icontrol;
      if (tcontrol2->ilist!=0) {
        if (tcontrol2->ilist->cur==0) {  //no FTItem selected
//          tFTItem=GetFTItem(tcontrol2->ilist,0,tcontrol2->ilist->cur-1);
          tFTItem=GetFTItemByNum(tcontrol2->ilist,tcontrol2->ilist->cur-1);
          fprintf(stderr,"FTItem selected = %s\n",tFTItem->name);
            if (tFTItem->submenu!=0) {  //FTItem has submenu, submenu should be open if cur is selected
              twin2=GetFTWindow(tFTItem->submenu);
              fprintf(stderr,"submenu of selected FTItem = %s\n",twin2->name); 
             // if (twin2->Bits&WNotVisible) {  //window not open, return last menu
						 if (!(twin2->Bits&WOpen)) {  //window not open, return last menu
//              twin2->ilist;
                tcontrol2=twin2->icontrol;  //go to next FTControl
            }  //tFTItem->submenu!=0
            else {  //tFTItem->submenu==0
        } //else tcontrol->cur==0
      }  //tcontrol2->ilist!=0 
      } //else tcontrol2->ilist
strcpy(winname,twin->name);
strcpy(conname,tcontrol->name);
  if (tcontrol->ilist!=0) {
//    if (tcontrol->ilist->cur>0) {
    if (tcontrol->i[0]>0) {
      if (tcontrol->i[0]-tcontrol->numvisible>0) {
        tcontrol->i[0]-=tcontrol->numvisible;
          tcontrol->ilist->cur-=tcontrol->numvisible;
        tcontrol->i[0]=0;
          tcontrol->ilist->cur=0;
//    fprintf(stderr,"Keypress func up i0=%d i1=%d\n",tcontrol->i[0],tcontrol->i[1]);
//        litem=GetFTItem(tcontrol->ilist,0,tcontrol->ilist->cur);
//        litem=GetFTItemByNum(tcontrol->ilist,tcontrol->ilist->cur);
        litem=GetFTItemByNum(tcontrol,tcontrol->ilist->cur+1);
//      fprintf(stderr,"FTItem=%s\n",litem->name);
					if (tcontrol->type==CTFileOpen || tcontrol->type==CTCombo) {
	  			  strcpy(tcontrol->text,litem->name); //text gets folders and files
		      if (!(litem->Bits&FTI_FOLDER))
		        strcpy(tcontrol->filename,litem->name);
		        strcpy(tcontrol->filename,"");  
      if (tcontrol->OnChange!=0) {
				(*tcontrol->OnChange) (twin,tcontrol);
      }  //i[0]>0 //cur>0  //if tcontrol->i[1]>0
  if (tcontrol->ilist!=0) {
    if (tcontrol->i[0]<tcontrol->ilist->num-1) {
//  fprintf(stderr,"Keypress func up top=%d cur=%d num=%d\n",tcontrol->i[0],tcontrol->i[1],tcontrol->ilist->num);
//    fprintf(stderr,"tcontrol->i[0]=%d nums=%d\n",tcontrol->i[0],tcontrol->ilist->num);
      if ((tcontrol->i[0]+2*tcontrol->numvisible)<tcontrol->ilist->num-1) {
        tcontrol->i[0]+=tcontrol->numvisible;
          tcontrol->ilist->cur+=tcontrol->numvisible;
          tcontrol->ilist->cur=tcontrol->ilist->num-1;
//        tcontrol->i[0]=tcontrol->ilist->cur-tcontrol->numvisible+1;
        tcontrol->i[0]=tcontrol->ilist->num-tcontrol->numvisible;
//        if (tcontrol->i[0]<0) tcontrol->i[0]=0;
//        fprintf(stderr,"cur=%d nums=%d\n",tcontrol->ilist->cur,tcontrol->ilist->num);
//        litem=GetFTItem(tcontrol->ilist,0,tcontrol->ilist->cur);
//        litem=GetFTItemByNum(tcontrol->ilist,tcontrol->ilist->cur);
        litem=GetFTItemByNum(tcontrol,tcontrol->ilist->cur+1);
					if (tcontrol->type==CTFileOpen || tcontrol->type==CTCombo) {
				    strcpy(tcontrol->text,litem->name); //text gets folders and files
		      if (!(litem->Bits&FTI_FOLDER))
		        strcpy(tcontrol->filename,litem->name);
		        strcpy(tcontrol->filename,"");  
      if (tcontrol->OnChange!=0) {
				(*tcontrol->OnChange) (twin,tcontrol);
//GetFTItemXY - return item which mouse x,y is over
//presumes x,y is over itemlist window - does no boundary checking
	fh=tlist->font->max_bounds.ascent+tlist->font->max_bounds.descent+PStatus.PadY;
	//if item has an ilist - open - or else close all itemlist windows
		if (titem->ilist!=0) { //item has subitemlist
			if (titem->ilist->window!=0) {
				twin=titem->ilist->window;
				if (twin->Bits&WOpen) CloseFTItemList(titem->ilist); //close opened subitemlist
				else OpenFTItemList(titem->ilist); //open closed subitemlist
				OpenFTItemList(titem->ilist); //open closed subitemlist
			}//titem->ilist->window
		} else { //titem->ilist==0
			//no subitemlist - close all itemlists
				if (tcontrol->type==CTCombo) {
					//Combo value could be selected itemlist index - but can't be used if subitemlists are allowed
					tcontrol->value=tcontrol->ilist->cur;
					strcpy(tcontrol->text,titem->name); //copy text of item
					//strcpy(tcontrol->text,titem->name);
				CloseFTItemList(tcontrol->ilist);
				if (tcontrol->type==CTCombo) {
		} //titem->ilist!=0
		if (tlist->window!=0 && tlist->control!=0) {
			if (titem->click[button]!=0) {
				(*titem->click[button]) (tlist->window,tlist->control,x,y);
		//		tlist->control=GetFTControl(conname);
		//		tlist->window=GetFTWindow(winname);
		//		if (tlist->control==0 || tlist->window==0) return; //user deleted control or window
			} //titem->click(button)
			if (tlist->control->OnChange!=0) {
				(*tlist->control->OnChange) (tlist->window,tlist->control);
		//		tlist->control=GetFTControl(conname);
		//		tlist->window=GetFTWindow(winname);
		//		if (tlist->control==0 || tlist->window==0) return; //user deleted control or window
			} //titem->control->OnChange
		} //tlist->window!=0 && tlist->control!=0
//SetFocus - set focus to a window and to any control (control=0 - sets window to focus only)
//Possibly SetWindowFocus - it might be nice to have a twin.SetFocus();
	//XUnmapWindow(PStatus.xdisplay,PStatus.FocusFTWindow->xwindow);
//	XLowerWindow(PStatus.xdisplay,PStatus.FocusFTWindow->xwindow);
if (PStatus.Bits&PInfo) fprintf(stderr,"SetFocus to window %s\n",twin->name);
tfocus=twin->focus;
//PStatus.focus=twin->num;
twin->focus=0;
//fprintf(stderr,"xdisplay=%p twin->xwindow=%p\n",PStatus.xdisplay,(u32 *)twin->xwindow);
//tns=PStatus.ctime->tm_sec+1;
//while(tns>PStatus.ctime->tm_sec) {
//fprintf(stderr,"trying to focus into %s\n",twin->name);
//XMapWindow(PStatus.xdisplay,twin->xwindow);
//XRaiseWindow(PStatus.xdisplay,twin->xwindow);
//XRaiseWindow(PStatus.xdisplay,twin->xwindow);
//XMapRaised(PStatus.xdisplay,twin->xwindow);
//XMapLowerRaised(PStatus.xdisplay,twin->xwindow);
//XMapRaised(PStatus.xdisplay,twin->xwindow);
//XMapWindow(PStatus.xdisplay,twin->xwindow);
XRaiseWindow(PStatus.xdisplay,twin->xwindow);
xchange.x=twin->x+20;
xchange.y=twin->y+20;
xchange.width=twin->w+20;
xchange.height=twin->h+20;
xchange.sibling=twin2->xwindow;
if (XReconfigureWMWindow(PStatus.xdisplay,twin->xwindow,0,CWStackMode|CWSibling|CWWidth|CWHeight|CWX|CWY,&xchange)==0) {
//XIconifyWindow(PStatus.xdisplay,twin->xwindow,0);
//XWithdrawWindow - but no XAssertWindow?
    ev.window = twin->xwindow;
//XSetWMProtocols(PStatus.xdisplay,twin->xwindow,&XA_WM_TAKE_FOCUS,0);
//fprintf(stderr,"twin=%s\n",twin->name);
//fprintf(stderr,"xdisplay=%p twin->xwindow=%p\n",PStatus.xdisplay,(u32 *)twin->xwindow);
XSetInputFocus(PStatus.xdisplay,twin->xwindow,RevertToNone,CurrentTime); 
//XGetInputFocus(PStatus.xdisplay,twin->
	while(xwin!=twin->xwindow) {
strcpy(winname,twin->name);
strcpy(conname,tcontrol->name);
  fprintf(stderr,"SetFocus to FTControl %s\n",tcontrol->name);
  twin->focus=tcontrol->tab;  //give this FTControl the window focus
  fprintf(stderr,"set win focus to FTControl %s\n",tcontrol->name);
  if (tcontrol->tab!=tfocus && tfocus!=0) {
			strcpy(conname2,tcontrol2->name);
      if (tcontrol2->type==CTTextBox || tcontrol2->type==CTTextArea) {
      if (tcontrol2->LostFocus!=0) (*tcontrol2->LostFocus) (twin,tcontrol2);
  }  //tcontrol->tab!=tfocus
  if (tcontrol->GotFocus!=0) (*tcontrol->GotFocus) (twin,tcontrol);
//if (twin->GotFocus!=0) (*twin->GotFocus) ();
if (PStatus.Bits&PInfo) fprintf(stderr,"End SetFocus to window %s\n",twin->name);
//strcpy(winname,twin->name);
tcontrol2=twin->icontrol;
  if (tcontrol2->Bits&CButtonDown(0) && x>=tcontrol2->x1 && x<=tcontrol2->x2 && y>=tcontrol2->y1 && y<=tcontrol2->y2) {
  if (tcontrol2->z<curz) {//was <curz || curz==-1) {
    curz=tcontrol->z;
  tcontrol2=tcontrol2->next;
//			strcpy(conname,tcontrol->name);
 // fprintf(stderr,"ButtonDown being held over control %s with delay=%d sec %d usec\n",tcontrol->name,(int)tcontrol->interval[button].tv_sec,(int)tcontrol->interval[button].tv_usec);
//if tcontrol->delay[button]=0 and tcontrol->interval[button]=0 presume the default delay?
      //fprintf(stderr,"found FTControl %s\n",tcontrol->name);
      //fprintf(stderr,"CButtonHoldStart=%x\n",tcontrol->Bits&CButtonHoldStart);
      thtime=tcontrol->lasttime[button].tv_sec*1000000 + tcontrol->lasttime[button].tv_usec + \
            (((tcontrol->Bits&CButtonHoldStart(button))>0) * \
	    (tcontrol->interval[button].tv_sec*1000000+tcontrol->interval[button].tv_usec)) + \
	    (!((tcontrol->Bits&CButtonHoldStart(button))>0) * \
	    (tcontrol->delay[button].tv_sec*1000000+tcontrol->delay[button].tv_usec));
        tcontrol->Bits|=CButtonHoldStart(button);
        tcontrol->lasttime[button].tv_sec=PStatus.utime.tv_sec;
        tcontrol->lasttime[button].tv_usec=PStatus.utime.tv_usec;
				//call scroll button functions - I moved these inline as opposed to internal callback to free for user to use - make these type=CTVScrollUp and then call these functions and a callback
				if (tcontrol->Bits&CVScrollUp) {
				if (tcontrol->Bits&CVScrollDown) {
				if (tcontrol->Bits&CVScrollBack) {
				if (tcontrol->Bits&CHScrollLeft) {
				if (tcontrol->Bits&CHScrollRight) {
				if (tcontrol->Bits&CHScrollBack) {
					//the scroll bar in GTK is implemented to scroll when the button is down after an initial scroll, no matter where mouse x,y is - perhaps separate initial buttondown and later repeating
        if (tcontrol->ButtonDownHold[button]!=0) {  //call any functions connected to ButtonDown
          (*tcontrol->ButtonDownHold[button]) (twin,tcontrol,x,y);
//in which case - we would only CloseAllitemLists(); in LostFocus
strcpy(winname,twin->name);
twin->Bits|=WButtonDown(button);
if (twin->ButtonDown[button]!=0) {  //call any window functions connected to ButtonDown
  (*twin->ButtonDown[button]) (twin,x,y);
//fprintf(stderr,"win %s exclusive=%x\n",twin->name,PStatus.Bits&PExclusive);
// && (twin->Bits&WOpen) - I think we can presume it is open if it is a buttondown on an itemlist window
if (twin->Bits&WItemList) {
//	FTItemButtonDown(twin->ilist,x,y,button);
//ignore buttondown on itemlist windows - only happens when itemlist window was already open - and then all that matters is location on buttonup
} //twin->Bits&WItemList
	tcontrol=twin->icontrol;
		strcpy(conname,tcontrol->name);
//test ->z?
		if ((tcontrol->type==CTFileMenu || tcontrol->type==CTCombo) && !(tcontrol->Bits&CNotVisible) && x>=tcontrol->x1 && x<=tcontrol->x2 && y>=tcontrol->y1 && y<=tcontrol->y2) {
				fprintf(stderr,"Button down on FTControl %s\n",tcontrol->name);
			tcontrol->Bits|=CButtonDown(button);  //set ButtonDown flag
			if (tcontrol->Bits&CItemListOpen) { //this is the open ItemList  - close on buttonup
//else {  //ItemList is closed, open - some other itemlist must be open
				//OpenFTItemList(tcontrol->ilist);
		} //if tcontrol->type==CTFileMenu ||
	tcontrol=tcontrol->next;
//possibly exit after found= can only click on 1 FTControl - need depth for scroll bar drag button
//if (twin!=0 && (!(PStatus.Bits&PExclusive) || twin->num==PStatus.ExclWin || (twin->Bits&WItemListOpen))) {
//if (twin!=0 && (!(PStatus.Bits&PExclusive) || twin->num==PStatus.ExclWin || (twin->Bits&WItemList && !(twin->Bits&WNotVisible)))) {
//if ((!(PStatus.Bits&PExclusive) || twin==PStatus.ExclusiveFTWindow || ((twin->Bits&WItemList) && (twin->Bits&WOpen)))) {
//  fprintf(stderr,"win %s is exclusive window\n",twin->name);
	twin->Bits|=WButtonDown(button);  //set window button down bit
//  fprintf(stderr,"twin menuopen %d\n",twin->Bits&WItemListOpen);
	tcontrol=twin->icontrol;
		if (!(tcontrol->Bits&CNotVisible) && x>=tcontrol->x1 && x<=tcontrol->x2 && y>=tcontrol->y1 && y<=tcontrol->y2 && tcontrol->z<curz) {
			curz=tcontrol->z;
		} //CNotVisible - mouse x,y is over this control
	tcontrol=(FTControl *)tcontrol->next;
			fprintf(stderr,"Button down on FTControl %s\n",tcontrol->name);
    tcontrol->lasttime[button].tv_sec=PStatus.utime.tv_sec;
    tcontrol->lasttime[button].tv_usec=PStatus.utime.tv_usec;
		bw=tcontrol->x2-tcontrol->x1;
		bh=tcontrol->y2-tcontrol->y1;
		if (tcontrol->Bits&(CResize|CResizeX1|CResizeX2|CResizeY1|CResizeY2))
			if (x<tcontrol->x1+PStatus.ResizePix)
			if (x>tcontrol->x2-PStatus.ResizePix)
			if (y<tcontrol->y1+PStatus.ResizePix)
			if (y>tcontrol->y2-PStatus.ResizePix)
			tcontrol->Bits|=CButtonDown(button);  //set ButtonDown flag
			//call scroll button functions - I moved these inline as opposed to internal callback to free for user to use
			if (tcontrol->Bits&CVScrollUp) {
			if (tcontrol->Bits&CVScrollDown) {
			if (tcontrol->Bits&CVScrollBack) {
			if (tcontrol->Bits&CHScrollLeft) {
			if (tcontrol->Bits&CHScrollRight) {
			if (tcontrol->Bits&CHScrollBack) {
			if (tcontrol->Bits&CVScroll) {
				sprintf(tstr,"%s%s",PStatus.PrefixVScrollSlide,&tcontrol->name[strlen(PStatus.PrefixVScrollBack)]);
					sprintf(tstr,"%s",&tcontrol->name[strlen(PStatus.PrefixVScrollBack)]);
						if (tcontrol3->type==CTTextArea) {  //scrollbar connected to textarea
							if (y<tcontrol2->y1) {
							}//y<tcontrol2->y1
						if (tcontrol3->type==CTFrame) { //scrollbar connected to frame
								if (y<tcontrol2->y1) {
								}//y<tcontrol2->y1
						} //tcontrol3->type==CTTextArea
					sprintf(tstr,"%s",&tcontrol->name[strlen(PStatus.PrefixVScrollDown)]);
						if (tcontrol3->type==CTFrame) { //scrollbar connected to frame
			if (!(tcontrol->Bits&CNoColorChangeButton(button)))
		if (tcontrol->type==CTFileMenu || tcontrol->type==CTCombo) {
				OpenFTItemList(tcontrol->ilist);
			if (tcontrol->Bits&CItemListOpen) { //ItemList is open - close on buttonup
				OpenFTItemList(tcontrol->ilist);
		} //tcontrol->type==CTFileMenu
	  if ((tcontrol->type==CTTextBox || tcontrol->type==CTTextArea) && button==0) {  
			//fprintf(stderr,"set focus on textbox or textarea (%s)\n",tcontrol->name);
			if (!(tcontrol->Bits&CNoTab)) {
			fw=tcontrol->font->max_bounds.width;
			fh=tcontrol->font->max_bounds.ascent+tcontrol->font->max_bounds.descent;
			mx=(x-tcontrol->x1)/fw;
			my=(y-tcontrol->y1)/fh; //mouse in characters
			cx=0;//tcontrol->x1+1;
			cy=0;//tcontrol->y1+fh-1;
			maxwidth=(tcontrol->x2-tcontrol->x1)/fw;
			maxheight=(tcontrol->y2-tcontrol->y1)/fh;
			i=tcontrol->i[1];
			tlen=strlen(tcontrol->text);
			curpos=tcontrol->i[0];
					curpos=i-1;
				if (tcontrol->text[i]==10) {
					if (cx>maxwidth-1) {
//			curpos=tcontrol->i[1]+cy*maxwidth+cx;						
	    tcontrol->i[2]=curpos;//x;   //button 0 only for now
	    tcontrol->i[3]=curpos;//tcontrol->i[2];
	    tcontrol->i[0]=curpos;// move cursor to button down position
//      tcontrol->i[4]=0;
//      tcontrol->i[5]=0;
//      tcontrol->i[4]=curpos;//tcontrol->i[1]+(tcontrol->i[2]-tcontrol->x1)/fw;
//      tcontrol->i[5]=curpos;//tcontrol->i[1]+(tcontrol->i[2]-tcontrol->x1)/fw;
	    //if (tcontrol->i[4]>strlen(tcontrol->text)) tcontrol->i[4]=strlen(tcontrol->text);
	    //if (tcontrol->i[5]>strlen(tcontrol->text)) tcontrol->i[5]=strlen(tcontrol->text);
	    fprintf(stderr,"strlen text=%d\n",strlen(tcontrol->text));
	    tcontrol2=twin->icontrol;
//        if ((tcontrol2->type==CTTextBox  || tcontrol2->type==CTTextArea) && !(strcmp(tcontrol2->name,tcontrol->name)==0)) {
	      if (tcontrol!=tcontrol2 && (tcontrol2->type==CTTextBox  || tcontrol2->type==CTTextArea) && tcontrol2->i[2]!=tcontrol2->i[3]) {
	        tcontrol2->i[2]=0;
	        tcontrol2->i[3]=0;
//          tcontrol2->i[4]=0;
//          tcontrol2->i[5]=0;
	        tcontrol2->text2[0]=0;  //empty selected string
	      tcontrol2=tcontrol2->next;
	if (!(tcontrol->Bits&CNoColorChangeMouse) && button==0)  //button 0 only for now
	//	fprintf(stderr,"Draw FTControl %s\n",tcontrol->name);
//  fprintf(stderr,"twin 0=%d\n",twin->Bits&WItemListOpen);
	  if (tcontrol->ButtonDown[button]!=0)
			//these include internal scrollbars-one problem is that the scroll bar slide button is already updated by the time of this call
	    (*tcontrol->ButtonDown[button]) (twin,tcontrol,x,y);
//				fprintf(stderr,"tcontrol->next=%p\n",tcontrol->next);
strcpy(winname,twin->name);
	fprintf(stderr,"CheckFTWindowButtonUp in Window '%s'\n",twin->name);
//if an itemlist is open - buttonup can only relate to filemenus or combo itemlists
	if (!(twin->Bits&WItemList)) { 
//the buttonup window must have an open filemenu or combo control - and the button 0 must be down
		//1) if exclusivecontrol is filemenu - other filemenus can open and close
		//twin2=PStatus.ExclusiveFTWindow; //this is itemlist window-  another way of getting window
		rx1=twin->x+x;
		ry1=twin->y+y;
			if (twin2->Bits&WItemList) {
				if (twin2->Bits&WOpen) {
					if (rx1>twin2->x && rx1<twin2->x+twin2->w &&
							ry1>twin2->y && ry1<twin2->y+twin2->h && twin2->z<twin->z) {
							x=rx1-twin->x; //x,y will be 0 to twin->w
							y=ry1-twin->y;
					} //rx1>twin2->x
			twin2=twin2->next;
				if (tcontrol->type==CTFileMenu || tcontrol->type==CTCombo) {
					tcontrol2=twin->icontrol;
						if (tcontrol2->type==CTFileMenu || tcontrol->type==CTCombo) {
							if (x>tcontrol2->x1 && x<tcontrol2->x2 && 
								y>tcontrol2->y1 && y<tcontrol2->y2) {
								//if down on control - closeitemlist windows
									CloseFTItemList(tcontrol->ilist);
								if (twin->ButtonUp[button]!=0) {
									(*twin->ButtonUp[button]) (twin,x,y);
									twin=GetFTWindow(winname); //check to see if window was deleted - we could pass &twin to user function
								if (tcontrol->ButtonUp[button]!=0) {
									(*tcontrol->ButtonUp[button]) (twin,tcontrol,x,y);
									//tcontrol->Bits&=~CMouseOver;
									CloseFTItemList(tcontrol->ilist);
									OpenFTItemList(tcontrol2->ilist);
									PStatus.SelectedFTItemList=tcontrol2->ilist; //need?
							} //x>tcontrol2->x1
					tcontrol2=tcontrol2->next;
					CloseFTItemList(tcontrol->ilist);
					tcontrol->Bits&=~CMouseOver; //clear mouse over
					if (twin->ButtonUp[button]!=0) {
						(*twin->ButtonUp[button]) (twin,x,y);			 
				} //tcontrol->type==CTFileMenu
//after this process this buttonup with an openitemlist like the rest - 
	} //!(twin->Bits&WItemList)  itemlist is open but window is not an itemlist
//			fprintf(stderr,"window is itemlist - call item\n");
		//CloseFTItemList(PStatus.ExclusiveFTControl->ilist);
//		CloseFTItemList(PStatus.ExclusiveFTControl->ilist);
		FTItemButtonUp(twin->ilist,x,y,button);
		twin->Bits&=~WButtonDown(button);  //clear window button down bit
		if (twin->ButtonUp[button]!=0) {
			(*twin->ButtonUp[button]) (twin,x,y);
//} //twin->Bits&WItemList
//else {//twin->Bits&WItemList
		if (twin->Bits&WButtonDown(button)) {
//				fprintf(stderr,"Exclusive window=%s control=%s\n",twin2->name,tcontrol->name);
				tlist=twin2->ilist;
				if (x>tcontrol->x1 && x<(tcontrol->x1+twin2->w) && 
						y>tcontrol->y2 && y<(tcontrol->y2+twin2->h)) {
//					titem=GetFTItemXY(tlist,x-tcontrol->x1,y-tcontrol->y2); //x,y is relative to window with control
					FTItemButtonUp(tlist,x-tcontrol->x1,y-tcontrol->y2,button);
				} else { //x>tcontrol->x1
					if (!(x>tcontrol->x1 && x<tcontrol->x2 && 
							 y>tcontrol->y1 && y<tcontrol->y2) || (PStatus.Bits&PCloseItemListOnUp)) {
						//and buttonup is not over itemlist - Close Control's ItemList Window
						CloseFTItemList(tcontrol->ilist);					
						tcontrol->Bits&=~CButtonDown(0);
					} //(!(x>tcontrol->x1
				} //x>tcontrol->x1
		} //twin->Bits&WButtonDown(button)
//		twin->Bits&=~WButtonDown(button);  //clear window button down bit
//	}//twin->Bits&WItemList
	tcontrol=twin->icontrol;
		strcpy(conname,tcontrol->name);
		if ((tcontrol->type==CTFileMenu || tcontrol->type==CTCombo) && !(tcontrol->Bits&CNotVisible) &&  x>=tcontrol->x1 && x<=tcontrol->x2 && y>=tcontrol->y1 && y<=tcontrol->y2) {
//				CloseFTItemList(PStatus.ExclusiveFTControl->ilist);
//button==0 && (tcontrol->Bits&CButtonDown(0)) && 
				CloseFTItemList(tcontrol->ilist);
				tcontrol->Bits&=~CButtonDown(0);
		} //tcontrol->type==CTFileMenu || 
	tcontrol=tcontrol->next;
//button up on window that is not itemlist - but not on filemenu control that had button 0 down=
	CloseFTItemList(PStatus.ExclusiveFTControl->ilist);
	twin->Bits&=~WButtonDown(button);  //clear window button down bit
strcpy(winname,twin->name); //save name to check if deleted by user
//window loses focus - clear window buttondown bits
if (twin->Bits&WButtonDown(button)) {
	twin->Bits&=~WButtonDown(button);
	if (twin->ButtonDownUp[button]!=0) {
		(*twin->ButtonDownUp[button]) (twin,x,y);
		twin2->Bits&=~WButtonDown(button);
		twin2=twin2->next;
} //twin->Bits
if (twin->ButtonUp[button]!=0) {
	(*twin->ButtonUp[button]) (twin,x,y);
	twin=GetFTWindow(winname); //check to see if window was deleted - we could pass &twin to user function
	//    fprintf(stderr,"dropped FTControl %s\n",tcontrol->name);
		  MovingControl=1;  //to stop any down-up click event when was drag-drop
	//z is important to determine scrollbar clicks - although perhaps scroll bars should be next to control
	twin->Bits&=~WButtonDown(button);  //clear window button down bit
	//curz=-1;
	tcontrol=twin->icontrol;
		if (!(tcontrol->Bits&CNotVisible) && x>=tcontrol->x1 && x<=tcontrol->x2 && y>=tcontrol->y1 && y<=tcontrol->y2 && tcontrol->z<curz) {
			curz=tcontrol->z;
		} //if !(tcontrol->Bits&CNotVisible
	tcontrol=tcontrol->next;
		tcontrol->Bits&=~(CButtonDown(button));
	tcontrol=twin->icontrol;
		if (tcontrol!=tcontrol2 && tcontrol->Bits&CButtonDown(button)) {
		//    fprintf(stderr,"here %s\n",tcontrol2->name);
		tcontrol=tcontrol->next;
		strcpy(conname,tcontrol->name);
			bw=tcontrol->x2-tcontrol->x1;
			bh=tcontrol->y2-tcontrol->y1;
			fh=tcontrol->font->max_bounds.ascent+tcontrol->font->max_bounds.descent;
			//uncolor mouseover color - possibly do in MouseMove
		  if (tcontrol->Bits&CMouseOver) {
		    tcontrol->Bits&=~CMouseOver;
			//clear CButtonHoldStart - this is set after a buttonhold interval has passed
      tcontrol->Bits&=~CButtonHoldStart(button);
			if (tcontrol->Bits&CButtonDown(button)) {
//				tcontrol->Bits&=~CButtonDown(button); //clear ButtonDown bit
				//ignore buttondown and up on filemenu and combo - because itemlist stays open from buttondown
				fprintf(stderr,"Button %d down and up on FTControl %s\n",button,tcontrol->name);
			tcontrol->Bits&=~(CButtonDown(button));
			//If this is a filemenu control - close all open itemlist windows
			if ((tcontrol->Bits&CItemListOpenOnButtonDown) && (tcontrol->type==CTFileMenu || tcontrol->type==CTCombo)) {
				CloseFTItemList(tcontrol->ilist);
				tcontrol->Bits&=~CButtonDown(button); //clear button down bit
				tcontrol->Bits&~=CItemListOpenOnButtonDown; //clear itemlist was open when button was down
			} //tcontrol2->type==CTFileMenu
				if (tcontrol->Bits&CIsMoving) {
					tcontrol->Bits&=~CIsMoving;
					tcontrol->Bits|=CDoneMoving;
						//give this control focus -  
						//if (tcontrol->type==CTTextBox || tcontrol->type==CTTextArea) {
//						fprintf(stderr,"not resizing - check for toggle\n");
						if (tcontrol->Bits&CToggle && button==0) {
							tcontrol->value=!tcontrol->value;
							//fprintf(stderr,"toggle control to value=%d\n",tcontrol->value);
							if (tcontrol->OnChange!=0) { 
								(*tcontrol->OnChange) (twin,tcontrol);
						if (tcontrol->type==CTCheckBox && button==0) {
							tcontrol->value=!(tcontrol->value);
							if (tcontrol->OnChange!=0) {
								(*tcontrol->OnChange) (twin,tcontrol);
						if (tcontrol->type==CTRadio && button==0) {
							if (tcontrol->value==0) {
								tcontrol->value=1;
								if (tcontrol->name!=0) {
									tcontrol2=twin->icontrol;
										if (tcontrol2->type==CTRadio) {
											if (tcontrol2->group==tcontrol->group) { //isnt it enough to be in the same group?
												if (tcontrol2->name!=0  && strcmp(tcontrol2->name,tcontrol->name)) {
													tcontrol2->value=0;
													} //tcontrol2->name
										tcontrol2=tcontrol2->next;
								if (tcontrol->OnChange!=0) {
									(*tcontrol->OnChange) (twin,tcontrol);
						if (tcontrol->type==CTFileOpen && button==0) {
							if (tcontrol->ilist!=0) {
//								i=(int)((y-tcontrol->y1)/(tcontrol->font->max_bounds.ascent+tcontrol->font->max_bounds.descent));
								i=(int)((y-tcontrol->y1)/fh); //item 1 is first item, cur=0 is no items selected
//								titem=GetFTItem(tcontrol->ilist,tcontrol->i[0]+i);
								titem=GetFTItemByNum(tcontrol,tcontrol->i[0]+i+1);
									if (!(titem->Bits&FTI_FOLDER)) {
										strcpy(tcontrol->filename,titem->name);
										strcpy(tcontrol->text,titem->name);
										strcpy(tcontrol->filename,"");  
									tcontrol->ilist->cur=tcontrol->i[0]+i;  //set index for text to draw selected    
								if (tcontrol->OnChange!=0) {
									(*tcontrol->OnChange) (twin,tcontrol);
						//    fprintf(stderr,"%s\n",tcontrol->filename);
						if (tcontrol->ButtonDownUp[button]!=0) {
							(*tcontrol->ButtonDownUp[button]) (twin,tcontrol,x,y);
				} //tcontrol->Bits&CIsMoving - control was moving
			} else {//tcontrol->Bits&CButton(button) - buttondown was on this control
				//  1) Filemenus and combos with buttondown - close
				fprintf(stderr,"Button %d up on FTControl %s (but not down on this control)\n",button,tcontrol->name);
			if (tcontrol->type!=CTFileMenu) {
						CloseFTItemList(PStatus.ExclusiveFTControl->ilist);
			} else { //tcontrol->type!=CTFileMenu
				//-ignore because mousemove should get it
			} //tcontrol->type!=CTFileMenu
				tcontrol2=twin->icontrol;
					if (tcontrol2->Bits&CButtonDown(button)) {
						if (tcontrol2->type==CTFileMenu || tcontrol2->type==CTCombo) {
							CloseFTItemList(tcontrol2->ilist);
						} //tcontrol2->type==CTFileMenu
					tcontrol2->Bits&=~CButtonDown(button); //clear button down bit
					} //tcontrol2->Bits&CButton
				tcontrol2=tcontrol2->next;
			} //tcontrol->Bits&CButton(button)
			if (tcontrol->ButtonUp[button]!=0)
			(*tcontrol->ButtonUp[button]) (twin,tcontrol,x,y);
	} //tcontrol2!=0 - buttonup is over control
//		} //!tcontrol->Bits&CNotVisible and buttonup is over this control
	//for now I am not worrying about z dimension on controls - two controls should not overlap each other - change scroll bar and fileopen buttons to be outside of controls. They can be connected by name.
		  if (tcontrol2->z<curz) {
		    curz=tcontrol->z;
//itemlist windows can have exclusive control - although perhaps I should exclude itemlist windows from being PStatus.ExclusiveFTWindow
//fprintf(stderr,"This window (%s) does not have exclusive control\n",twin->name);
//	fprintf(stderr,"%s does\n",PStatus.ExclusiveFTWindow->name);
//moved windows functions because - window might be destroyed as result
//fprintf(stderr,"in mouse move %s %d %d\n",twin->name,x,y);
	if (PStatus.Bits&PInfo) fprintf(stderr,"CheckFTWindowMouseMove in %s\n",twin->name);
		strcpy(winname,twin->name);
  //fprintf(stderr,"Mouse moving and itemlist window is open (%s)\n",twin->name);
if (twin->Bits&WItemList || (twin->Bits&WButtonDown(0))) {
	if (!(twin->Bits&WItemList)) {
		//1) if exclusivecontrol is filemenu - other filemenus can open and close
		//twin2=PStatus.ExclusiveFTWindow; //this is itemlist window-  another way of getting window
		rx1=twin->x+x;
		ry1=twin->y+y;
			if (twin2->Bits&WItemList) {
				if (twin2->Bits&WOpen) {
					if (rx1>twin2->x && rx1<twin2->x+twin2->w &&
							ry1>twin2->y && ry1<twin2->y+twin2->h && twin2->z<twin->z) {
							x=rx1-twin->x; //x,y will be 0 to twin->w
							y=ry1-twin->y;
					} //rx1>twin2->x
			twin2=twin2->next;
				if (tcontrol->type==CTFileMenu) {
					tcontrol2=twin->icontrol;
						if (tcontrol2->type==CTFileMenu) {
							if (x>tcontrol2->x1 && x<tcontrol2->x2 && 
								y>tcontrol2->y1 && y<tcontrol2->y2) {
									tcontrol->Bits&=~CMouseOver;
									CloseFTItemList(tcontrol->ilist);
									OpenFTItemList(tcontrol2->ilist);
									PStatus.SelectedFTItemList=tcontrol2->ilist; //need?
							} //x>tcontrol2->x1
					tcontrol2=tcontrol2->next;
				} //tcontrol->type==CTFileMenu
//after this process this mouse move with an openitemlist like the rest - 
} //!(twin->Bits&WItemList)
//see if new item is selected - if yes change current selection and redraw window
		tlist=twin->ilist;
		if (titem->num!=tlist->cur) { //mouse over item is not the currently selected item
			//clear last selected item - including all subitemlists
			//UnSelectFTItem(tlist,tlist->cur); //
			titem2=GetFTSubItemByNum(tlist,tlist->cur);
			if (titem2!=0 && titem2->ilist!=0) {
				CloseFTItemList(titem2->ilist); //Close any subitemlist
			DrawUnselectedFTItem(tlist,tlist->cur);
			tlist->cur=titem->num;
			DrawSelectedFTItem(tlist,tlist->cur); 
			if (titem->ilist!=0) {
				OpenFTItemList(titem->ilist);
//		SelectFTItem(tlist,titem->num);
//do not redraw entire window - only draw unselected and selected items
		} else { // titem->num!=tlist->cur
			if (titem->ilist!=0) {  //item has subitemlist
				tlist2=titem->ilist;
				if (tlist2->window!=0) { //subitemlist has a window
					if (tlist2->window->Bits&WOpen) { //subitemlist window is open
						if (tlist2->cur>0) {
							DrawUnselectedFTItem(tlist2,tlist2->cur);
							tlist2->cur=0;
						} //tlist2->cur>0
				} //tlist2->window
			} //titem=->ilist!=0
		} // titem->num!=tlist->cur
	} //titem!=0 - mouse is not over any item
} //twin->Bits&WItemList
tcontrol2=twin->icontrol;
	if (PStatus.ExclusiveFTControl!=0 && PStatus.ExclusiveFTControl->type==CTFileMenu) {
		if ((!(PStatus.Bits&PItemListOpen) || (tcontrol2->type==CTFileMenu)) &&  
				!(tcontrol2->Bits&CNotVisible) &&    
		     x>=tcontrol2->x1 && x<=tcontrol2->x2 &&  y>=tcontrol2->y1 && y<=tcontrol2->y2) {
		     //fprintf(stderr,"over FTControl %s\n",tcontrol2->name);
		    if (tcontrol2->z<cz) { //depth of FTControl - only want top
		      cz=tcontrol2->z;
					//fprintf(stderr,"Mouse over %s\n",tcontrol2->name);
tcontrol2=tcontrol2->next;
		PStatus.MouseOver->Bits&=~CMouseOver;
		//fprintf(stderr,"Redraw %s\n",PStatus.MouseOver->name);
strcpy(conname,tcontrol->name);
//fprintf(stderr,"Erase mouseover - new control = %p ",tcontrol);
//if (tcontrol!=0) { fprintf(stderr,"%s\n",tcontrol->name);}
//a window may have exclusive control - but not just filemenus - 
//Maybe needs PItemListOpen - for open FileMenus and Combos
			if (tcontrol->type==CTFileMenu) { //and is filemenu
					PStatus.MouseOver->Bits&=~CMouseOver;
					//fprintf(stderr,"Redraw %s\n",PStatus.MouseOver->name);
					if ((PStatus.MouseOver->Bits&CItemListOpen) && (PStatus.MouseOver->type==CTFileMenu || PStatus.MouseOver->type==CTCombo)) {
						CloseFTItemList(PStatus.MouseOver->ilist);
							if (tcontrol->type==CTFileMenu) {
								OpenFTItemList(tcontrol->ilist);
					} //PStatus.MouseOver->Bits&CItemListOpen
			} //tcontrol->type==CTFileMenu
//For mouse moves over a filemenu/combo control with open itemlist - must reset selected item (1)
		if (tcontrol->Bits&CItemListOpen) { //this control has an itemlist open
			if (tcontrol->ilist->cur!=0) {	
				titem=GetFTItemByNum(tcontrol,tcontrol->ilist->cur);
					if (titem->ilist!=0) {  //check to see if open?
						//fprintf(stderr,"close subitemlist window=%p\n",titem->ilist->window);
						//fprintf(stderr,"item=%s\n",titem->name);
						CloseFTItemList(titem->ilist);
					} //titem->ilist!=0
				DrawUnselectedFTItem(tcontrol->ilist,tcontrol->ilist->cur);
				tcontrol->ilist->cur=0; //unselect any selected items
				//PStatus.SelectedFTItemList=tcontrol->ilist;
				//DrawFTItemList(tcontrol->ilist); //redraw itemlist to unselect item
			} //tcontrol->ilist->cur!=0
		} //tcontrol->Bits&CItemListOpen
//for a combo control mousemovement doesn't matter - since only one combo can be open at a time, and selecting combo items in combo itemlists is done above - itemlists are FTWindows
//    if (tcontrol->type==CTFileMenu && twin->Bits&WFileMenuOpen) {
    if (tcontrol->type==CTFileMenu && PStatus.ExclusiveFTControl!=0 && tcontrol!=PStatus.ExclusiveFTControl) {
     	if (!(tcontrol->Bits&CItemListOpen)) {  //the filemenu itemlist is not open
					CloseFTItemList(tcontrol2->ilist);
				OpenFTItemList(tcontrol->ilist);
		fprintf(stderr,"window=%s\n",twin->name);
//	if (twin->Bits&WItemListOpen) fprintf(stderr,"because twin->Bits&WItemListOpen\n");
//	if (twin->num==PStatus.ExclWin) fprintf(stderr,"because twin->num=PStatus.ExclWin\n");
//  fprintf(stderr,"x,y =%d,%d win=%d,%d %s\n",x,y,twin->w,twin->h,twin->name);
				if (tcontrol->Bits&(CVScrollSlide|CHScrollSlide)) {
				if (tcontrol->Bits&CVScrollSlide) {
				if (tcontrol->Bits&CHScrollSlide) {
					//call user MouseMove function and return - technically this should be tcontrol->ButtonDownMouseMove()
		    if (tcontrol->MouseMove>0) {  //call any FTControl functions connected to MouseMove
		      (*tcontrol->MouseMove) (twin,tcontrol,x,y);
			} //tcontrol->Bits CHScroll_Slide|CVScroll_Slide
  tcontrol2=twin->icontrol;
//determine topmost control - this is needed because controls can be on top of each other and have a z dimension
  //  if (ignore==0 && !(tcontrol2->Bits&CNotVisible) &&
//actually - i don't think there would be a mouse over a window without control over input
 // if ((!(PStatus.Bits&PItemListOpen) || (tcontrol2->type==CTFileMenu)) &&  
					!(tcontrol2->Bits&CNotVisible) &&    
				   x>=tcontrol2->x1 && x<=tcontrol2->x2 &&  y>=tcontrol2->y1 && y<=tcontrol2->y2) {
				   //fprintf(stderr,"over FTControl %s\n",tcontrol2->name);
				  if (tcontrol2->z<cz) { //depth of FTControl - only want top
				    cz=tcontrol2->z;
						//fprintf(stderr,"Mouse over %s\n",tcontrol2->name);
		if ((tcontrol2->Bits&CIsMoving)||(tcontrol2->Bits&(CResize|CResizeX1|CResizeX2|CResizeY1|CResizeY2)) ) {
				if (tcontrol2->Bits&CButtonDown(0) &&  
				    tcontrol2->type!=CTFileMenu &&
				    tcontrol2->type!=CTTextBox &&
				    tcontrol2->type!=CTTextArea) {  //do not ignore mousemove in textbox
    //if (tcontrol2->Bits&CItemListOpen || (tcontrol2->Bits&CSubMenu && !(tcontrol2->Bits&CNotVisible))) {
    tcontrol2=(FTControl *)tcontrol2->next;
//fprintf(stderr,"Mouse win=%s\n",twin->name);
//fprintf(stderr,"Mouse is over %s\n",tcontrol->name);
//found control mouse is over - so ignore searching to see if resizing a control
//fprintf(stderr,"FTControl=%s\n",tcontrol->name);
tcontrol2=twin->icontrol;
if ((tcontrol2->type==CTTextBox  || tcontrol2->type==CTTextArea) && (tcontrol2->Bits&CButtonDown(0))) {
//  fprintf(stderr,"tcontrol has button down %s\n",tcontrol->name);
     if ((tcontrol2->Bits&CCursor) && !(tcontrol2->Bits&CButtonDown(0))) { 
        //fprintf(stderr,"restore cursor2 %s\n",tcontrol->name);
        tcontrol2->Bits&=~CCursor; 
        XUndefineCursor(PStatus.xdisplay,twin->xwindow);
//perhaps could keep track in PStatus - control with mouseover - and just reset that one
  if (tcontrol2->Bits&CMouseOver && !(tcontrol2->Bits&CNotVisible)) {
              //fprintf(stderr,"Mouse not over %s anymore\n",tcontrol->name);
              //fprintf(stderr,"mouse over remove from %s\n",tcontrol->name);
      //fprintf(stderr,"undid mouse over on %s\n",tcontrol->name);
    tcontrol2->Bits&=~CMouseOver;
    if (!(tcontrol2->Bits&CNoColorChangeMouse) && tcontrol2->type!=CTFileOpen)
           //fprintf(stderr,"redrew %s\n",tcontrol->name);
  tcontrol2=(FTControl *)tcontrol2->next;
//  fprintf(stderr,"after loop tcontrol %s\n",tcontrol->name);
//need to look at selecting text - only redraw textarea when new character is selected
//perhaps need - mousechanges bit which is default for CTButton, CTCombo, etc
			PStatus.MouseOver->type!=CTTextArea && PStatus.MouseOver->type!=CTTextBox) {  
//		if (PStatus.MouseOver!=0 && (tcontrol!=PStatus.MouseOver || tcontrol->Bits&CButton(0))) {  //the mouse was over a control, and is not over the same control now or the button is down (selecting text)
			//	fprintf(stderr,"resetting Mouse over %s\n",PStatus.MouseOver->name);
				PStatus.MouseOver->Bits&=~CMouseOver;
//				fprintf(stderr,"draw control mouseover type=%d\n",PStatus.MouseOver->type);
				//if (tcontrol->type!=
				if (!(tcontrol2->Bits&CNoColorChangeMouse)) { //only redraw control if color change on mouse over is enabled
				//if control is open filemenu or combo - close
    //  - change color for filemenu
    //  - print text/tag after delay
    //  fprintf(stderr,"twin 2=%d\n",twin->Bits&WItemListOpen);
//      fprintf(stderr,"mouse move over %s\n",tcontrol->name);
//if (PStatus.Bits&PInfo) fprintf(stderr,"Mouse is over FTControl '%s'\n",tcontrol->name);
    tcontrol->Bits|=CMouseOver;
    if (!(tcontrol->Bits&CNoColorChangeMouse) && tcontrol->type!=CTTextBox && tcontrol->type!=CTTextArea && tcontrol->type!=CTFileOpen) {
//if the filemenu control itemlist is not open - close the open itemlist window of the other filemenu control
           //fprintf(stderr,"Set window tab to %s x=%d,y=%d\n",tcontrol->name,x,y);
          //twin->focus=tcontrol->tab;  //make this FTControl have window focus 
           //check for resize - mouse is within FTControl already
           if (!(tcontrol->Bits&CIsMoving)&&tcontrol->Bits&(CResize|CResizeX1|CResizeX2|CResizeY1|CResizeY2) ) {
             if (x<tcontrol->x1+PStatus.ResizePix) rx1=1;
             if (x>tcontrol->x2-PStatus.ResizePix) rx2=1;
             if (y<tcontrol->y1+PStatus.ResizePix) ry1=1;
             if (y>tcontrol->y2-PStatus.ResizePix) ry2=1;
            if (!match && (tcontrol->Bits&CResize || 
             (tcontrol->Bits&CResizeX1 && tcontrol->Bits&CResizeY1)) && 
//              fprintf(stderr,"add top left cursor %s\n",tcontrol->name);
              if (!(tcontrol->Bits&CCursor)) { //have not changed the cursor yet
                XDefineCursor(PStatus.xdisplay,twin->xwindow,tcursor);
                tcontrol->Bits|=CCursor;  //cursor to erase later
            if (!match && (tcontrol->Bits&CResize || 
             (tcontrol->Bits&CResizeX1 && tcontrol->Bits&CResizeY2)) && 
              if (!(tcontrol->Bits&CCursor)) { //have not changed the cursor yet
                XDefineCursor(PStatus.xdisplay,twin->xwindow,tcursor);
                tcontrol->Bits|=CCursor;  //cursor to erase later
            if (!match && (tcontrol->Bits&CResize || 
             (tcontrol->Bits&CResizeX2 && tcontrol->Bits&CResizeY1)) && 
              if (!(tcontrol->Bits&CCursor)) { //have not changed the cursor yet
                XDefineCursor(PStatus.xdisplay,twin->xwindow,tcursor);
                tcontrol->Bits|=CCursor;  //cursor to erase later
            if (!match && (tcontrol->Bits&CResize || 
             (tcontrol->Bits&CResizeX2 && tcontrol->Bits&CResizeY2)) && 
              if (!(tcontrol->Bits&CCursor)) { //have not changed the cursor yet
                XDefineCursor(PStatus.xdisplay,twin->xwindow,tcursor);
                tcontrol->Bits|=CCursor;  //cursor to erase later
             if (!match && tcontrol->Bits&(CResize|CResizeX1) && rx1) {  
             //fprintf(stderr,"add cursor %llx %s\n",tcontrol->Bits,tcontrol->name);
                if (!(tcontrol->Bits&CCursor)) { //have not changed the cursor yet
                  //tcontrol->i[4]++;
                  //fprintf(stderr,"cursor=%d",tcontrol->i[4]);
                  //tcursor=XCreateFontCursor(PStatus.xdisplay,tcontrol->i[4]);
                  XDefineCursor(PStatus.xdisplay,twin->xwindow,tcursor);
                  tcontrol->Bits|=CCursor;  //cursor to erase later
            if (!match && tcontrol->Bits&(CResize|CResizeX2) && rx2) {  
              //fprintf(stderr,"add cursor %s\n",tcontrol->name);
              if (!(tcontrol->Bits&CCursor)) { //have not changed the cursor yet
                XDefineCursor(PStatus.xdisplay,twin->xwindow,tcursor);
                tcontrol->Bits|=CCursor;  //cursor to erase later
            if (!match && tcontrol->Bits&(CResize|CResizeY1) && ry1) {  
//              fprintf(stderr,"add up cursor %s\n",tcontrol->name);
              if (!(tcontrol->Bits&CCursor)) { //have not changed the cursor yet
                XDefineCursor(PStatus.xdisplay,twin->xwindow,tcursor);
                tcontrol->Bits|=CCursor;  //cursor to erase later
            if (!match && tcontrol->Bits&(CResize|CResizeY2) && ry2) {  
//              fprintf(stderr,"add down cursor %s\n",tcontrol->name);
              if (!(tcontrol->Bits&CCursor)) { //have not changed the cursor yet
                XDefineCursor(PStatus.xdisplay,twin->xwindow,tcursor);
                tcontrol->Bits|=CCursor;  //cursor to erase later
            if (!match && (tcontrol->Bits&CCursor) && !(tcontrol->Bits&CButtonDown(0))) {
              //fprintf(stderr,"restore cursor %llx %s\n",tcontrol->Bits,tcontrol->name);
              tcontrol->Bits&=~CCursor; 
              //fprintf(stderr,"restore cursor %llx %s\n",tcontrol->Bits,tcontrol->name);
              XUndefineCursor(PStatus.xdisplay,twin->xwindow);
          }  //!(tcontrol->Bits&CIsMoving)&&tcontrol->Bits&(CResize|CResizeX1|CResizeX2|CResizeY1|CResizeY2) )  - control is moving or resizing
          if (tcontrol->Bits&CButtonDown(0)) {
                fprintf(stderr,"Drag FTControl %s %d\n",tcontrol->name,PStatus.MouseX);
            //if(PStatus.LastMouseX>=tcontrol->x1 && PStatus.LastMouseX<=tcontrol->x2 && PStatus.LastMouseY>=tcontrol->y1 && PStatus.LastMouseY<=tcontrol->y2)
              //perhaps should use +-6 if moving
             // if (tcontrol->Bits&(CMove|CResize|CResizeX1|CResizeX2))
            if (tcontrol->Bits&(CMove|CCursor)) {
//            if (tcontrol->Bits&CMove) {
                //if (x>=tcontrol->x1 && x<=tcontrol->x2 && y>=tcontrol->y1 && y<=tcontrol->y2)
                if (PStatus.ButtonX[0]>=tcontrol->x1 && PStatus.ButtonX[0]<=tcontrol->x2 && PStatus.ButtonY[0]>=tcontrol->y1 && PStatus.ButtonY[0]<=tcontrol->y2) {  //if mouse is over this FTControl
                  tcontrol->Bits|=CIsMoving;
                  tcontrol->Bits&=~CDoneMoving;
                if (tcontrol->Bits&(CResize|CResizeX1) && PStatus.Bits&EResizeX1) {
//                  if (tcontrol->x1+(x-PStatus.LastMouseX)>twin->x1) {
                  if (tcontrol->x1+(x-PStatus.LastMouseX)>0) {
                    tcontrol->x1+=(x-PStatus.LastMouseX);
                    if (tcontrol->x1>=tcontrol->x2) tcontrol->x1=tcontrol->x2-2;
                    if (tcontrol->type==CTRadio) {
                      tcontrol->x3+=(x-PStatus.LastMouseX);
                      if (tcontrol->x3<=tcontrol->x1) tcontrol->x3=tcontrol->x2-1;
                if (tcontrol->Bits&(CResize|CResizeX2) && PStatus.Bits&EResizeX2) {
                  //fprintf(stderr,"%d %d\n",tcontrol->x2,x-PStatus.LastMouseX);
                  //if (tcontrol->x2+(x-PStatus.LastMouseX)<twin->x1+twin->w) {
                  if (tcontrol->x2+(x-PStatus.LastMouseX)<twin->w) {
                    tcontrol->x2+=(x-PStatus.LastMouseX);
                    if (tcontrol->x2<=tcontrol->x1) tcontrol->x2=tcontrol->x1+2;
                    if (tcontrol->type==CTCombo) {
                      tcontrol->x3+=(x-PStatus.LastMouseX);
                      if (tcontrol->x3<=tcontrol->x1) tcontrol->x3=tcontrol->x1+1;
                    //fprintf(stderr,"tcontrol->x2=%d\n",tcontrol->x2);
                if (tcontrol->Bits&CResize && PStatus.Bits&EResizeY1) {
//                  if (tcontrol->y1+(y-PStatus.LastMouseY)<twin->y1+twin->h+5) {
                  if (tcontrol->y1+(y-PStatus.LastMouseY)<twin->h+5) {
                    tcontrol->y1+=(y-PStatus.LastMouseY);
                    if (tcontrol->y1>=tcontrol->y2) tcontrol->y1=tcontrol->y2-1;
                if (tcontrol->Bits&CResize && PStatus.Bits&EResizeY2) {
//                  if (tcontrol->y2+(y-PStatus.LastMouseY)<twin->y1+twin->h+5) {
                  if (tcontrol->y2+(y-PStatus.LastMouseY)<twin->h+5) {
                    tcontrol->y2+=(y-PStatus.LastMouseY);
                    if (tcontrol->y2<=tcontrol->y1) tcontrol->y2=tcontrol->y1+1;
                //if (0) { //tcontrol->Bits&CIsMoving) {
                if (match==0 && tcontrol->Bits&CIsMoving) {
 //                 fprintf(stderr,"1 y1=%i y2=%i\n",tcontrol->y1,tcontrol->y2);
                  tcontrol->x1+=(x-PStatus.LastMouseX);
                  tcontrol->y1+=(y-PStatus.LastMouseY);
                  tcontrol->x2+=(x-PStatus.LastMouseX);
                  tcontrol->y2+=(y-PStatus.LastMouseY);
                  tcontrol->x3+=(x-PStatus.LastMouseX);
                  tcontrol->y3+=(y-PStatus.LastMouseY);
 //                 fprintf(stderr,"2 y1=%i y2=%i\n",tcontrol->y1,tcontrol->y2);
//                  if (tcontrol->x1<twin->x1) {
                  if (tcontrol->x1<0) {
                    ti=tcontrol->x2-tcontrol->x1;
                    tj=tcontrol->x3-tcontrol->x1;
                    tcontrol->x1=0;//twin->x1;
                    tcontrol->x2=ti;//twin->x1+ti;
                    tcontrol->x3=tj;//twin->x1+tj;
//                  if (tcontrol->x2>twin->x1+twin->w) {
                  if (tcontrol->x2>twin->w) {
                    ti=tcontrol->x2-tcontrol->x1;
                    tj=tcontrol->x3-tcontrol->x1;
                    //tcontrol->x1=twin->x1+twin->w-ti;
                    tcontrol->x1=twin->w-ti;
//                    tcontrol->x2=twin->x1+twin->w;
                    tcontrol->x2=twin->w;
//                    tcontrol->x3=twin->x1+twin->w-tj;
                    tcontrol->x3=tcontrol->x1+tj;
//                  if (tcontrol->y1<twin->y1) {
                  if (tcontrol->y1<0) {
                    ti=tcontrol->y2-tcontrol->y1;
//                    tcontrol->y1=twin->y1;
                    tcontrol->y1=0;
//                    tcontrol->y2=twin->y1+ti;
                    tcontrol->y2=ti;
                    //tcontrol->y3=twin->y1+ti;
                    tcontrol->y3=ti;
//                  if (tcontrol->y2>twin->y1+twin->h) {
                  if (tcontrol->y2>twin->h) {
                    ti=tcontrol->y2-tcontrol->y1;
//                    tcontrol->y1=twin->y1+twin->h-ti;
                    tcontrol->y1=twin->h-ti;
//                    tcontrol->y2=twin->y1+twin->h;
                    tcontrol->y2=twin->h;
//                    tcontrol->y3=twin->y1+twin->h;
                    tcontrol->y3=twin->h;
//                  fprintf(stderr,"3 y1=%i y2=%i\n",tcontrol->y1,tcontrol->y2);
               if (tcontrol->OnMove!=0) {
									(*tcontrol->OnMove) (twin,tcontrol,x,y);
                  if (tcontrol->OnResize!=0) {
										(*tcontrol->OnResize) (twin,tcontrol,x,y);
//fprintf(stderr,"tnum=%lli StartTimeVisible=%lli\n",tnum,tcontrol->StartTimeVisible);
//fprintf(stderr,"tcontrol= %s diff=%d x=%d ts=%d\t",tcontrol->name,PStatus.MouseX,x,PStatus.timespace);
              } //if (tcontrol->Bits&(CMove|CCursor)) 
//still in  tcontrol->Bits&CButtonDown(0)
            if (tcontrol->type==CTTextBox  || tcontrol->type==CTTextArea) {  //button down is possibly selecting text
//              fprintf(stderr,"button down=%lli\n",(tcontrol->Bits&CButtonDown(0)));
              fw=tcontrol->font->max_bounds.width;
							fh=tcontrol->font->max_bounds.ascent+tcontrol->font->max_bounds.descent;
              maxwidth=(int)((tcontrol->x2-tcontrol->x1)/fw-1);//*fw;
							mx=(x-tcontrol->x1)/fw; //mouse position in characters
							my=(y-tcontrol->y1)/fh;
							cx=0;//tcontrol->i[0];
							curpos=tcontrol->i[2];//
//              tcontrol->i[3]=curpos;
							//actually - since mouse is left of x1 - perhaps button down was on this FTControl?
							if (tcontrol->type==CTTextBox) {
		            //if (tcontrol->i[3]<tcontrol->x1) { //scroll left if possible
								if (x<tcontrol->x1) { //scroll left if possible textbox only
		              if (tcontrol->i[1]>0) {
		                tcontrol->i[1]--;
		                //tcontrol->i[2]+=fw;  //have to move original down click
										tcontrol->i[2]++;//=fw;  //have to move original down click
		              //tcontrol->i[3]=tcontrol->x1; //why is this needed?			
		            if ((x-tcontrol->x1)>maxwidth*fw && (strlen(tcontrol->text)-tcontrol->i[1])>maxwidth) { //scroll right if possible
		              //fprintf(stderr,"%d > 0\n",strlen(tcontrol->text)-tcontrol->i[1]-maxwidth);          
		              //if (strlen(tcontrol->text)-tcontrol->i[1]>0) 
		              tcontrol->i[1]++;
		              //tcontrol->i[2]-=fw;  //have to move original down click
									tcontrol->i[2]--;//=fw;  //have to move original down click
		              //tcontrol->i[3]=tcontrol->x2; //why is this needed?
							if (tcontrol->type==CTTextArea) {
								if (y<tcontrol->y1) { 
		              if (tcontrol->i[1]>0) {
										curpos=tcontrol->i[1];
										while(curpos>0 && tcontrol->text[curpos]!=10) {
			                curpos--;
										tcontrol->i[1]=curpos;
										tcontrol->i[2]=curpos; //have to move original down click
		            } //y<tcontrol->y1
		            if (y>tcontrol->y2) { //scroll down if possible
										curpos=tcontrol->i[1];
//		              if (tcontrol->i[1]>0) {
										while(curpos>0 && tcontrol->text[curpos]!=10) {
			                curpos--;
										tcontrol->i[1]=curpos;
										tcontrol->i[2]=curpos; //have to move original down click
								} //y>tcontrol->y2
							maxwidth=(tcontrol->x2-tcontrol->x1)/fw;
							maxheight=(tcontrol->y2-tcontrol->y1)/fh;
							mx=(x-tcontrol->x1)/fw;
							my=(y-tcontrol->y1)/fh;
							i=tcontrol->i[1];
							tlen=strlen(tcontrol->text);
							curpos=tcontrol->i[0];
								if (tcontrol->text[i]==10) {
									if (cx>maxwidth-1) {
//fprintf(stderr,"curpos=%d [2]=%d [3]=%d\n",curpos,tcontrol->i[2],tcontrol->i[3]);
              if (curpos<=tcontrol->i[2]) {
								//tcontrol->i[3]=tcontrol->i[2];
								tcontrol->i[2]=curpos;
								//tcontrol->i[4]=tcontrol->i[1]+tcontrol->i[3];
								//tcontrol->i[5]=tcontrol->i[1]+tcontrol->i[2];
                //tcontrol->i[5]=tcontrol->i[1]+(tcontrol->i[3]-tcontrol->x1)/fw;
                //tcontrol->i[4]=tcontrol->i[1]+(tcontrol->i[2]-tcontrol->x1)/fw;
								tcontrol->i[3]=curpos;
							//fprintf(stderr,"[2]=%d [3]=%d\n",tcontrol->i[2],tcontrol->i[3]);
              //fprintf(stderr,"i[4]=%d %d\n",tcontrol->i[4],tcontrol->i[5]);
              //tcontrol->i[0]=tcontrol->i[1]+((tcontrol->i[3]-tcontrol->x1)/fw);
							tcontrol->i[0]=curpos;//tcontrol->i[1]+curpos;
              //if (tcontrol->i[0]<0) tcontrol->i[0]=0;
              //if (tcontrol->i[1]<0) tcontrol->i[1]=0;
              //if (tcontrol->i[2]<0) tcontrol->i[2]=0;
//              if (tcontrol->i[4]<=tcontrol->x1) tcontrol->i[4]=tcontrol->x1+PStatus.PadX;
  //            if (tcontrol->i[5]<=tcontrol->x1) tcontrol->i[5]=tcontrol->x1+PStatus.PadX;
              //if (tcontrol->i[0]>strlen(tcontrol->text)) tcontrol->i[0]=strlen(tcontrol->text);
              //if (tcontrol->i[4]>strlen(tcontrol->text)) tcontrol->i[4]=strlen(tcontrol->text);
              //if (tcontrol->i[5]>strlen(tcontrol->text)) tcontrol->i[5]=strlen(tcontrol->text);
//need to draw textbox or textarea? - this is any textbox or textarea
          }  //          if (tcontrol->Bits&CButtonDown(0)) {
            if (tcontrol->MouseMove>0) {  //call any FTControl functions connected to MouseMove
              (*tcontrol->MouseMove) (twin,tcontrol,x,y);
//tph - comment
//        }  //(!(twin->Bits&WItemListOpen) || tcontrol->type==CTFileMenu || tcontrol->type==CTCombo)  
   //end if twin->Bits&WItemListOpen highlighting only for menu and combo
//      } //tcontrol->win==twin  end if this FTControl is in this window
      //fprintf(stderr,"%s\n",tcontrol->name);
    //fprintf(stderr,"win=%s\n",twin->name);
  if (twin->MouseMove>0) {  //call any MouseMove window functions 
    (*twin->MouseMove) (twin,x,y);
//possibly exit after found= can only click on 1 FTControl - need depth for scroll bar drag button
strcpy(winname,twin->name);
tcontrol=twin->icontrol;
strcpy(conname,tcontrol->name);
bw=tcontrol->x2-tcontrol->x1;
bh=tcontrol->y2-tcontrol->y1;
//double-clicked down on this FTControl (this is second click down)
    PStatus.ButtonX[button]>=tcontrol->x1 && PStatus.ButtonX[button]<=tcontrol->x2 && 
    PStatus.ButtonY[button]>=tcontrol->y1 && PStatus.ButtonY[button]<=tcontrol->y2)
//downup FTControls must be up clicked over FTControl - human may not mean to click
fprintf(stderr,"FTControl %s double-click\n",tcontrol->name);
//tcontrol->Bits&=(~CButtonDown);  //button is not being held on this FTControl any more
twin->Bits|=WButtonDown(button);  //set window button down bit
   //double-click also can call ButtonDownhold functions
   tcontrol->lasttime[button].tv_sec=PStatus.utime.tv_sec;
   tcontrol->lasttime[button].tv_usec=PStatus.utime.tv_usec;
if (tcontrol->type==CTFileOpen && button==0) {
//  litem=GetFTItem(tcontrol->ilist,0,tcontrol->i[1]);
  if (tcontrol->ilist!=0) {
//    litem=GetFTItem(tcontrol->ilist,0,tcontrol->ilist->cur);
//    litem=GetFTItem(tcontrol->ilist,tcontrol->ilist->cur);
//since this is a double-click - the item may not yet be selected
    litem=GetFTItemByNum(tcontrol,tcontrol->ilist->cur+1);
      if (litem>0 && litem->Bits&FTI_FOLDER) {
        tcontrol->ilist->cur=0;  //reset cur index
        tcontrol->i[0]=0;
        chdir(litem->name);
        tcontrol->ilist->Bits|=FTIL_REREAD;
        strcpy(tcontrol->filename,"");  
        i=(int)((y-tcontrol->y1)/(tcontrol->font->max_bounds.ascent+tcontrol->font->max_bounds.descent));
        strcpy(tcontrol->filename,litem->name); //filename gets only file, text gets file and folder name
  //      tcontrol->i[1]=tcontrol->i[0]+i;  //set index tfor text to draw selected    
       if (tcontrol->OnChange!=0) {
					(*tcontrol->OnChange) (twin,tcontrol);
  //    fprintf(stderr,"%s\n",tcontrol->filename);
if (tcontrol->ButtonDoubleClick[button]>0)
(*tcontrol->ButtonDoubleClick[button]) (twin,tcontrol,x,y);
//twin->focus=tcontrol->num;
}  //if FTControl had double-click button down
tcontrol=(FTControl *)tcontrol->next;
//click downup was not in any FTControl - change focus to window
for(i=0;i<strlen(tcontrol->text);i++) {
  if (!(i>=tcontrol->i[2] && i<tcontrol->i[3])) { //not selected text, do not erase-ignore
    tstr[tx]=tcontrol->text[i];
  if (i==tcontrol->i[2]) 
    tcontrol->i[0]=tx;  //is start of selected text, move cursor here         
strcpy(tcontrol->text,tstr); 
tcontrol->text2[0]=0;
tcontrol->i[2]=0;
tcontrol->i[3]=0;
tcontrol->i[4]=0; //4 and 5 used for?
tcontrol->i[5]=0;
		strcpy(winname,twin->name);
  if (GetNextTab(twin,twin->focus)!=twin->focus) {
    tcontrol=GetFTControlWithTab(twin,twin->focus);
    twin->focus=GetNextTab(twin,twin->focus);
 		   //fprintf(stderr,"%s had focus\n",tcontrol->name);
			strcpy(conname,tcontrol->name);
      //if (tcontrol->type==CTCombo && tcontrol->Bits&CItemListOpen) EraseMenu(tcontrol);
			if (tcontrol->type==CTCombo && tcontrol->Bits&CItemListOpen) CloseFTItemList(tcontrol->ilist);
      if (tcontrol->type==CTTextBox || tcontrol->type==CTTextArea) DrawFTControl(tcontrol);  //remove cursor
      if (tcontrol->LostFocus!=0) (*tcontrol->LostFocus) (twin,tcontrol);
    tcontrol2=GetFTControlWithTab(twin,twin->focus);
      //fprintf(stderr,"%s now has focus\n",tcontrol2->name);
      if (tcontrol2->type==CTTextBox || tcontrol2->type==CTTextArea) {
        tcontrol2->i[0]=strlen(tcontrol2->text);
      if (tcontrol2->GotFocus!=0) {
				(*tcontrol2->GotFocus) (twin,tcontrol2);
strcpy(winname,twin->name);
  if (GetPrevTab(twin,twin->focus)!=twin->focus) {
    //tcontrol=GetFTControlWithTab(twin,GetNextTab(twin,twin->focus));
    tcontrol=GetFTControlWithTab(twin,twin->focus);
    twin->focus=GetPrevTab(twin,twin->focus);
			strcpy(conname,tcontrol->name);
//      if (tcontrol->type==CTCombo && tcontrol->Bits&CItemListOpen) EraseMenu(tcontrol);
      if (tcontrol->type==CTCombo && tcontrol->Bits&CItemListOpen) CloseFTItemList(tcontrol->ilist);
      if (tcontrol->type==CTTextBox || tcontrol->type==CTTextArea) DrawFTControl(tcontrol);  //remove cursor
      if (tcontrol->LostFocus!=0) (*tcontrol->LostFocus) (twin,tcontrol);
    tcontrol2=GetFTControlWithTab(twin,twin->focus);
      if (tcontrol2->type==CTTextBox || tcontrol2->type==CTTextArea) {
        tcontrol2->i[0]=strlen(tcontrol2->text);
      if (tcontrol2->GotFocus!=0) {
				(*tcontrol2->GotFocus) (twin,tcontrol2);
//CheckFTWindowKeypress - handle keypress in an FTWindow
		fprintf(stderr,"in window %s\n",twin->name);
//process Keypress for FTControl with focus only - do not bother with other FTControls
	strcpy(winname,twin->name);
//If an itemlist is open - do not call any user window keypresses - for example, an escape key to close a window would close a window instead of closing a combo control itemlist
		strcpy(conname,tcontrol->name);
		//tlist=GetSelectedFTItemList(tcontrol->ilist);
			tlist=titem->parent;
				tlist=tcontrol->ilist; //no parent, use control ilist 
			tlist=tcontrol->ilist; //the open itemlist can only be the filemenu or combo control's itemlist
		fprintf(stderr,"Error: In CheckFTWindowKeypress - PItemListOpen but PStatus.ExclusiveControl=0\n");
		//Different programs handle this differently - 
	//Close any open ItemList - but just the last one
	//possibly just GetSelectedItemList(); returns current ilist - there can only be ony itemlist open
					if (titem->ilist!=0) { //item has subitemlist
					} //titem->ilist
				if (tlist->control!=0) {
					if (tlist->control->type==CTCombo) {
						tlist->cur=tlist->orig; //set cur to original selected item
						tlist->control->value=tlist->cur;
						if (tlist->cur==0) {
							strcpy(tlist->control->text,"");  //perhaps track original text
//						fprintf(stderr,"Setting cur to %d\n",tlist->orig);
				} //tlist->control!=0
					if (tcontrol->type==CTCombo) {
						tcontrol->value=titem->num;//tcontrol->ilist->cur;
					CloseFTItemList(tcontrol->ilist);
					if (titem->click[0]!=0) {
						(*titem->click[0]) (twin,tcontrol,0,0);
						if (tcontrol->type==CTCombo) {
				if (tlist->cur==0) {  //no item selected
					tlist->cur=tlist->num;
					DrawSelectedFTItem(tlist,tlist->cur);
					titem=GetFTSubItemByNum(tlist,tlist->cur);						
						if (titem->ilist!=0) { //this item has a subitemlist
								OpenFTItemList(titem->ilist); //open the subitemlist
						} //titem->ilist!=0
					if (tcontrol->OnChange!=0) {
						(*tcontrol->OnChange) (twin,tcontrol);
					newcur=tlist->cur-1;
						newcur=tlist->num;
					if (newcur!=tlist->cur) {
						titem=GetFTSubItemByNum(tlist,tlist->cur);
						CloseFTItemList(titem->ilist); //this does necessary checks for ilist==0, etc.
						DrawUnselectedFTItem(tlist,tlist->cur);
						tlist->cur=newcur;
						DrawSelectedFTItem(tlist,tlist->cur);						
						titem=GetFTSubItemByNum(tlist,tlist->cur);						
							if (titem->ilist!=0) { //this item has a subitemlist
									OpenFTItemList(titem->ilist); //open the subitemlist
							} //titem->ilist!=0
						//selected item has changed so call any OnChange functions - done in DrawSelectedFTItem
//						if (tcontrol->OnChange!=0) {
//							(*tcontrol->OnChange) (twin,tcontrol);
					} //newcur!=tlist->cur
				} //tlist->cur==0
			  //fprintf(stderr,"down arrow 0 %s\n",twin->name);
				//fprintf(stderr,"tlist->cur=%d\n",tlist->cur);
				if (tlist->cur==0) {  //no item selected
					tlist->cur=1;
					titem=GetFTSubItemByNum(tlist,tlist->cur);						
						if (titem->ilist!=0) { //this item has a subitemlist
								OpenFTItemList(titem->ilist); //open the subitemlist
						} //titem->ilist!=0
//					if (tcontrol->OnChange!=0) {
//						(*tcontrol->OnChange) (twin,tcontrol);
					newcur=tlist->cur+1;
					if (newcur>tlist->num) {
					if (newcur!=tlist->cur) {
						titem=GetFTSubItemByNum(tlist,tlist->cur);
							CloseFTItemList(titem->ilist); //this does necessary checks for ilist==0, etc.
						DrawUnselectedFTItem(tlist,tlist->cur);
						tlist->cur=newcur;
						DrawSelectedFTItem(tlist,tlist->cur);						
						titem=GetFTSubItemByNum(tlist,tlist->cur);						
							if (titem->ilist!=0) { //this item has a subitemlist
									OpenFTItemList(titem->ilist); //open the subitemlist
							} //titem->ilist!=0
//						if (tcontrol->OnChange!=0) {
//							(*tcontrol->OnChange) (twin,tcontrol);
					} //newcur!=tlist->cur
				} //tlist->cur==0
					if (titem->ilist!=0) { //item has subitemlist
						if (titem->ilist->window!=0) {
							twin=titem->ilist->window;
							if (!(twin->Bits&WOpen)) {
								OpenFTItemList(titem->ilist);
						} //titem->ilist->window!=0
						tlist=titem->ilist;
						tlist->cur=1;
						DrawSelectedFTItem(tlist,tlist->cur);
//						if (tcontrol->OnChange!=0) {
//							(*tcontrol->OnChange) (twin,tcontrol);
					} else { //titem->ilist!=0
						//there is no subitemlist - go to next filemenu control if any
					} //titem->ilist!=0
					//no item is selected - go to next file control
				if (tlist->parent==0) { //is descended from a control - is not subitemlist
					//some item must be selected - above tlist is from selected item but make sure anyway
						DrawUnselectedFTItem(tlist,tlist->cur);
						tlist->cur=0;
						tlist=tlist->parent;
						PStatus.SelectedFTItem=GetFTSubItemByNum(tlist,tlist->cur);
				} //tlist->parent==0
} //PStatus.Bits&PItemListOpen - program has a control with exclusive control over input
//possibly exit after found= can only click on 1 FTControl - need depth for scroll bar drag button
if (twin->Keypress!=0) {
	*(twin->Keypress) (twin,key);
} //twin->Keypress
if (twin->icontrol!=0 && (!(PStatus.Bits&PExclusive) || twin==PStatus.ExclusiveFTWindow)) {
//  tcontrol=twin->icontrol;
	fprintf(stderr,"twin=%s twin->focus=%d\n",twin->name,twin->focus);
tcontrol=GetFTControlWithTab(twin,twin->focus);
//fprintf(stderr,"FTControl tab=%d focus=%d\n",tcontrol->tab,twin->focus);
//if (tcontrol->win==win && pwin[win].focus==a)
//if (tcontrol->win==twin->num && twin->focus==tcontrol->tab)
	fprintf(stderr,"FTControl %s has focus\n",tcontrol->name);
	strcpy(conname,tcontrol->name);
//  if (!(twin->Bits&WItemListOpen) &&
//Check Hotkeys - for filemenu keys
  if (!(twin->Bits&WItemList) &&
      !(tcontrol->Bits&CNoTab) &&
       tcontrol->type!=CTLabel) { //tab may erase selected text=shouldn't
					//DrawFTControl(GetFTControlWithTab(twin,twin->focus));
					//DrawFTControl(GetFTControlWithTab(twin,twin->focus));
  }  //end if not !(twin->Bits&WItemListOpen), has no tab, or is Label
//2) only erase and redraw cursor for arrow keys - or just row
if (tcontrol->type==CTTextBox || tcontrol->type==CTTextArea)
strcpy(istr,tcontrol->text);//to see if need to call OnChange()
fw=tcontrol->font->max_bounds.width;
fh=tcontrol->font->max_bounds.ascent+tcontrol->font->max_bounds.descent;
maxwidth=(int)((tcontrol->x2-tcontrol->x1)/fw); 
maxheight=(int)((tcontrol->y2-tcontrol->y1)/fh); 
//cntl-a select all text
//I think with cap lock cntl-V did not work
//cut-copy-paste
			tcontrol->i[2]=0;
			tcontrol->i[3]=strlen(tcontrol->text);
     //fprintf(stderr,"Copy %s\n",tcontrol->text2);
		if (tcontrol->i[2]!=tcontrol->i[3]) { //only if there is selected text
			if (twin->xwindow!=0) {
				memcpy(tstr,&tcontrol->text[tcontrol->i[2]],tcontrol->i[3]-tcontrol->i[2]);
				tstr[tcontrol->i[3]-tcontrol->i[2]]=0;
				//XChangeProperty(PStatus.xdisplay,twin->xwindow,XA_PRIMARY,XA_STRING,
			//            8, PropModeReplace, (unsigned char *)tcontrol->text2,strlen(tcontrol->text2));
			//XChangeProperty appears to have a text limit of 7 characters - I can't figure out why
			//it seemed that XSetStandardProperties(PStatus.xdisplay,twin->xwindow,twin->title,twin->ititle,None,NULL,0,NULL);
			//fprintf(stderr,"string %s length=%d and %d\n",tstr,(int)strlen(tstr),tcontrol->i[3]-tcontrol->i[2]);
			result=XChangeProperty(PStatus.xdisplay,twin->xwindow,XA_PRIMARY,XA_STRING,
								fprintf(stderr,"control-c XChangeProperty failed %d\n",result);
			result=XChangeProperty(PStatus.xdisplay,twin->xwindow,XA_SECONDARY,XA_STRING,
								fprintf(stderr,"control-c XChangeProperty failed %d\n",result);
				XSetSelectionOwner(PStatus.xdisplay,XA_CLIPBOARD,twin->xwindow,CurrentTime);
				if (twin->xwindow!=XGetSelectionOwner(PStatus.xdisplay,XA_CLIPBOARD))
			//make this window own the clipboard selection - needs twice for some reason
				XSetSelectionOwner(PStatus.xdisplay,XA_CLIPBOARD,twin->xwindow,CurrentTime);
				if (twin->xwindow!=XGetSelectionOwner(PStatus.xdisplay,XA_CLIPBOARD))
} //		if (tcontrol->i[2]!=tcontrol->i[3]) { //only if there is selected text
     result=XConvertSelection(PStatus.xdisplay,XA_CLIPBOARD,XA_STRING,XA_PRIMARY,twin->xwindow,CurrentTime);
		      fprintf(stderr,"control-v XChangeProperty failed %d\n",result);
 //    if (result==BadWindow) fprintf(stderr,"convert selection error - BadWindow\n");
  //   if (result==BadAtom) fprintf(stderr,"convert selection error - BadAtom\n");
//wait for SelectionRequest-SelectionNotify?
ltim=PStatus.ctime->tm_sec;  //PStatus.utime.tv_usec
while (!(PStatus.Bits&PGotSelection) && PStatus.ctime->tm_sec<ltim+1) {
   if (twin->xwindow!=0) 
     XGetWindowProperty(PStatus.xdisplay,twin->xwindow,XA_PRIMARY,0,10000000L,0,XA_STRING,&type,&format,&len,&bytes_left,&data);				
   cx=tcontrol->i[0];
   for(i=0;i<=strlen(tcontrol->text);i++) {
     if (i==tcontrol->i[0]) { //this is where the cursor is, insert the pasted text
     } //end if i==tcontrol->i[0], insert pasted text
     if (i<strlen(tcontrol->text) && !(i>=tcontrol->i[2] && i<tcontrol->i[3])) { 
       //not selected text, do not erase-ignore (ignore selected text which will not be copied to new string)
       tstr[tx]=tcontrol->text[i];
   tcontrol->i[0]=cx; //move cursor to end of pasted text
   tcontrol->i[2]=cx;
   tcontrol->i[3]=cx;
   if (strlen((char *)data)>0 && strlen(tcontrol->text)==0) {
     tcontrol->i[0]=len; //move cursor to end of pasted text
//   fprintf(stderr,"here1.5 i4=%d i5=%d\n",tcontrol->i[4],tcontrol->i[5]);
//   fprintf(stderr,"here2 tx=%d tstr=%s text=%s\n",tx,tstr,tcontrol->text);
   strcpy(tcontrol->text,tstr); 
//   fprintf(stderr,"here3 tx=%d tstr=%s text=%s\n",tx,tstr,tcontrol->text);
	i=tcontrol->i[0];
		if (tcontrol->text[i]==10) {
			tcontrol->i[1]=i+1;
				i=-1; //exit 
	i--;
   if (tcontrol->i[0]>maxwidth) {
     tcontrol->i[1]=strlen(tcontrol->text)-maxwidth;
     tcontrol->i[0]=strlen(tcontrol->text);
     //fprintf(stderr,"Scoop (Cut) %s\n",tcontrol->text2);
		if (tcontrol->i[2]!=tcontrol->i[3]) { //only if there is selected text
     if (twin->xwindow!=0) {
//       XChangeProperty(PStatus.xdisplay,twin->xwindow,XA_PRIMARY,XA_STRING,
 //           8, PropModeReplace, (unsigned char *)tcontrol->text2,strlen(tcontrol->text2));
				strncpy(tstr,&tcontrol->text[tcontrol->i[2]],tcontrol->i[3]-tcontrol->i[2]);
       XChangeProperty(PStatus.xdisplay,twin->xwindow,XA_PRIMARY,XA_STRING,
      XSetSelectionOwner(PStatus.xdisplay,XA_CLIPBOARD,twin->xwindow,CurrentTime);
      if (twin->xwindow!=XGetSelectionOwner(PStatus.xdisplay,XA_CLIPBOARD))
       XChangeProperty(PStatus.xdisplay,twin->xwindow,XA_SECONDARY,XA_STRING,
      XSetSelectionOwner(PStatus.xdisplay,XA_CLIPBOARD,twin->xwindow,CurrentTime);
      if (twin->xwindow!=XGetSelectionOwner(PStatus.xdisplay,XA_CLIPBOARD))
     for(i=0;i<strlen(tcontrol->text);i++) {
       if (!(i>=tcontrol->i[2] && i<tcontrol->i[3])) { //not selected text, do not erase-ignore
         tstr[tx]=tcontrol->text[i];
       if (i==tcontrol->i[2] && tcontrol->i[2]!=tcontrol->i[3]) 
         tcontrol->i[0]=tx;  //is start of selected text, move cursor here         
     strcpy(tcontrol->text,tstr); 
     //tcontrol->text2[0]=0;
     tcontrol->i[2]=0;
     tcontrol->i[3]=0;
//     tcontrol->i[4]=0;
//     tcontrol->i[5]=0;
		}		//if (tcontrol->i[2]!=tcontrol->i[3]) { //only if there is selected text
  fprintf(stderr,"textbox %s is not wide enough for this font of text.\n",tcontrol->name);
//fprintf(stderr,"FTControl %s focus=%d\n",tcontrol->name,twin->focus,tcontrol->tab);
//bw=tcontrol->x2-tcontrol->x1;
bh=tcontrol->y2-tcontrol->y1;
if (tcontrol->font->max_bounds.ascent+tcontrol->font->max_bounds.descent>bh)
  fprintf(stderr,"textbox %s is not tall enough for this font of text.\n",tcontrol->name);
//cx=(tcontrol->i[0]-tcontrol->i[1])*fw;
//XSetForeground (PStatus.xdisplay, twin->xgc, 0x0);
//tx=tcontrol->x1+tcontrol->cx+1;
//XDrawLine(PStatus.xdisplay,twin->xwindow,twin->xgc,tx,tcontrol->y1+1,tx,tcontrol->y2-1);
//->cx is the current location in the textbox
//->i[0] is the location in the string (with no regard to scrolled text offscreen)
//-27: //caps lock
//-29:  //right ctrl
//-30:  //left shift
//-31:  //right shift left and right
//watch out for keys other than A-Z, a-z 0-9 and punctuation
//case 0x64://-44: //left arrow
if (tcontrol->type==CTTextArea && tcontrol->i[1]>0) {
	//tlen=strlen(tcontrol->text);
	if (tcontrol->i[0]==tcontrol->i[1]) { //need to scroll back one line
		i=tcontrol->i[1];
		while(i>-1) {
			if (i==0) tcontrol->i[1]=0;
			else tcontrol->i[1]=i+1;
			if (tcontrol->text[i]==10) {
				if (j>1) i=-1; //exit while
		i--;
     if (tcontrol->i[2]==tcontrol->i[3]) {
//       tcontrol->i[2]=(tcontrol->i[0]-tcontrol->i[1])*fw;  //these are in pixels not characters
       tcontrol->i[2]=tcontrol->i[0];  //these are in characters
       tcontrol->i[3]=tcontrol->i[0];  //these are in characters
     if (tcontrol->i[0]>0) {
        if (tcontrol->type==CTTextBox && tcontrol->i[1]>0 && (tcontrol->i[0]-tcontrol->i[1])==0) {
          tcontrol->i[1]--;  
//        if (tcontrol->i[5]-tcontrol->i[1]>maxwidth) tcontrol->i[4]--;//move left selection marker 1 left
          //tcontrol->i[4]--;//=tcontrol->i[0]-tcontrol->i[1];  //move selection marker
        tcontrol->i[0]--;  //move cursor
//        tcontrol->i[4]=tcontrol->i[0];
        if (tcontrol->i[0]<tcontrol->i[2]) tcontrol->i[2]=tcontrol->i[0];
        else tcontrol->i[3]=tcontrol->i[0];
    if (tcontrol->i[0]>0 && tcontrol->i[0]>=tcontrol->i[1]) {
      if (tcontrol->type==CTTextBox && tcontrol->i[0]==tcontrol->i[1]) {
        tcontrol->i[1]--;
   tcontrol->i[0]--;
//case 0x62: //-43:  //up arrow
if (tcontrol->type==CTTextBox) {
	if (tcontrol->i[2]!=tcontrol->i[3]) { //there is selected text
	//  fprintf(stderr,"next tab=%d\n",GetNextTab(twin,twin->focus));
} else { //CTTextArea - up arrow may move up a row 
//case 0x66: //-45:  //right arrow
     if (tcontrol->i[2]==tcontrol->i[3]) {
       tcontrol->i[2]=tcontrol->i[0];
       tcontrol->i[3]=tcontrol->i[0];
     if (strlen(tcontrol->text)>tcontrol->i[0]) {
       tcontrol->i[0]++;  //move cursor
       if (tcontrol->type==CTTextBox && tcontrol->i[0]-tcontrol->i[1]>maxwidth) {
         tcontrol->i[1]++;
         //if (tcontrol->i[4]>0) tcontrol->i[4]--;  //have to move left selection marker 1 left
//         tcontrol->i[5]++;//=tcontrol->i[0]-tcontrol->i[1];  //move selection marker (in pixels)
      if (tcontrol->i[0]>tcontrol->i[3]) tcontrol->i[3]=tcontrol->i[0];
      else tcontrol->i[2]=tcontrol->i[0];
  if (tcontrol->i[0]<strlen(tcontrol->text)) {
    if (tcontrol->type==CTTextBox) {
			if  ((tcontrol->i[0]-tcontrol->i[1])==maxwidth) {
	      tcontrol->i[1]++;
   tcontrol->i[0]++;
	//scroll if necessary - all this just for scrolling - there must be some more simple way - the problem is that chr(10) throws off the mapping of characters to pixels
	if (tcontrol->type==CTTextArea) {
			i=tcontrol->i[1];
			tlen=strlen(tcontrol->text);
			while(i<tcontrol->i[0]) {
				if (tcontrol->text[i]==10) {
			if (cy==maxheight) { //need to adjust i[1] - first character showing
				i=tcontrol->i[1];
					if (i==0) tcontrol->i[1]=0;
					else tcontrol->i[1]=i+1;				
					if (tcontrol->text[i]==10) {
//case 0x68: //-42:  //down arrow
if (tcontrol->type==CTTextBox) {
	if (tcontrol->i[2]!=tcontrol->i[3]) { //there is selected text
//  fprintf(stderr,"next tab=%d\n",GetNextTab(twin,twin->focus));
//case 0x61://-40: //home also P
     if (tcontrol->i[2]==tcontrol->i[3]) {
       tcontrol->i[2]=tcontrol->i[0];
       tcontrol->i[3]=tcontrol->i[0];
		if (tcontrol->type==CTTextArea) {
			i=tcontrol->i[0]-1;
				tcontrol->i[0]=i;
				if (tcontrol->text[i]==10) {
					tcontrol->i[0]=i+1; //need to move ahead 1
					i=-1;
				i--;
			tcontrol->i[0]=0;
			tcontrol->i[1]=0;
		if (tcontrol->i[0]<=tcontrol->i[2]) {
			tcontrol->i[2]=tcontrol->i[0]; 
			tcontrol->i[3]=tcontrol->i[0]; 
  //interesting phenom-selection goes from begin of selection
  if (tcontrol->i[2]!=tcontrol->i[3]) { //there is a selection
    tcontrol->i[0]=tcontrol->i[2];   //move cursor to begin of selection
  tcontrol->i[3]=tcontrol->i[0];
  tcontrol->i[0]=0;
  tcontrol->i[1]=0;
  tcontrol->i[2]=tcontrol->i[0];
  if (tcontrol->i[0]>0 || tcontrol->i[1]>0) {
    tcontrol->i[0]=0;
    tcontrol->i[1]=0;
//case 0x67: //-41: //end
		   if (tcontrol->i[2]==tcontrol->i[3]) {
		     tcontrol->i[2]=tcontrol->i[0];
		     tcontrol->i[3]=tcontrol->i[0];
	if (tcontrol->type==CTTextArea) {
		tlen=strlen(tcontrol->text);
		i=tcontrol->i[0];
			tcontrol->i[0]=i;
			if (tcontrol->text[i]==10) {
		tcontrol->i[0]=strlen(tcontrol->text);
		if (strlen(tcontrol->text)>maxwidth) {
			tcontrol->i[1]=strlen(tcontrol->text)-maxwidth;
			//tcontrol->i[1]=0;
			if (tcontrol->i[0]<=tcontrol->i[2]) {
				tcontrol->i[2]=tcontrol->i[0]; 
				tcontrol->i[3]=tcontrol->i[0]; 
//mouse button or shift key is down - move selected text to end
  //interesting phenom-selection goes from begin of selection
  if (tcontrol->i[2]!=tcontrol->i[3]) { //there is a selection
    //tcontrol->i[0]=tcontrol->i[3];   //move cursor to begin of selection
		tcontrol->i[0]=tcontrol->i[3];   //move cursor to begin of selection
  tcontrol->i[2]=tcontrol->i[0];
  tcontrol->i[0]=strlen(tcontrol->text);
  if (tcontrol->type==CTTextBox) {
	  if (strlen(tcontrol->text)>maxwidth) tcontrol->i[1]=tcontrol->i[0]-maxwidth;
  	else tcontrol->i[1]=0;
  tcontrol->i[3]=tcontrol->i[0];
//  if (tcontrol->type==CTTextArea) {
  if (tcontrol->i[0]<strlen(tcontrol->text)) {
    tcontrol->i[0]=strlen(tcontrol->text);
    if (tcontrol->type==CTTextBox && strlen(tcontrol->text)>maxwidth)  tcontrol->i[1]=strlen(tcontrol->text)-maxwidth;
//case -28:  //left ctrl
//case -29:  //right ctrl
//case -30:  //left shift
//case -31:  //right shift left and right
//case -27: //caps lock
//case -1:  //delete key
if (tcontrol->i[2]!=tcontrol->i[3]) { //there is selected text
if (tcontrol->i[0]>=0)
strcpy(&tcontrol->text[tcontrol->i[0]],&tcontrol->text[tcontrol->i[0]+1]);
if (tcontrol->type==CTTextBox && tcontrol->i[0]==tcontrol->i[1] && tcontrol->i[1]>0)
  tcontrol->i[1]--;
//fprintf(stderr,"%s\n",tcontrol->text);
if (tcontrol->i[2]!=tcontrol->i[3]) { //there is selected text
if (tcontrol->type==CTTextArea) {
if (!(tcontrol->Bits&CReadOnly)) {
	strcpy(tstr,tcontrol->text);
	tstr[tcontrol->i[0]]=10;
	tcontrol->i[0]++;
	tstr[tcontrol->i[0]]=0;
	strcpy(istr,&tcontrol->text[tcontrol->i[0]-1]);
	sprintf(tcontrol->text,"%s%s",tstr,istr);
	tlen=strlen(tcontrol->text);
	i=tcontrol->i[1];
		if (tcontrol->text[i]==10) {
				j=tcontrol->i[1];
					tcontrol->i[1]=j+1;
					if (tcontrol->text[j]==10) {
	if (tcontrol->i[0]-tcontrol->i[1]>=maxwidth)
		tcontrol->text[tcontrol->i[0]]=10;// use 10 instead of 13 key;
		tcontrol->text[tcontrol->i[0]+1]=0;
		tcontrol->i[0]++;  //total length of string (could get from strlen(tcontrol->text) I guess
		tcontrol->i[1]++;  //1st char in left of textbox
	tlen=strlen(tcontrol->text);
	if (tcontrol->i[0]<tlen)
		tcontrol->text[tlen+2]=0;
		for(a=tlen+1;a>tcontrol->i[0];a--)
		  tcontrol->text[a]=tcontrol->text[a-1];
		tcontrol->text[tcontrol->i[0]]=10;//key;
		tcontrol->text[tcontrol->i[0]]=10;//key;
		tcontrol->text[tcontrol->i[0]+1]=0;
	tcontrol->i[0]++;
if (tcontrol->i[2]!=tcontrol->i[3]) { //there is selected text
  if (tcontrol->i[0]>0) {
  //fprintf(stderr,"textvis=%d\n",strlen(tcontrol->textvis));
    strcpy(&tcontrol->text[tcontrol->i[0]-1],&tcontrol->text[tcontrol->i[0]]);
  if (tcontrol->type==CTTextBox && tcontrol->i[0]==tcontrol->i[1]) {
    tcontrol->i[1]--;
  tcontrol->i[0]--;
//fprintf(stderr,"%s\n",tcontrol->text);
if (tcontrol->i[2]!=tcontrol->i[3]) { //there is selected text
//  fprintf(stderr,"next tab=%d\n",GetNextTab(twin,twin->focus));
//one interpretation of page up is that the entire page should shift leaving one line from the previous page - the cursor stays on the same row - gedit has this
//either way - probably the cursor should stay on the same row
//probably storing row and col would be easier - and then deal with chr(10) when drawing only - either way the text probably has to be while looped through unless perhaps there is an array
	if (tcontrol->type==CTTextArea) {
//			fprintf(stderr,"i[0]=%d i[1]=%d\n",tcontrol->i[0],tcontrol->i[1]);
	if (tcontrol->type==CTTextArea) {
//			fprintf(stderr,"i[0]=%d i[1]=%d\n",tcontrol->i[0],tcontrol->i[1]);
if (tcontrol->i[2]!=tcontrol->i[3]) { //there is selected text
if (!(tcontrol->Bits&CReadOnly)) {
	if (tcontrol->type==CTTextBox && tcontrol->i[0]-tcontrol->i[1]>=maxwidth) {
//		tcontrol->text[tcontrol->i[0]]=key;
//		tcontrol->text[tcontrol->i[0]]=mapkey[0];
		tcontrol->text[tcontrol->i[0]]=PStatus.asckey;
//		tcontrol->text[tcontrol->i[0]]=*XKeysymToString(key);
//		tcontrol->text[tcontrol->i[0]]=XKeysymToKeycode(PStatus.xdisplay,key);
//		fprintf(stderr,"key is= %c\n",tcontrol->text[tcontrol->i[0]]);
		tcontrol->text[tcontrol->i[0]+1]=0;
		//tcontrol->i[0]++; //is done below //total length of string (could get from strlen(tcontrol->text) I guess
		tcontrol->i[1]++;  //1st char in left of textbox
	tlen=strlen(tcontrol->text);
	if (tcontrol->i[0]<tlen) {
		tcontrol->text[tlen+2]=0;
		for(a=tlen+1;a>tcontrol->i[0];a--)
		  tcontrol->text[a]=tcontrol->text[a-1];
//		tcontrol->text[tcontrol->i[0]]=key;
//		tcontrol->text[tcontrol->i[0]]=mapkey[0];
		tcontrol->text[tcontrol->i[0]]=PStatus.asckey;
//		tcontrol->text[tcontrol->i[0]]=XKeysymToKeycode(PStatus.xdisplay,key);
//		fprintf(stderr,"key is= %c\n",tcontrol->text[tcontrol->i[0]]);
//		tcontrol->text[tcontrol->i[0]]=key;
//		tcontrol->text[tcontrol->i[0]]=*XKeysymToString(key);
//			tcontrol->text[tcontrol->i[0]]=mapkey[0];
			tcontrol->text[tcontrol->i[0]]=PStatus.asckey;
//			fprintf(stderr,"key is= %c\n",tcontrol->text[tcontrol->i[0]]);
			tcontrol->text[tcontrol->i[0]+1]=0;
//		tcontrol->text[tcontrol->i[0]]=XKeysymToKeycode(PStatus.xdisplay,key);
	tcontrol->i[0]++;
//fprintf(stderr,"text=%s\n",tcontrol->text);
  tcontrol->i[2]=0;
  tcontrol->i[3]=0;
//  tcontrol->i[4]=0;
//  tcontrol->i[5]=0;
if (strcmp(istr,tcontrol->text)!=0) {
  if (tcontrol->OnChange!=0) {
		(*tcontrol->OnChange) (twin,tcontrol);
if (tcontrol->tab==twin->focus && (tcontrol->type==CTFileMenu || tcontrol->type==CTCombo)) {
 				if (tcontrol->type==CTCombo) {
					//Down arrow opens combo (and filemenu? an unopened filemenu cannot be tabbed to - but if it can open too, I guess)
					tcontrol->ilist->cur=1;
					//tcontrol->ilist->orig=1;
					OpenFTItemList(tcontrol->ilist); //Open will draw					
					//need to tcontrol->Bits|=CItemListOpen ?
//				fprintf(stderr,"Escape close %s ItemList\n",tcontrol->name);
					CloseFTItemList(tcontrol->ilist);
if (tcontrol->type==CTFileOpen)
  if (tcontrol->ilist!=0) {
   if (tcontrol->ilist->cur<tcontrol->ilist->num-1) {  
//  fprintf(stderr,"Keypress func up top=%d cur=%d num=%d\n",tcontrol->i[0],tcontrol->i[1],tcontrol->ilist->num);
    if (tcontrol->ilist->cur==(tcontrol->i[0]+tcontrol->numvisible-1))
      tcontrol->i[0]++;
    tcontrol->ilist->cur++;
    //litem=GetFTItem(tcontrol->ilist,0,tcontrol->ilist->cur);
		litem=GetFTItemByNum(tcontrol,tcontrol->ilist->cur+1);
    strcpy(tcontrol->text,litem->name); //text gets folders and files
    if (!(litem->Bits&FTI_FOLDER))
      strcpy(tcontrol->filename,litem->name);
      strcpy(tcontrol->filename,"");  
    if (tcontrol->OnChange!=0) {
			(*tcontrol->OnChange) (twin,tcontrol);
  }  //tcontrol->ilist->cur<tcontrol->ilist->num-1
//    strcpy(tcontrol2->text,tcontrol->filename);  //need foOpenFile_OnChange() func to update txtOpen
//    if (tcontrol2->value!=0) DrawImage();  //if preview==1
//  fprintf(stderr,"Keypress func up top=%d cur=%d\n",tcontrol->i[0],tcontrol->i[1]);
  if (tcontrol->ilist!=0) {
//    if (tcontrol->ilist->cur>0) {
    if (tcontrol->ilist->cur>0) {
      if (tcontrol->ilist->cur==tcontrol->i[0])
        tcontrol->i[0]--;
      tcontrol->ilist->cur--;
//      litem=GetFTItem(tcontrol->ilist,0,tcontrol->ilist->cur);
      litem=GetFTItemByNum(tcontrol,tcontrol->ilist->cur+1);
		    strcpy(tcontrol->text,litem->name); //text gets folders and files
		    if (!(litem->Bits&FTI_FOLDER))
		      strcpy(tcontrol->filename,litem->name);
		      strcpy(tcontrol->filename,"");  
//    fprintf(stderr,"Keypress func up i0=%d i1=%d\n",tcontrol->i[0],tcontrol->i[1]);
    //strcpy(tcontrol2->text,tcontrol->filename);  //need onChange() func to update txtOpen
      if (tcontrol->OnChange!=0) {
				(*tcontrol->OnChange) (twin,tcontrol);
     } //tcontrol->ilist->cur
//      strcpy(tcontrol2->text,tcontrol->filename);
//      if (tcontrol2->value!=0) DrawImage();  //if preview==1
  } //tcontrol->ilist->cur
  if (tcontrol->ilist!=0) {
//  litem=GetFTItem(tcontrol->ilist,0,tcontrol->ilist->cur);
  litem=GetFTItemByNum(tcontrol,tcontrol->ilist->cur+1);
  if (litem!=0 && litem->Bits&FTI_FOLDER) {
    tcontrol->ilist->cur=0;
    tcontrol->i[0]=0;
    chdir(litem->name);
    tcontrol->ilist->Bits|=FTIL_REREAD;
    strcpy(tcontrol->filename,"");  
    if (tcontrol->OnChange!=0) {
			(*tcontrol->OnChange) (twin,tcontrol);
if (tcontrol->Keypress>0)
(*tcontrol->Keypress) (twin,tcontrol,key);
//  twin->Bits|=WClose;
//  XDestroyWindow(PStatus.xdisplay, twin->xwindow);
//  twin->xwindow=0;
//signal(sig,catch_alarm); //re-enable signal handler - apparently not needed
//setitimer - causes the read of the video image to fail - returns black
//check on 02/25/09 - this loop processed every 7 or 8 usec, so very fast relative to a 1 msec timer
		strcpy(winname,twin->name);
		//to disable a timer (for example until needed) set twin->timer=-1, =0 is constant
		if (twin->OnTimer !=0 && twin->timer>=0) {
			//fprintf(stderr,"Found OnTimer function in window %s\n",twin->name);
			tm2=(i64)twin->timertime.tv_sec*1000000+twin->timertime.tv_usec;
			tm2+=twin->timer*1000; //add milliseconds
				twin->timertime.tv_sec=PStatus.utime.tv_sec;
				twin->timertime.tv_usec=PStatus.utime.tv_usec;
				//perhaps all calls out of the main input loop should be put in a low-priority thread, in order to keep the CPU focus on the polling for xevents (keypress, mouse move, resize, etc).
				(*twin->OnTimer) (twin);
		} //twin->OnTimer !=0
	tcontrol=twin->icontrol;
		strcpy(conname,tcontrol->name);
		if (tcontrol->OnTimer !=0 && tcontrol->timer>=0) {
			//fprintf(stderr,"Found OnTimer function for FTControl %s in window %s\n",tcontrol->name,twin->name);
			tm2=(i64)tcontrol->timertime.tv_sec*1000000+tcontrol->timertime.tv_usec;
			tm2+=tcontrol->timer*1000; //add milliseconds
				tcontrol->timertime.tv_sec=PStatus.utime.tv_sec;
				tcontrol->timertime.tv_usec=PStatus.utime.tv_usec;
				//perhaps all calls out of the main input loop should be put in a low-priority thread, in order to keep the CPU focus on the polling for xevents (keypress, mouse move, resize, etc).
				(*tcontrol->OnTimer) (twin,tcontrol);
		} //twin->OnTimer !=0	
	tcontrol=tcontrol->next;
	twin=twin->next;
//   if (XCheckWindowEvent(PStatus.xdisplay, twin->xwindow,xeventmask,&xevent))
      nwin=twin->next;
      if (twin->Bits&WClose) {
	      //DestroyFTWindowByNum(twin->num);
      //twin=(FTWindow *)twin->next;
  if (twin->xwindow==xwin) return(twin);
  twin=twin->next;
//this function checks for twin->Keypress functions
//   if (XCheckWindowEvent(PStatus.xdisplay, twin->xwindow,xeventmask,&xevent))
//possibly this event may have a parent window - not related to freethought
strcpy(winname,twin->name);
     num=twin->num;
					if (twin!=0) fprintf(stderr,"in %s\n",twin->name);
					if (twin!=0) fprintf(stderr,"in %s\n",twin->name);
         if (twin->x!=xevent.xconfigure.x || twin->y!=xevent.xconfigure.y) {
           fprintf(stderr,"Move Window %s\n",twin->name);
           twin->x=xevent.xconfigure.x;  //move
           twin->y=xevent.xconfigure.y;  //move
           if (twin->OnMove!=0) twin->OnMove(twin);
         if (twin->w!=xevent.xconfigure.width ||
             twin->h!=xevent.xconfigure.height) {
           dw=xevent.xconfigure.width-twin->w;
           dh=xevent.xconfigure.height-twin->h; 
           tcontrol=twin->icontrol;
						strcpy(conname,tcontrol->name);
      //fprintf(stderr,"scale FTControl %s\n",tcontrol->name);
      //  fprintf(stderr,"x2=%d bw=%d bh=%d\n",tcontrol->x2,bw,bh);
      //  fprintf(stderr,"x2=%d bw=%d bh=%d\n",tcontrol->x2,bw,bh);
      //fprintf(stderr,"dw=%i dh=%i\n",twin->dw,twin->dh);
      if (tcontrol->Bits&CGrowX1) {
        tcontrol->x1+=dw;
      if (tcontrol->Bits&CGrowY1) {
        tcontrol->y1+=dh;
      if (tcontrol->Bits&CGrowX2) {
        tcontrol->x2+=dw;
        if (tcontrol->type==CTCombo||tcontrol->type==CTRadio||tcontrol->type==CTCheckBox) tcontrol->x3+=dw; //x3 is far right of combo
//        if (tcontrol->type==CTCombo||tcontrol->type==CTRadio||tcontrol->type==CTCheckBox) tcontrol->x3=tcontrol->x2; //x3 is far right of combo
      if (tcontrol->Bits&CGrowY2) {
        tcontrol->y2+=dh;
//        if (tcontrol->type==CTCombo||tcontrol->type==CTRadio||tcontrol->type==CTCheckBox) tcontrol->y3+=dh; 
//        if (tcontrol->type==CTCombo||tcontrol->type==CTRadio||tcontrol->type==CTCheckBox) tcontrol->y4=tcontrol->y2;
        if (tcontrol->type==CTCombo||tcontrol->type==CTRadio||tcontrol->type==CTCheckBox) tcontrol->y3=tcontrol->y2;  
      if (tcontrol->Bits&CScaleX1) {
        tcontrol->x1+=tcontrol->sx1*dw;
      if (tcontrol->Bits&CScaleY1) {
        tcontrol->y1+=tcontrol->sy1*dh;
      if (tcontrol->Bits&CScaleX2) {
        tcontrol->x2+=tcontrol->sx2*dw;
      if (tcontrol->Bits&CScaleY2) {
        tcontrol->y2+=tcontrol->sy2*dh;
    if (tcontrol->type==CTFileOpen) {
       if (tcontrol->ilist!=0) {
         numvisible=(tcontrol->y2-tcontrol->y1)/(tcontrol->font->max_bounds.ascent+tcontrol->font->max_bounds.descent);
         fprintf(stderr,"i[0]=%d numv=%d list->numv=%d\n",tcontrol->i[0],numvisible,tcontrol->ilist->num);
         if ((tcontrol->i[0]+numvisible)>tcontrol->ilist->num) tcontrol->i[0]=tcontrol->ilist->num-numvisible;
         if (tcontrol->i[0]<0) tcontrol->i[0]=0;
         tcontrol->numvisible=(tcontrol->y2-tcontrol->y1)/(tcontrol->font->max_bounds.ascent+tcontrol->font->max_bounds.descent);
//         numvisible=(tcontrol->y2-tcontrol->y1)/(tcontrol->font->max_bounds.ascent+tcontrol->font->max_bounds.ascent);
//         if (tcontrol->ilist->num-tcontrol->i[0]+tcontrol->numvisible>numvisible) {
//           tcontrol->i[0]-=nums-tcontrol->ilist->num;  
//           if (tcontrol->i[0]<0) tcontrol->i[0]=0;
       if (tcontrol->OnResize !=0) {
					(*tcontrol->OnResize) (twin,tcontrol,xevent.xconfigure.x,xevent.xconfigure.y);
    tcontrol=tcontrol->next; 
//       twin->w=xevent.xresizerequest.width;
       twin->w=xevent.xconfigure.width;
       twin->h=xevent.xconfigure.height; 
       //fprintf(stderr,"win now= %d,%d\n",twin->w,twin->h);
       if (twin->OnResize !=0) {
					(*twin->OnResize) (twin);
					if (twin!=0) fprintf(stderr,"in %s\n",twin->name);
			      tcontrol=GetFTControlWithTab(twin,twin->focus);
					if (twin!=0) fprintf(stderr,"in %s\n",twin->name);
					if (twin->OnClose!=0) {
						(*twin->OnClose) (twin);
         if (twin->Bits&WClose) {  //FileMenus do not get WClose
           if (num==0) PStatus.Bits|=PExit;  //exit program - misses OnClose
//							DestroyFTWindow(twin); //need to destroy instead of close - close keeps FT window structure			
					if (twin!=0) fprintf(stderr,"in %s\n",twin->name);
  		         if (twin->Bits&WMsgBox) PStatus.mb=MB_CANCEL; //end messagebox while loop
  		       CloseFTWindowNum(num);//XDestroyWindow(PStatus.xdisplay,twin->xwindow);
//This issue of a program taking focus raises two different views- 1) let programs raise windows, 2) program should not be able to raise windows - only people should be able to
//this can be configured by alt-f3 focus stealing prevention level: None
//This issue is addressed at: http://lists.freedesktop.org/archives/xorg/2006-january/012276.html
									XSetInputFocus(PStatus.xdisplay,PStatus.FocusFTWindow->xwindow, RevertToParent,CurrentTime);
									XRaiseWindow(PStatus.xdisplay,PStatus.FocusFTWindow->xwindow);
//  		       CloseFTWindowNum(num);//XDestroyWindow(PStatus.xdisplay,twin->xwindow);
					if (twin!=0) fprintf(stderr,"in %s\n",twin->name);
       fprintf(stderr,"twin=%x\n",(u32)twin->xwindow);
					if (twin!=0) fprintf(stderr,"in %s\n",twin->name);
       fprintf(stderr,"twin=%x\n",(u32)twin->xwindow);
					XGetWindowProperty(PStatus.xdisplay,twin->xwindow,XA_PRIMARY,0,10000000L,0,XA_STRING,&type,&format,&len,&bytes_left,&data);				
					if (twin!=0) fprintf(stderr,"in %s\n",twin->name);
					if (twin!=0) fprintf(stderr,"in %s\n",twin->name);
				//do not redraw for exposes that take place in milliseconds - lastexpose isn't implemented yet
				//twin->Bits&=~WWaitUntilDoneDrawing; //Window is done drawing now
     if (PStatus.ctime->tm_sec==PStatus.secs) {
        fprintf(stderr,"secs=%d %d\n",PStatus.secs,PStatus.ctime->tm_sec);
        PStatus.secs=PStatus.ctime->tm_sec+5;
					if (twin!=0) fprintf(stderr,"in %s\n",twin->name);
//Need to wait to see if this will be a double-click
// 1st click of double-click will cause ButtonDown events
//perhaps wait until first click can not be double-click
//q: call double-click functions on second button down of double-click, or second button-up of double-click?
//gedit does double-click on ButtonDown
//	           fprintf(stderr,"lastclick=%li delay=%d time=%d\n",twin->lastclick[0],PStatus.dclickdelay,(int)xevent.xbutton.time);
		       if (twin->lastclick[0]!=0 && (twin->lastclick[0]+PStatus.dclickdelay)>(int)xevent.xbutton.time) {
//	           fprintf(stderr,"double-dn click\n ");
	           twin->lastclick[0]=xevent.xbutton.time;
	//           fprintf(stderr,"single-dn click\n ");
	           twin->lastclick[0]=xevent.xbutton.time;
         if (twin->lastclick[1]!=0 && (twin->lastclick[1]+PStatus.dclickdelay)>xevent.xbutton.time) {
//           fprintf(stderr,"double-dn click\n ");
           fprintf(stderr,"single-dn button 2 click\n ");
		       if (twin->lastclick[2]!=0 && (twin->lastclick[2]+PStatus.dclickdelay)>xevent.xbutton.time) {
	//           fprintf(stderr,"double-dn click\n ");
		         fprintf(stderr,"single-dn button 3 click\n ");
					if (twin!=0) fprintf(stderr,"in %s\n",twin->name);
         //fprintf(stderr,"button 1 time = %li\n ",twin->lastclick[0]);
//         if (twin->lastclick[0]!=0 && twin->lastclick[0]+PStatus.dclickdelay>xevent.xbutton.time) {
//         if (twin->lastclick[0]!=0 && (twin->lastclick[0]+PStatus.dclickdelay)>xevent.xbutton.time) {
//           fprintf(stderr,"double-up click\n ");
//           fprintf(stderr,"single-up click\n ");
						twin->lastclick[0]=xevent.xbutton.time;
//       if (twin->lastclick[1]!=0 && (twin->lastclick[1]+PStatus.dclickdelay)>xevent.xbutton.time) {
//           fprintf(stderr,"double-up click\n ");
//           fprintf(stderr,"single-up click\n ");
		       twin->lastclick[1]=xevent.xbutton.time;
//     if (twin->lastclick[2]!=0 && (twin->lastclick[2]+PStatus.dclickdelay)>xevent.xbutton.time) {
//           fprintf(stderr,"double-up click\n ");
//           fprintf(stderr,"single-up click\n ");
     			twin->lastclick[2]=xevent.xbutton.time;
					if (twin!=0) fprintf(stderr,"in %s\n",twin->name);
//      case -28:  //cntrl_r
//      case -29:  //cntrl_l
//      case -30:
//      case -31:  //ignore shift keys
//        if (twin->Keypress>0) (*twin->Keypress) (Keypress);
			//(ISO/IEC 8859-1 = Unicode U+0020..U+00FF)
			if ((symbol>=XK_0 && symbol<=XK_9) || (symbol>=XK_A && symbol<=XK_Z) || (symbol>=XK_a && symbol<=XK_z)) { //ascii key 0-9 A-Z a-z 
			//symbol has the code listed in /usr/include/X11/keysymdef.h - although it does not understand that the shift key is pressed and so 0x20 needs to be subtracted for capital letters
     break; //motion notify - mouse moved (with button down)
     break; //enter notify - mouse moved into window?
     break; //leave notify - mouse moved out of window?
					if (twin!=0) fprintf(stderr,"in %s\n",twin->name);
//        fprintf(stderr,"win=%s\n",twin->name);
//        PStatus.focus=twin->num;
        if (twin->Bits&WExclusive) {  //if window has exclusive, update global bits
        //if (twin->Bits&WItemList) twin->focus=1;
        //else twin->focus=0; //no FTControl can have focus
        if (twin->GotFocus!=0) {
					(*twin->GotFocus) (twin);
				if (twin!=0) fprintf(stderr,"in %s\n",twin->name);
					if (PStatus.MouseOver->Bits&CMouseOver) {
						PStatus.MouseOver->Bits&=~CMouseOver;
					} //PStatus.MouseOver->Bits&CMouseOver
		      tcontrol=GetFTControlWithTab(twin,twin->focus);
//         if ((twin->Bits&WItemList) && !(twin->Bits&WNotVisible)) {  //button up causes focusout
//         if (!(twin->Bits&WItemList) && !(twin->Bits&WNotVisible)) {  //button up causes focusout
//         if (twin->Bits&WItemList && (twin->Bits&WItemListOpen)) {  //button up causes focusout
//         if (!(twin->Bits&WItemList) && (twin->Bits&WItemListOpen)) {  //button up causes focusout
//         if (twin->Bits&WItemListOpen) {  //button up causes focusout
//fprintf(stderr,"focusout for %s\n",twin->name);
         tcontrol=GetFTControlWithTab(twin,twin->focus);
				// tcontrol=GetFTControlWithTab(PStatus.FocusWindow,PStatus.FocusWindow->focus);    
//           fprintf(stderr,"control with tab= FTControl=%s twin->focus=%d\n",tcontrol->name,twin->focus);
           //twin->focus=0;  //only to remove cursor
           if (tcontrol->type==CTTextBox || tcontrol->type==CTTextArea) {
             tcontrol->Bits|=CEraseCursor;
           if (tcontrol->LostFocus!=0) (*tcontrol->LostFocus) (twin,tcontrol);
         if (twin->LostFocus!=0) (*twin->LostFocus) (twin);
           fprintf(stderr,"no window, last with focus is %s\n",twin->name);
           //tcontrol=GetFTControlWithTab(twin,twin->focus);
           tcontrol=GetFTControlWithTab(twin,twin->focus);
				//set focus back to correct window - causes feedback loop hang - because XWindows needs to get focus
      tcontrol=GetFTControlWithTab(twin,twin->focus);
//				fprintf(stderr,"PStatus window with focus= %s\n",PStatus.FocusFTWindow->name);
           //tcontrol=GetFTControlWithTab(twin,twin->focus);
					if (twin!=0) fprintf(stderr,"in %s\n",twin->name);
//					twin->Bits&=~WWaitUntilDoneDrawing; //Window is done drawing now
					if (twin!=0) fprintf(stderr,"in %s\n",twin->name);
					if (twin!=0) fprintf(stderr,"in %s\n",twin->name);
					if (twin!=0) fprintf(stderr,"in %s\n",twin->name);
					if (twin!=0) fprintf(stderr,"in %s\n",twin->name);
       //result=XResizeWindow(PStatus.xdisplay,twin->xwindow,xevent.xresizerequest.width,xevent.xresizerequest.height);
					if (twin!=0) fprintf(stderr,"in %s\n",twin->name);
					if (twin!=0) fprintf(stderr,"in %s\n",twin->name);
//probably should add 32-bit aligned padding
bmf->bfType=0x4d42;
bmf->bfSize=bmpsize;
bmf->bfOffBits=sizeof(BITMAPFILEHEADER)+sizeof(BITMAPINFOHEADER);
bmi->biSize=sizeof(BITMAPINFOHEADER);
bmi->biWidth=w;
bmi->biHeight=h;
bmi->biPlanes=1;
bmi->biBitCount=bpp;
bmi->biSizeImage=Bytespp*w*h;
//for now just copy directly - ignore byte order
//FT_CreateBitmapHeader - Malloc memory, and initialize a bitmap header only, caller copies data into
bmf->bfType=0x4d42;
bmf->bfSize=bmpsize;
bmf->bfOffBits=sizeof(BITMAPFILEHEADER)+sizeof(BITMAPINFOHEADER);
bmi->biSize=sizeof(BITMAPINFOHEADER);
bmi->biWidth=w;
bmi->biHeight=h;
bmi->biPlanes=1;
bmi->biBitCount=bpp;
bmi->biSizeImage=Bytespp*w*h;
if (nw>0)  {nw=bmi.biWidth*bc+4-nw;}
if (nw>0)  {nw=bmi.biWidth*bc+4-nw;}
    offset=bdata+((int)((y-i-1)*ry))*nw+((int)(j*rx))*bc;
//Load a Bitmap and shade with mixcolor - for selected buttons
if (nw>0)  {nw=bmi.biWidth*bc+4-nw;}
    offset=bdata+((int)((y-i-1)*ry))*nw+((int)(j*rx))*bc;
  /* Make a one-row-high sample array that will go away when done with image */
  buffer = (*djpeg.mem->alloc_sarray)
    memcpy(bdata+(djpeg.output_scanline-1)*row_stride,buffer[0],row_stride);
  x=tcontrol->x2-tcontrol->x1;
  y=tcontrol->y2-tcontrol->y1;
if (tcontrol->bmpinfo!=0) free(tcontrol->bmpinfo);
tcontrol->bmpinfo=(BITMAPINFOHEADER *)malloc(sizeof(BITMAPINFOHEADER));
memcpy(tcontrol->bmpinfo,&bmi,sizeof(BITMAPINFOHEADER));
if (nw>0)  {nw=bmi.biWidth*bc+4-nw;}
if (nw2>0)  {nw2=jx*bc2+4-nw2;}
//    offset=bdata+((int)((y-i-1)*ry))*nw+((int)(j*rx))*bc;
//    offset=bdata+((int)((y-i-1)*ry))*jx*bc2+((int)(j*rx))*bc2;
       image itself.  Rather, it initializes the structure byte-order, bit-
       order, and bitmap-unit values from the display and returns a pointer to
//maybe make LoadBitmapToFTControlScale - Scale to FTControl
if (bmf->bfType!=0x4d42) {
//if (tcontrol->bmpinfo!=0) free(tcontrol->bmpinfo); //causes segfault?
tcontrol->bmpinfo=(BITMAPINFOHEADER *)malloc(sizeof(BITMAPINFOHEADER));
memcpy(tcontrol->bmpinfo,&bmi,sizeof(BITMAPINFOHEADER));
//fprintf(stderr,"bitcount=%d\n",bmi->biBitCount);
bc=bmi->biBitCount/8;
nw=(int)fmodf((float)bmi->biWidth*bc,4.0);
	nw=bmi->biWidth+4-nw;
  nw=bmi->biWidth;
//  nw=bmi->biWidth;//nw;
  y=bmi->biHeight;
//ry=(float)bmi->biHeight/(float)y;
offset=bdata;//-352*3-169*3;//  183*3;//549 off 183*3  352*3=1056 /2=528 -169*3=-507
    //offset=bdata+((int)((y-i-1)*ry))*nw+((int)(j*rx))*bc;
tcontrol->image=tximage;
//NOTE - this probably needs to be changed - see LoadBitmapToFTWindow for working version
if (tcontrol->bmpinfo!=0) free(tcontrol->bmpinfo);
tcontrol->bmpinfo=(BITMAPINFOHEADER *)malloc(sizeof(BITMAPINFOHEADER));
memcpy(tcontrol->bmpinfo,&bmi,sizeof(BITMAPINFOHEADER));
if (nw>0)  {nw=bmi.biWidth+4-nw;}
    offset=bdata+((int)((y-i-1)*ry))*nw+((int)(j*rx))*bc;
//fprintf(stdout,"bitmap %s file size= %d\n",name,bmf->bfSize);
//fprintf(stdout,"bitmap image size= %d\n",bmi->biSizeImage);
//have to write in little endian - fwrite does not know to use structures, such as the BITMAPFILEHEADER structure
//fprintf(stdout,"bmf->bfType=%x fptr=%x\n",bmf->bfType,fptr);
	fwrite(&bmf->bfType,1,2,fptr);
//fprintf(stdout,"bmf->bfType=%x\n",bmf->bfType);
	fwrite(&bmf->bfSize,1,4,fptr);
	fwrite(&bmf->bfReserved1,1,2,fptr);
	fwrite(&bmf->bfReserved2,1,2,fptr);
	fwrite(&bmf->bfOffBits,1,4,fptr);
//fprintf(stdout,"bmi->biSize=%x\n",bmi->biSize);
	fwrite(&bmi->biSize,1,4,fptr);
	fwrite(&bmi->biWidth,1,4,fptr);
	fwrite(&bmi->biHeight,1,4,fptr);
	fwrite(&bmi->biPlanes,1,2,fptr);
	fwrite(&bmi->biBitCount,1,2,fptr);
	fwrite(&bmi->biCompression,1,4,fptr);
	fwrite(&bmi->biSizeImage,1,4,fptr);
	fwrite(&bmi->biXPelsPerMeter,1,4,fptr);
	fwrite(&bmi->biYPelsPerMeter,1,4,fptr);
	fwrite(&bmi->biClrUsed,1,4,fptr);
	fwrite(&bmi->biClrImportant,1,4,fptr);
	//fwrite(bmd,bmi->biSizeImage,1,fptr);
bpp=bmi->biBitCount/8;
h=bmi->biHeight;
linelen=bmi->biWidth*bpp;
	fwrite(bmd+(h-i-1)*linelen,linelen,1,fptr);
if (bmf->bfType!=0x4d42) {
//if (twin->bmpinfo!=0) free(twin->bmpinfo);
//bmpinfo should probably be static - not pointer
if (twin->bmpinfo==0) {  //don't bother to free+malloc again if memory is already malloc'd
	twin->bmpinfo=(BITMAPINFOHEADER *)malloc(sizeof(BITMAPINFOHEADER));
memcpy(twin->bmpinfo,&bmi,sizeof(BITMAPINFOHEADER));
//fprintf(stderr,"w=%d h=%d\n",bmi->biWidth,bmi->biHeight);
//fprintf(stderr,"bitcount=%d\n",bmi->biBitCount);
bc=bmi->biBitCount/8;
nw=(int)fmodf((float)bmi->biWidth*bc,4.0);
	nw=bmi->biWidth+4-nw;
  nw=bmi->biWidth;
	if (twin->w!=bmi->biWidth || twin->h!=bmi->biHeight) {
	  twin->w=bmi->biWidth;
  	twin->h=bmi->biHeight;
		if (twin->Bits&WOpen && twin->xwindow!=0) {
//if this is a new window - set the dimensions to the bitmap dimensions
if (twin->w==0 || twin->h==0) {
  twin->w=bmi->biWidth;
  twin->h=bmi->biHeight;
//twin at 32 bpp should always be 4-byte aligned - but could be a problem on other display resolutions
x=twin->w;
y=twin->h;
	//rx=(float)nw/((float)twin->x*(float)bc);
	rx=((float)nw-1.0)/(float)x;
	ry=((float)bmi->biHeight-1.0)/(float)y;
if (twin->bmpdata!=0) {
//	free(twin->bmpdata); //free any previous mallc'd bitmap data
twin->bmpdata=bdata2; //store in order to track to free
//if (twin->image!=0) {
//	XDestroyImage(twin->image);  //causes segfault
twin->image=tximage;
//can free bdata and bdata2 - does XCreateImage do its own malloc?
//LoadBitmapDataToFTWindow() - Loads Bitmap data to window (expects bmfile to have no header info as LoadBitmapToFTWindow does).
//fprintf(stderr,"w=%d h=%d\n",bmi->biWidth,bmi->biHeight);
//fprintf(stderr,"bitcount=%d\n",bmi->biBitCount);
	nw=width+4-nw;
	if (twin->w!=width || twin->h!=height) {
	  twin->w=width;
  	twin->h=height;
		if (twin->Bits&WOpen && twin->xwindow!=0) {
//if this is a new window - set the dimensions to the bitmap dimensions
if (twin->w==0 || twin->h==0) {
  twin->w=width;
  twin->h=height;
//twin at 32 bpp should always be 4-byte aligned - but could be a problem on other display resolutions
x=twin->w;
y=twin->h;
	//rx=(float)nw/((float)twin->x*(float)bc);
	rx=((float)nw-1.0)/(float)x;
	ry=((float)height-1.0)/(float)y;
if (twin->bmpdata!=0) {
//	free(twin->bmpdata); //free any previous mallc'd bitmap data
twin->bmpdata=bdata2; //store in order to track to free
//if (twin->image!=0) {
//	XDestroyImage(twin->image);  //causes segfault
twin->image=tximage;
//can free bdata and bdata2 - does XCreateImage do its own malloc?
//NOTE THIS CODE IS INACCURATE - remove rx,ry - fix nw and loop
if (twin->bmpinfo!=0) free(twin->bmpinfo);
twin->bmpinfo=(BITMAPINFOHEADER *)malloc(sizeof(BITMAPINFOHEADER));
memcpy(twin->bmpinfo,&bmi,sizeof(BITMAPINFOHEADER));
if (nw>0)  {nw=bmi.biWidth+4-nw;}
if (nw>0)  {nw=bmi.biWidth*bc+4-nw;}
//if this is a new window - set the dimensions to the bitmap dimensions
if (twin->w==0 || twin->h==0) {
  twin->w=bmi.biWidth;
  twin->h=bmi.biHeight;
x=twin->w;
y=twin->h;
//for(i=y-1;i>-1;i--) {
	//for(j=x-1;j>-1;j--) {
//    offset=bdata+((int)((y-i-1)*ry))*nw+((int)(j*rx))*bc;
//		offset=bdata+((int)((y-i-1)*ry))*nw+((int)(j*rx));//*bc;
		offset=bdata+((int)((float)(y-i-1)*ry))*nw*bc+(((int)((float)j*rx))*bc);//*bc;
//NOTE: Convert all JPG encoding/decoding to FFMPEG Libraries - remove direct libjpeg requirement
//JSAMPLE * image_buffer;	/* Points to large array of R,G,B-order data */
  /* Make a one-row-high sample array that will go away when done with image */
  buffer = (*djpeg.mem->alloc_sarray)
    memcpy(bdata+(djpeg.output_scanline-1)*row_stride,buffer[0],row_stride);
//if (twin->bmpinfo!=0) free(twin->bmpinfo);
//twin->bmpinfo=(BITMAPINFOHEADER *)malloc(sizeof(BITMAPINFOHEADER));
//memcpy(twin->bmpinfo,&bmi,sizeof(BITMAPINFOHEADER));
       image itself.  Rather, it initializes the structure byte-order, bit-
       order, and bitmap-unit values from the display and returns a pointer to
//JSAMPLE * image_buffer;	/* Points to large array of R,G,B-order data */
  /* Make a one-row-high sample array that will go away when done with image */
  buffer = (*djpeg.mem->alloc_sarray)
    memcpy(bdata+(djpeg.output_scanline-1)*row_stride,buffer[0],row_stride);
//if this is a new window - set the dimensions to the bitmap dimensions
if (twin->w==0 || twin->h==0) {
  twin->w=bmi.biWidth;
  twin->h=bmi.biHeight;
if (twin->bmpinfo!=0) free(twin->bmpinfo);
twin->bmpinfo=(BITMAPINFOHEADER *)malloc(sizeof(BITMAPINFOHEADER));
memcpy(twin->bmpinfo,&bmi,sizeof(BITMAPINFOHEADER));
       image itself.  Rather, it initializes the structure byte-order, bit-
       order, and bitmap-unit values from the display and returns a pointer to
//JSAMPLE * image_buffer;	// Points to large array of R,G,B-order data 
  // Make a one-row-high sample array that will go away when done with image 
  buffer = (*djpeg.mem->alloc_sarray)
    memcpy(bdata+(djpeg.output_scanline-1)*row_stride,buffer[0],row_stride);
//if this is a new window - set the dimensions to the bitmap dimensions
if (twin->w==0 || twin->h==0) {
  twin->w=bmi.biWidth;
  twin->h=bmi.biHeight;
if (twin->bmpinfo!=0) free(twin->bmpinfo);
twin->bmpinfo=(BITMAPINFOHEADER *)malloc(sizeof(BITMAPINFOHEADER));
memcpy(twin->bmpinfo,&bmi,sizeof(BITMAPINFOHEADER));
//       image itself.  Rather, it initializes the structure byte-order, bit-
//       order, and bitmap-unit values from the display and returns a pointer to
		if (!(twin->Bits&WAVCodec_Init)) {
				//twin->w=;
		//twin->jpgdata=jpg;
//initialize AVCodec part of FFMPEG - using the MJPEG encoder and decoder
//twin->avc = avcodec_find_encoder(CODEC_ID_MJPEG);
twin->avc = avcodec_find_decoder(CODEC_ID_MJPEG);
if (!twin->avc) {
twin->avcc=avcodec_alloc_context();
twin->mjpeg_bmp= avcodec_alloc_frame();  //this does malloc
twin->mjpeg_yuv= avcodec_alloc_frame();
* - encoding: Set by libavcodec. for coded_picture (and set by user for input).\
* - decoding: Set by libavcodec.\
twin->mjpeg_bmp->quality=1; 
twin->mjpeg_yuv->quality=1;
width=twin->w;
height=twin->h;
twin->avcc->bit_rate = 20000000;//1000000;//8000000;//4000000;//2400000;//1200000;
twin->avcc->width = width;
twin->avcc->height = height;
twin->avcc->time_base= (AVRational){1,30}; //{1,25};
twin->avcc->pix_fmt = PIX_FMT_YUVJ422P;  //this is correct format for some digital cameras
if (avcodec_open(twin->avcc,twin->avc) < 0) {
	twin->Bits|=WAVCodec_Init;
twin->mjpeg_frame_size = width*height*(depth/8); //allocate full uncompressed image size
twin->mjpeg_frame = malloc(twin->mjpeg_frame_size);
twin->swsctx = sws_getContext(
if (twin->swsctx == 0) {
twin->mjpeg_yuv->data[0] = malloc(2*width*height); //
twin->mjpeg_yuv->data[1]=twin->mjpeg_yuv->data[0]+width*height; //not /2
twin->mjpeg_yuv->data[2]=twin->mjpeg_yuv->data[1]+width*height/2;
twin->mjpeg_yuv->linesize[0]=width;
twin->mjpeg_yuv->linesize[1]=width/2;
twin->mjpeg_yuv->linesize[2]=width/2;
twin->mjpeg_bmp->data[0]=(uint8_t *)(twin->bmpdata);  //set bitmap data to AVFrame
twin->mjpeg_bmp->data[1]=0;
twin->mjpeg_bmp->data[2]=0;
twin->mjpeg_bmp->linesize[0] = width*3;//c->width;
twin->mjpeg_bmp->linesize[1] = 0;
twin->mjpeg_bmp->linesize[2] = 0;
	sws_scale(twin->swsctx,twin->mjpeg_bmp->data,twin->mjpeg_bmp->linesize,0,twin->h,twin->mjpeg_yuv->data,twin->mjpeg_yuv->linesize);
	len = avcodec_encode_video(twin->avcc,twin->mjpeg_frame,twin->mjpeg_frame_size,twin->mjpeg_yuv);
//bmp is malloc'd in this function - otherwise jpg dimensions need to be passed
AVCodec *avc;  //format to save video calls - currently set to MJPEG
//if(avc->capabilities&CODEC_CAP_TRUNCATED)
//	avcc->flags|= CODEC_FLAG_TRUNCATED; /* we dont send complete frames */
* - encoding: Set by libavcodec. for coded_picture (and set by user for input).\
* - decoding: Set by libavcodec.\
mjpeg_bmp->quality=1; 
mjpeg_yuv->quality=1;
//avcc->bit_rate = 20000000;//1000000;//8000000;//4000000;//2400000;//1200000;
//avcc->width = width;
//avcc->height = height;
//avcc->width = 320;//352;//320;//352;//640;//3000;//640;//352;//320;//640;//352;//320;//width;
//avcc->height = 240;//288;//240;//288;//480;//2000;//480;//288;//240;//480;//288;//240;//height;
//avcc->time_base= (AVRational){1,30}; //{1,25};
//icam.avcc->pix_fmt = PIX_FMT_NONE;
//avcc->pix_fmt = PIX_FMT_YUVJ422P;  //this is correct format for some digital cameras
//avcc->pix_fmt = PIX_FMT_YUV422P;  //possibly this is more common or generic
avcc->pix_fmt = PIX_FMT_YUV422P;  //possibly this is more common or generic
//icam.avcc->pix_fmt = PIX_FMT_YUV422P;  //this is correct format for some digital cameras
//icam.avcc->pix_fmt = PIX_FMT_YU4422P;  //this is correct format for some digital cameras
//   fprintf(stderr,"before avcc->width=%d height=%d\n",avcc->width,avcc->height);
//decode_video2 adjusts avcc width and height - but it is better to know before what dimensions are
//	if (mjpeg_yuv->pan_scan!=0) {
//		fprintf(stderr,"mjpeg_yuv->pan_scan->height=%d\n",mjpeg_yuv->pan_scan->height);
//	fprintf(stderr," linesize[0]=%d\n",mjpeg_yuv->linesize[0]);
	  //printf("lossless=%d\n",mjpeg->ls);
//   fprintf(stderr,"after avcc->width=%d height=%d\n",avcc->width,avcc->height);
//	  fprintf(stderr,"mjpeg_yuv->linesize[0]=%d\n",mjpeg_yuv->linesize[0]);
//    fprintf(stderr, "(avcod)c->pix_fmt=%x=%x(PIX_FMT_YUVJ422P)\n",c->pix_fmt,PIX_FMT_YUVJ422P);
	   //fprintf(stderr,"c->width %d c->height %d\n",c->width,c->height);
				avcc->width,  //source
				avcc->height,
				avcc->width,  //dest
				avcc->height,//c->height,
				PIX_FMT_BGR24,////PIX_FMT_BGR24,  //dest format  - I thought I am using RGB
				avcc->width,  //source
				avcc->height,
				avcc->width,  //dest
				avcc->height,//c->height,
				PIX_FMT_RGB32,////PIX_FMT_BGR24,  //dest format  - I thought I am using RGB
bmpsize=sizeof(BITMAPFILEHEADER)+sizeof(BITMAPINFOHEADER)+(PStatus.depth/8)*avcc->width*avcc->height;
//uint8_t *dest[3]= {data, data+c->width*c->height, data+c->width*c->height*2};
sws_dest[1]=0;//sws_data+c->width*c->height;
sws_dest[2]=0;//sws_data+c->width*c->height*2;
//int stride[3]={c->width*3,0,0};  //put data in one channel w*3
sws_stride[0]=avcc->width*(PStatus.depth/8);
//printf("important: picture->data[0]=%x ls[0]=%d d[1]=%x l[1]=%d d[2]=%x l[2]=%d\n",picture->data[0],picture->linesize[0],picture->data[1],picture->linesize[1],picture->data[2],picture->linesize[2]);
//fprintf(stderr,"&dst->data=%x =%x\n",&dst->data,dst->data);
//sws_scale( ctx, src->data, src->stride,0, src->height,dst->data, dst->stride );
//	sws_scale(swsctx,mjpeg_yuv->data,mjpeg_yuv->linesize,0,avcc->height,sws_dest,sws_stride);
	sws_scale(swsctx,mjpeg_yuv->data,mjpeg_yuv->linesize,0,avcc->height,sws_dest,sws_stride);
//this is just data - needs header info to
bmf->bfType=0x4d42;
bmf->bfSize=bmpsize;
bmf->bfOffBits=sizeof(BITMAPFILEHEADER)+sizeof(BITMAPINFOHEADER);
bmi->biSize=sizeof(BITMAPINFOHEADER);
bmi->biWidth=avcc->width;
bmi->biHeight=avcc->height;
bmi->biPlanes=1;
bmi->biBitCount=PStatus.depth;
bmi->biSizeImage=(PStatus.depth/8)*avcc->width*avcc->height;
	if (mjpeg_yuv->data[0]!=0) {
		free(mjpeg_yuv->data[0]);
//bmp is not malloc'd in this function - so bmp needs to contain enough allocated memory
AVCodec *avc;  //format to save video calls - currently set to MJPEG
//if(avc->capabilities&CODEC_CAP_TRUNCATED)
//	avcc->flags|= CODEC_FLAG_TRUNCATED; /* we dont send complete frames */
* - encoding: Set by libavcodec. for coded_picture (and set by user for input).\
* - decoding: Set by libavcodec.\
mjpeg_bmp->quality=1; 
mjpeg_yuv->quality=1;
//avcc->bit_rate = 20000000;//1000000;//8000000;//4000000;//2400000;//1200000;
avcc->width = w;
avcc->height = h;
//avcc->width = 320;//352;//320;//352;//640;//3000;//640;//352;//320;//640;//352;//320;//width;
//avcc->height = 240;//288;//240;//288;//480;//2000;//480;//288;//240;//480;//288;//240;//height;
//avcc->time_base= (AVRational){1,30}; //{1,25};
//icam.avcc->pix_fmt = PIX_FMT_NONE;
avcc->pix_fmt = PIX_FMT_YUVJ422P;  //this is correct format for some digital cameras
//avcc->pix_fmt = PIX_FMT_YUV422P;  //possibly this is more common or generic
//avcc->pix_fmt = PIX_FMT_YUV422P;  //possibly this is more common or generic
//icam.avcc->pix_fmt = PIX_FMT_YUV422P;  //this is correct format for some digital cameras
//icam.avcc->pix_fmt = PIX_FMT_YU4422P;  //this is correct format for some digital cameras
//   fprintf(stderr,"before avcc->width=%d height=%d\n",avcc->width,avcc->height);
//decode_video2 adjusts avcc width and height - but it is better to know before what dimensions are
//	if (mjpeg_yuv->pan_scan!=0) {
//		fprintf(stderr,"mjpeg_yuv->pan_scan->height=%d\n",mjpeg_yuv->pan_scan->height);
//	fprintf(stderr," linesize[0]=%d\n",mjpeg_yuv->linesize[0]);
	  //printf("lossless=%d\n",mjpeg->ls);
//   fprintf(stderr,"after avcc->width=%d height=%d\n",avcc->width,avcc->height);
//	  fprintf(stderr,"mjpeg_yuv->linesize[0]=%d\n",mjpeg_yuv->linesize[0]);
//    fprintf(stderr, "(avcod)c->pix_fmt=%x=%x(PIX_FMT_YUVJ422P)\n",c->pix_fmt,PIX_FMT_YUVJ422P);
	   //fprintf(stderr,"c->width %d c->height %d\n",c->width,c->height);
				h,//c->height,
				PIX_FMT_BGR24,////PIX_FMT_BGR24,  //dest format  - I thought I am using RGB
				h,//c->height,
				PIX_FMT_BGR32,////PIX_FMT_BGR24,  //dest format  - I thought I am using RGB
//bmpsize=sizeof(BITMAPFILEHEADER)+sizeof(BITMAPINFOHEADER)+(PStatus.depth/8)*avcc->width*avcc->height;
//uint8_t *dest[3]= {data, data+c->width*c->height, data+c->width*c->height*2};
sws_dest[1]=0;//sws_data+c->width*c->height;
sws_dest[2]=0;//sws_data+c->width*c->height*2;
//int stride[3]={c->width*3,0,0};  //put data in one channel w*3
//printf("important: picture->data[0]=%x ls[0]=%d d[1]=%x l[1]=%d d[2]=%x l[2]=%d\n",picture->data[0],picture->linesize[0],picture->data[1],picture->linesize[1],picture->data[2],picture->linesize[2]);
//fprintf(stderr,"&dst->data=%x =%x\n",&dst->data,dst->data);
//sws_scale( ctx, src->data, src->stride,0, src->height,dst->data, dst->stride );
//	sws_scale(swsctx,mjpeg_yuv->data,mjpeg_yuv->linesize,0,avcc->height,sws_dest,sws_stride);
	sws_scale(swsctx,mjpeg_yuv->data,mjpeg_yuv->linesize,0,h,sws_dest,sws_stride);
//this is just data - needs header info to
bmf->bfType=0x4d42;
bmf->bfSize=bmpsize;
bmf->bfOffBits=sizeof(BITMAPFILEHEADER)+sizeof(BITMAPINFOHEADER);
bmi->biSize=sizeof(BITMAPINFOHEADER);
bmi->biWidth=avcc->width;
bmi->biHeight=avcc->height;
bmi->biPlanes=1;
bmi->biBitCount=PStatus.depth;
bmi->biSizeImage=(PStatus.depth/8)*avcc->width*avcc->height;
	if (mjpeg_yuv->data[0]!=0) {
		free(mjpeg_yuv->data[0]);
AVCodec *avc;  //format to save video calls - currently set to MJPEG
width=bmi->biWidth;
height=bmi->biHeight;
depth=bmi->biBitCount;
* - encoding: Set by libavcodec. for coded_picture (and set by user for input).\
* - decoding: Set by libavcodec.\
mjpeg_bmp->quality=1; 
mjpeg_yuv->quality=1;
avcc->bit_rate = 20000000;//1000000;//8000000;//4000000;//2400000;//1200000;
avcc->width = width;
avcc->height = height;
avcc->time_base= (AVRational){1,30}; //{1,25};
//c->gop_size = 10; /* emit one intra frame every ten frames */
//c->max_b_frames=1;
//c->pix_fmt = PIX_FMT_YUV420P;
//    c->pix_fmt = PIX_FMT_YUVJ440P;
//    c->pix_fmt = PIX_FMT_YUVJ444P;
avcc->pix_fmt = PIX_FMT_YUVJ422P;  //this is correct format for some digital cameras
//avcc->pix_fmt = PIX_FMT_YUV422P;  //possibly this is more common?
mjpeg_yuv->data[0] = malloc(2*width*height);
mjpeg_yuv->data[1]=mjpeg_yuv->data[0]+width*height;
mjpeg_yuv->data[2]=mjpeg_yuv->data[1]+width*height/2;
mjpeg_yuv->linesize[0]=width;
mjpeg_yuv->linesize[1]=width/2;
mjpeg_yuv->linesize[2]=width/2;
mjpeg_bmp->data[0]=(uint8_t *)(bmpdata);  //set bitmap data to AVFrame
mjpeg_bmp->data[1]=0;
mjpeg_bmp->data[2]=0;
mjpeg_bmp->linesize[0] = width*3;//c->width;
mjpeg_bmp->linesize[1] = 0;
mjpeg_bmp->linesize[2] = 0;
	sws_scale(swsctx,mjpeg_bmp->data,mjpeg_bmp->linesize,0,height,mjpeg_yuv->data,mjpeg_yuv->linesize);
	if (mjpeg_yuv->data[0]!=0) {
		free(mjpeg_yuv->data[0]);
fprintf(stderr,"\nstart GetFTControlBackground %p %s.\n",tcontrol,tcontrol->name);
twin=tcontrol->window;
//  bw=tcontrol->x2-tcontrol->x1;
//  bh=tcontrol->y2-tcontrol->y1;
  bw=tcontrol->cx2-tcontrol->cx1;
  bh=tcontrol->cy2-tcontrol->cy1;
  if (tcontrol->erase!=0) {
    fprintf(stderr,"XDestroyImage tcontrol->erase=%p\n",tcontrol->erase);
    XDestroyImage(tcontrol->erase);
    tcontrol->erase=0;
    fprintf(stderr,"after XDestroyImage tcontrol->erase=%p\n",tcontrol->erase);
//    if (tcontrol->x1<0 || tcontrol->y1<0 || (tcontrol->x1+bw)>(twin->x1+twin->w) || (tcontrol->y1+bh)>(twin->y1+twin->h)) {
//    if (tcontrol->x1<0 || tcontrol->y1<0 || (tcontrol->x1+bw)>twin->w || (tcontrol->y1+bh)>twin->h) {
    if (tcontrol->cx1<0 || tcontrol->cy1<0 || (tcontrol->cx1+bw)>twin->w || (tcontrol->cy1+bh)>twin->h) {
//      fprintf(stderr,"Pstatus.xdisplay=%p twin->xwin=%p\n",PStatus.xdisplay,(u32 *)twin->xwindow);
      fprintf(stderr,"before getimage for tcontrol->erase=%p\n",tcontrol->erase);
      fprintf(stderr,"cx1=%d cy1=%d bw=%d bh=%d\n",tcontrol->cx1,tcontrol->cy1,bw,bh);
//      tcontrol->erase=XGetImage(PStatus.xdisplay,twin->xwindow,tcontrol->x1,tcontrol->y1,bw,bh,AllPlanes,ZPixmap);
      tcontrol->erase=XGetImage(PStatus.xdisplay,twin->xwindow,tcontrol->cx1,tcontrol->cy1,bw,bh,AllPlanes,ZPixmap);
      fprintf(stderr,"after getimage for tcontrol->erase=%p\n",tcontrol->erase);
		fprintf(stderr,"\nStart EraseFTControl %s\n",tcontrol->name);
//  bw=tcontrol->x2-tcontrol->x1;
//  bh=tcontrol->y2-tcontrol->y1;
  bw=tcontrol->cx2-tcontrol->cx1;
  bh=tcontrol->cy2-tcontrol->cy1;
//  fprintf(stderr,"ctl x1=%d y1=%d bw=%d bh=%d\n",tcontrol->x1,tcontrol->y1,bw,bh);
//  fprintf(stderr,"win x1=%d y1=%d bw=%d bh=%d\n",twin->x1,twin->y1,twin->w,twin->h);
    if (tcontrol->erase!=0) {
			twin=tcontrol->window;
      fprintf(stderr,"XPutImage %p cx=%d cy=%d w=%d h=%d\n",tcontrol->erase,tcontrol->cx1,tcontrol->cy1,bw,bh);
      XPutImage(PStatus.xdisplay,twin->xwindow,twin->xgc,tcontrol->erase,0,0,tcontrol->cx1,tcontrol->cy1,bw,bh);
    //XDestroyImage(tcontrol->erase);
//fprintf(stderr,"End EraseFTControl %s\n\n",tcontrol->name);
//DrawFTControls(-1,tcontrol);
//I need to add clipping, z clipping too - either higher controls need to be redrawn, or parts of lower controls need to be not drawn.
	  fprintf(stderr,"Start DrawFTControls window=%p tcontrol=%s\n",twin,tcontrol->name);
	 	fprintf(stderr,"Start DrawFTControls window=%s\n",twin->name);
//  fprintf(stderr,"tcontrol->next=%p\n",tcontrol->next);
//fprintf(stderr,"DrawFTControls win=%d name=%s\n",win,tcontrol->name);
  tcontrol=twin->icontrol;
//  twin=GetFTWindowN(tcontrol->win);
  twin=tcontrol->window;
		fprintf(stderr,"Error: Control '%s' has no associated window\n",tcontrol->name);
			fprintf(stderr,"In window %s\n",twin->name);
//  win=tcontrol->win;
//if (twin->Bits&WNotVisible || twin->xwindow==0) {
if (!(twin->Bits&WOpen) || twin->xwindow==0) {
strcpy(winname,twin->name);
//fprintf(stderr,"control name=%s\n",tcontrol->name);
//fprintf(stderr,"twin->xwindow=%p &root_win=%p\n",twin->xwindow,&root_win);
//XGetGeometry causes malloc crashes - assign 0 to variables to see if this helps
XGetGeometry(PStatus.xdisplay,twin->xwindow,&root_win,&xr,&yr,&wr,&hr,&bwr,&dr);
//XGetGeometry(PStatus.xdisplay,twin->xwindow,&root_win,x_return,y_return,width_return,height_return,border_width_return,depth_return);
//if (twin->Bits&WResize) { //may be used unitialized warning if not
//  scalex=(float)twin->w/(float)twin->ow;
//  scaley=(float)twin->h/(float)twin->oh;
//fprintf(stderr,"0 twin x=%d ,y=%d\n",twin->w,twin->h);
strcpy(conname,tcontrol->name);
//fprintf(stderr,"name=%s\n",tcontrol->name);
if (!(tcontrol->Bits&CNotVisible))  //FTControl is visible
//get background for ->Bits&CErase
if (tcontrol->erase==0 && tcontrol->Bits&(CErase|CMove)) { 
//if (tcontrol->Bits&CMove) { EraseFTControl(twin,tcontrol); }
  //one time - only draw 1 FTControl
  //fprintf(stderr,"single FTControl %s in win %d\n",tcontrol->name,win);
  win=tcontrol->win;
//fprintf(stderr,"name=%s\n",tcontrol->name);
//fprintf(stderr,"name=%p\n",tcontrol->name);
//if ((tcontrol->name==0&&track==0) || (tname>0 && strcmp(tcontrol->name,name)==0) || (track>0 && tcontrol->track==track))
//if ((tcontrol->name==0&&track==0) || (track>0 && tcontrol->track==track))
//fprintf(stderr,"FTControl %s in win %d\n",tcontrol->name,win);
//fprintf(stderr,"%d: FTControl name %s, next %p\n",a,tcontrol->name,tcontrol->next);
//if (tcontrol->name!=0 && tcontrol->track>0) 
//    ClearTracks(tcontrol->track);  //may not be a data FTControl being drawn
if (tcontrol->win==win && (tcontrol->Bits&CGrowX1 ||tcontrol->Bits&CGrowY1 ||tcontrol->Bits&CGrowX2 ||tcontrol->Bits&CGrowY2 ||tcontrol->Bits&CGrowX3 ||tcontrol->Bits&CGrowY3))
//  XGetGeometry(PStatus.xdisplay,twin->xwindow,root_win,x_return,y_return,width_return,height_return,border_width_return,depth_return);
  if (tcontrol->Bits&CGrowX1)
      //tcontrol->x1=*(width_return)+tcontrol->gx1;
      tcontrol->x1=wr+tcontrol->gx1;
  if (tcontrol->Bits&CGrowY1)
//      tcontrol->y1=*(height_return)+tcontrol->gy1;
      tcontrol->y1=hr+tcontrol->gy1;
  if (tcontrol->Bits&CGrowX2)
//      tcontrol->x2=*(width_return)+tcontrol->gx2;
      tcontrol->x2=wr+tcontrol->gx2;
  if (tcontrol->Bits&CGrowY2)
//      tcontrol->y2=*(height_return)+tcontrol->gy2;
      tcontrol->y2=hr+tcontrol->gy2;
    if (tcontrol->Bits&CGrowX3)
//      tcontrol->x3=*(width_return)+tcontrol->gx3;
      tcontrol->x3=wr+tcontrol->gx3;
    if (tcontrol->Bits&CGrowY3)
//      tcontrol->y3=*(height_return)+tcontrol->gy3;
      tcontrol->y3=hr+tcontrol->gy3;
//    if (check==1 &&tcontrol->type&CTFileOpen) {
//      if (tcontrol->ilist!=0) tcontrol->ilist->Bits|=FTIL_REREAD;
//if (tcontrol->win==win)
//This control is in this window - need?
if (tcontrol->window==twin)  {
  //if (tcontrol->tab==0)  //this FTControl has initial focus
 //   twin->focus=tcontrol->num;  //not sure FTControls have a number
	//Clip control to window (is done by X-windows anyway)
	x1=tcontrol->x1;
	x2=tcontrol->x2;
	y1=tcontrol->y1;
	y2=tcontrol->y2;
	tcontrol->cx1=x1;
  tcontrol->cy1=y1;
  tcontrol->cx2=x2;
	tcontrol->cy2=y2;
//	if (tcontrol->type==CTData) {  //use 64-bit control dimension values (lx1,ly1,lx2,ly2)
//		lx1=tcontrol->lx1;
//		lx2=tcontrol->lx2;
//		ly1=tcontrol->ly1;
//		ly2=tcontrol->ly2;
	if (tcontrol->x2<twin->x || tcontrol->y2<twin->y || tcontrol->x1>twin->x+twin->w || tcontrol->y1>twin->y+twin->h) {
	if (tcontrol->x1<twin->x) {
		x1=twin->x;
		tcontrol->cx1=x1;
		x1=tcontrol->x1;
	if (tcontrol->x1>twin->x+twin->w) {
		x2=twin->x+twin->w;
		tcontrol->cx2=x2;
		x2=tcontrol->x2;
	if (tcontrol->y1<twin->y) {
		y1=twin->y;
		tcontrol->cy1=y1;
		y1=tcontrol->y1;
	if (tcontrol->y2>twin->y+twin->h) {
		y2=twin->y+twin->h;
		tcontrol->cy2=y2;
		y2=tcontrol->y2;
//		fprintf(stderr,"is clipped Control %s?\n",tcontrol->name);
	if (tcontrol->FrameFTControl!=0) {
		//fprintf(stderr,"Control %s belongs to a frame\n",tcontrol->name);
		tFrame=tcontrol->FrameFTControl;
		if (tcontrol->type==CTData) {  //use 64-bit control dimension values (lx1,ly1,lx2,ly2)
			lx1=tcontrol->lx1;
			lx2=tcontrol->lx2;
			ly1=tcontrol->ly1;
			ly2=tcontrol->ly2;
			if (lx1>(i64)tFrame->x2 || lx2<(i64)tFrame->x1 || ly1>(i64)tFrame->y2 || ly2<(i64)tFrame->y1) {
				//fprintf(stderr,"lx1=%lli >%lli lx2=%lli < %lli\n",lx1,(i64)tFrame->x2,lx2,(i64)tFrame->x1);
			} //lx1>tFrame->x2
			if (lx1<(i64)tFrame->x1) {
				x1=tFrame->x1; //clip x1 to frame
				tcontrol->cx1=x1;
			if (lx2>(i64)tFrame->x2) {
				x2=tFrame->x2; //clip x2 to frame
				tcontrol->cx2=x2;
			if (ly1<(i64)tFrame->y1) {
				y1=tFrame->y1; //clip y1 to frame
				tcontrol->cy1=y1;
			if (ly2>(i64)tFrame->y2) {
				y2=tFrame->y2; //clip y2 to frame
				tcontrol->cy2=y2;
		} else { //use 32-bit control dimension values (x1,y1,x2,y2)
			if (x1>tFrame->x2 || x2<tFrame->x1 || y1>tFrame->y2 || y2<tFrame->y1) {
			} //x1>tFrame->x2
			if (x1<tFrame->x1) {
				x1=tFrame->x1; //clip x1 to frame
				tcontrol->cx1=x1;
			if (x2>tFrame->x2) {
				x2=tFrame->x2; //clip x2 to frame
				tcontrol->cx2=x2;
			if (y1<tFrame->y1) {
				y1=tFrame->y1; //clip y1 to frame
				tcontrol->cy1=y1;
			if (y2>tFrame->y2) {
				y2=tFrame->y2; //clip y2 to frame
				tcontrol->cy2=y2;
//  bw=tcontrol->x2-tcontrol->x1+1; //+1 because both points x1 and x2 are drawn
//  bh=tcontrol->y2-tcontrol->y1+1;
  bw=x2-x1+1; //+1 because both points x1 and x2 are drawn
  bh=y2-y1+1;
	//clip control to window - why not use twin->x,y and w,h? they must not be changed when window size changes
  if (tcontrol->x2>maxx) //+1?
    bw=maxx-tcontrol->x1;
  if (tcontrol->y2>maxy)
    bh=maxy-tcontrol->y1;
//	if (tcontrol->
  if (tcontrol->font==0) {
		if (tcontrol->type!=CTTimer) {
    	fprintf(stderr,"FTControl with name %s has no font. Each FTControl (except a timer) needs to have a font. Assigning font *ISO8859*.\n",tcontrol->name);
			tcontrol->font=XLoadQueryFont(PStatus.xdisplay,"*ISO8859*");
			if (tcontrol->font==0) {
				XSetFont(PStatus.xdisplay,twin->xgc,tcontrol->font->fid);
				fw=tcontrol->font->max_bounds.width;
				fh=tcontrol->font->max_bounds.ascent+tcontrol->font->max_bounds.descent;
    XSetFont(PStatus.xdisplay,twin->xgc,tcontrol->font->fid);
	  fw=tcontrol->font->max_bounds.width;
		fh=tcontrol->font->max_bounds.ascent+tcontrol->font->max_bounds.descent;
//  fprintf(stderr,"font width=%d\n",tcontrol->font->max_bounds.width);
  switch (tcontrol->type)
//      fprintf(stderr,"Before FTControl %s is a button\n",tcontrol->name);
//			if (!(tcontrol->Bits&CNotVisible)) {
		//fw=tcontrol->font->max_bounds.width;
		//fh=tcontrol->font->max_bounds.ascent+tcontrol->font->max_bounds.descent;
//      fprintf(stderr,"FTControl %s is a button\n",tcontrol->name);
//    fprintf(stderr,"FTControl %s %d\n",tcontrol->name,tcontrol->x2);
//    if (tcontrol->data==0)
//      if (!(tcontrol->Bits&CStartTime))
//        if (!(twin->Bits&WItemListOpen)) { 
//draw a border around the button if the button has the tab (twin->focus==tcontrol->tab)
if (twin->focus==tcontrol->tab) {
		fprintf(stderr,"%s has tab focus\n",tcontrol->name);
        	if (((tcontrol->Bits&CToggle) && tcontrol->value && !(tcontrol->Bits&CNoColorChangeButton(0)))|| tcontrol->Bits&CButtonDown(0))  //is a toggle button
              XSetForeground(PStatus.xdisplay, twin->xgc, tcontrol->color[1]);
  //            XSetForeground(PStatus.xdisplay, twin->xgc, tcontrol->color[0]);
            XSetForeground(PStatus.xdisplay,twin->xgc,tcontrol->color[0]); //normal
//            if (PStatus.MouseX>tcontrol->x1 && PStatus.MouseX<tcontrol->x2 && PStatus.MouseY>tcontrol->y1 && PStatus.MouseY<tcontrol->y2) {  //mouse is over FTControl
            if (!(tcontrol->Bits&CNoColorChangeMouse) && (tcontrol->Bits&CMouseOver || twin->focus==tcontrol->tab)) {  //mouse is over FTControl or button has tab focus
              XSetForeground(PStatus.xdisplay, twin->xgc,tcontrol->color[2]);
	            if (!(tcontrol->Bits&CNoColorChangeButton(0)) && tcontrol->Bits&CButtonDown(0)) { //button is down
	              XSetForeground(PStatus.xdisplay,twin->xgc,tcontrol->color[1]);
  	          }  //if button is down (and mouse is over - only way can be)
//          XSetForeground (PStatus.xdisplay, twin->xgc, tcontrol->color[0]);
        XFillRectangle(PStatus.xdisplay,twin->xwindow,twin->xgc,x1,y1,bw-1,bh-1);
        if (!(tcontrol->Bits&C2D)) {
          XSetForeground(PStatus.xdisplay,twin->xgc,white);
          XDrawLine(PStatus.xdisplay,twin->xwindow,twin->xgc,x1,y1,x2-1,y1);
          XDrawLine(PStatus.xdisplay,twin->xwindow,twin->xgc,x1,y1,x1,y2-1);
          XSetForeground(PStatus.xdisplay,twin->xgc,black);
          XDrawLine(PStatus.xdisplay,twin->xwindow,twin->xgc,x1,y2-1,x2-1,y2-1);
          XDrawLine(PStatus.xdisplay,twin->xwindow,twin->xgc,x2-1,y1,x2-1,y2-1);
    if (tcontrol->image!=0) {
//     	if (tcontrol->image2!=0 && tcontrol->Bits&CToggle && tcontrol->Bits&CToggleValue)  {//is a toggle
     	if (tcontrol->image2!=0 &&  //has a color change image
					(((tcontrol->Bits&CToggle) && tcontrol->value) || //is not selected toggle
					(tcontrol->Bits&CButtonDown(0))) && //or button is not down on
					!(tcontrol->Bits&CNoColorChangeButton(0)))   { //and can change color
					//fprintf(stderr,"Drawing non-no color change button image\n");
					if (!(tcontrol->Bits&CNoColorChangeMouse) && tcontrol->Bits&CMouseOver && tcontrol->image3!=0) {  //mouse is over a selected (or toggled) button
	          XPutImage(PStatus.xdisplay,twin->xwindow,twin->xgc,tcontrol->image3,0,0,x1,y1,bw-1,bh-1); 
	          XPutImage(PStatus.xdisplay,twin->xwindow,twin->xgc,tcontrol->image2,0,0,x1,y1,bw-1,bh-1);
					} //tcontrol->NoColorChange
				} else { //image2!=0 - is not a selected toggle button 
          XPutImage(PStatus.xdisplay,twin->xwindow,twin->xgc,tcontrol->image,0,0,tcontrol->x1,tcontrol->y1,bw-1,bh-1);
      } else { //image2==0 - not a selected or toggled button
				//mouse over non-selected or toggled button
        if (tcontrol->image3!=0 &&  !(tcontrol->Bits&CNoColorChangeMouse) && tcontrol->Bits&CMouseOver) {  //mouse is over FTControl image3=mouse over
//!(tcontrol->Bits&CNoColorChangeButton(0)) || 
//          if (tcontrol->Bits&CButtonDown(0))  //mouse over and button is down
//            XPutImage(PStatus.xdisplay,twin->xwindow,twin->xgc,tcontrol->image3,0,0,tcontrol->x1,tcontrol->y1,bw-1,bh-1);
            XPutImage(PStatus.xdisplay,twin->xwindow,twin->xgc,tcontrol->image3,0,0,x1,y1,bw-1,bh-1);
         //no image3 - mouse not over non-selected non-toggled button
          XPutImage(PStatus.xdisplay,twin->xwindow,twin->xgc,tcontrol->image,0,0,x1,y1,bw-1,bh-1);
     // XPutImage(PStatus.xdisplay,xwindow[tcontrol->win],xgc[tcontrol->win],tcontrol->image,0,0,0,0,32,32);
    }  //tcontrol->image!=0 end if button has a bitmap
        if (tcontrol->Bits&CShowText)
            XSetForeground(PStatus.xdisplay, twin->xgc, tcontrol->textcolor[0]); //normal
//            XSetBackground(PStatus.xdisplay, twin->xgc, tcontrol->textcolor[1]); //
//            if (PStatus.MouseX>tcontrol->x1 && PStatus.MouseX<tcontrol->x2 && PStatus.MouseY>tcontrol->y1 && PStatus.MouseY<tcontrol->y2) {  //mouse is over FTControl
            if (!(tcontrol->Bits&CNoColorChangeMouse) && tcontrol->Bits&CMouseOver) {  //mouse is over FTControl
              XSetForeground (PStatus.xdisplay, twin->xgc, ~tcontrol->textcolor[0]);
//            if (!(tcontrol->Bits&CNoColorChangeButton) && tcontrol->Bits&CButtonDown) { //button is down
//              XSetForeground (PStatus.xdisplay, twin->xgc, tcontrol->color[1]);
//            }  //if button is down (and mouse is over - only way can be)
         while(ex3<strlen(tcontrol->text) && cx<x2-fw && y1+fh+1<y2)
           if (tcontrol->text[ex3]==0x26)  //& underline
							//instead of XDrawImageString - which draws background color
             XDrawString(PStatus.xdisplay,twin->xwindow,twin->xgc,cx,y1+fh,&tcontrol->text[ex3],1);
             XDrawLine(PStatus.xdisplay,twin->xwindow,twin->xgc,cx,y1+fh+1,cx+fw,y1+fh+1);
			if (tcontrol->Bits&CVScroll) {
				sprintf(tstr,"%s%s",PStatus.PrefixVScrollSlide,&tcontrol->name[strlen(PStatus.PrefixVScrollBack)]);
//    fprintf(stderr,"FTControl2 %s %d\n",tcontrol->name,tcontrol->x2);
      if (tcontrol->OnDraw!=0) {
 			   //fprintf(stderr,"call OnDraw function for %s\n",tcontrol->name);
				(*tcontrol->OnDraw) (twin,tcontrol);
//    fprintf(stderr,"FTControl3 %s %d\n",tcontrol->name,tcontrol->x2);
//		} //			if (!(tcontrol->Bits&CNotVisible)) {
		//fw=tcontrol->font->max_bounds.width;
		//fh=tcontrol->font->max_bounds.ascent+tcontrol->font->max_bounds.descent;
//      fprintf(stderr,"FTControl %s is label in window %d\n",tcontrol->name,win);
    XSetForeground (PStatus.xdisplay,twin->xgc,tcontrol->color[0]);
    XFillRectangle(PStatus.xdisplay,twin->xwindow,twin->xgc,x1,y1,bw,bh);
    XSetForeground(PStatus.xdisplay,twin->xgc,tcontrol->textcolor[0]);  
//    XSetBackground(PStatus.xdisplay, twin->xgc, tcontrol->textcolor[1]);  //background color of text
    cx=x1+1;//tcontrol->cx;//+tcontrol->font->max_bounds.width;
    tlen=((strlen(tcontrol->text)+1)*fw<bw)?strlen(tcontrol->text):(bw/tcontrol->font->max_bounds.width)-1;
//instead of image string - don't need custom background color for label
    XDrawString(PStatus.xdisplay,twin->xwindow,twin->xgc,x1,y1+fh,tcontrol->text,tlen);
      if (tcontrol->OnDraw!=0) {
				(*tcontrol->OnDraw) (twin,tcontrol);
		//fw=tcontrol->font->max_bounds.width;
		//fh=tcontrol->font->max_bounds.ascent+tcontrol->font->max_bounds.descent;
     // fprintf(stderr,"FTControl %s is textbox in window %d\n",tcontrol->name,win);
     //fprintf(stderr,"flags=%x\n",tcontrol->Bits);
    XSetForeground (PStatus.xdisplay,twin->xgc,tcontrol->color[1]);
    XFillRectangle(PStatus.xdisplay,twin->xwindow,twin->xgc,x1,y1,bw,bh);
    XSetForeground (PStatus.xdisplay,twin->xgc,tcontrol->color[0]);  //only white?
    XFillRectangle(PStatus.xdisplay,twin->xwindow,twin->xgc,x1+1,y1+1,bw-1,bh-1);
    XSetForeground (PStatus.xdisplay,twin->xgc,tcontrol->textcolor[0]);  //text color
    XSetBackground(PStatus.xdisplay,twin->xgc,tcontrol->textcolor[1]);  //background color of text
//		fprintf(stderr,"i[0]=%d i[1]=%d len=%d\n",tcontrol->i[0],tcontrol->i[1],(int)strlen(tcontrol->text));										
//chr(10)-adds extra row (another approach is go through and count actual strlen - then for loop)
//checking for selected text by looking at tcontrol->i[4] and i[5]
//a person might erase part or all of tcontrol->text, and so i[0] and i[1] needs to be reset
//if there ever is a change to ->text
//ideally, FT would get called anytime tcontrol->text is changed programatically to adjust i[0], etc
//the cursor position should never be > the length of the string - if it is, a user probably
//changed the text in a textbox or textarea - just move cursor to end of text if any
		if (tcontrol->i[0]>strlen(tcontrol->text)) { //user changed text programatically
//			fprintf(stderr,"i[0]>strlen (%d>%d)\n",tcontrol->i[0],(int)strlen(tcontrol->text));
			tcontrol->i[0]=strlen(tcontrol->text);
			if (strlen(tcontrol->text)>maxwidth) {
				tcontrol->i[1]=strlen(tcontrol->text)-maxwidth;
				tcontrol->i[1]=0;
			tcontrol->i[2]=strlen(tcontrol->text);
			tcontrol->i[3]=strlen(tcontrol->text);
		} //strlen(tcontrol->text)
		//for all characters print - to catch chr(10)
		tlen=strlen(tcontrol->text);
//		fprintf(stderr,"cx=%d cy=%d i=%d tlen=%d y2=%d\n",cx,cy,i,tlen,tcontrol->y2);
		if (tcontrol->Bits&CAutoScroll) {
			i=tlen-1;
			tcontrol->i[0]=i;
				if (tcontrol->text[i]==10) {
						tcontrol->i[1]=i+1;
						i=-1;
				i--;
		cy=y1+fh-1; 
		i=tcontrol->i[1]; //cursor position in characters, first showing character
//		while(i<=tlen && ((tcontrol->type==CTTextArea && cy<tcontrol->y2) || (tcontrol->type==CTTextBox && cx<tcontrol->x2))) {
//		while(i<=tlen && cy<tcontrol->y2) {
			if (tcontrol->text[i]!=10) {
				if (tcontrol->text[i]!=0) { // && cx+fw<tcontrol->x2-1) {
					if (tcontrol->i[2]!=tcontrol->i[3]) { //there is selected text
						if (i>=tcontrol->i[2] && i<tcontrol->i[3]) { //draw selected
			      	XSetForeground(PStatus.xdisplay,twin->xgc,tcontrol->textcolor[2]);  //selected text color
			      	XSetBackground(PStatus.xdisplay,twin->xgc,tcontrol->textcolor[3]); // selected text background color
			      	XSetForeground(PStatus.xdisplay,twin->xgc,tcontrol->textcolor[0]); 
			      	XSetBackground(PStatus.xdisplay,twin->xgc,tcontrol->textcolor[1]); 
					} //[2]!=[3] - there is selected text
			  XDrawImageString(PStatus.xdisplay,twin->xwindow,twin->xgc,cx,cy,&tcontrol->text[i],1);
				//fprintf(stderr,"%d ",tcontrol->text[i]);					
				} //tcontrol->text[i]!=0 && cx+fw<tcontrol->x2-1 textarea is large enough				
//			fprintf(stderr,"i=%d i[0]=%d i[1]=%d\n",i,tcontrol->i[0],tcontrol->i[1]);										
//			if (tcontrol->i[0]==i || tcontrol->i[0]==tlen+1) { //cursor position is here - needs to be after character is drawn but before character is advanced
			if (tcontrol->i[0]==i) { //cursor position is here - needs to be
			//	fprintf(stderr,"test Draw Cursor tcontrol->tab  %d ==%d twin->focus\n",tcontrol->tab,twin->focus);
				if (tcontrol->tab==twin->focus && !(tcontrol->Bits&CNoTab) && !(tcontrol->Bits&CReadOnly)) {
				  if (tcontrol->Bits&CEraseCursor) {
							tcontrol->Bits&=~CEraseCursor;  
					if (tcontrol->i[0]==tlen+1) {  //if cursor is at last character draw now
						if (cx>tcontrol->x2-fw) {
							cx=tcontrol->x1+1;
						} //cx>tcontrol->x2-fw
					} //tcontrol->i[0]==tlen+1
//					fprintf(stderr,"Draw Cursor at position i=%d %d %d\n",i,cx,cy-fh+3);
					XDrawLine(PStatus.xdisplay,twin->xwindow,twin->xgc,cx,cy-fh+3,cx,cy);
			if (tcontrol->text[i]==10 && tcontrol->type==CTTextArea) {
			if (tcontrol->type==CTTextArea) {
				if (tcontrol->text[i]!=0 && tcontrol->text[i]!=10) {
					if (cx>x2-fw) {
					} //cx>tcontrol->x2-fw
			} else { //tcontrol->type==CTTextArea
				if (cx>x2-fw) {
					if (tcontrol->i[0]==i+1) { //cursor position is here - needs to be
						if (tcontrol->tab==twin->focus && !(tcontrol->Bits&CNoTab) && !(tcontrol->Bits&CReadOnly)) {
							if (tcontrol->Bits&CEraseCursor) {
									tcontrol->Bits&=~CEraseCursor;  
//							fprintf(stderr,"Draw Cursor at position i=%d %d %d\n",i,cx,cy-fh+3);
							XDrawLine(PStatus.xdisplay,twin->xwindow,twin->xgc,cx,cy-fh+3,cx,cy);
					} //if (tcontrol->i[0]==i) { //cursor position is here - needs to be
			} //tcontrol->type==CTTextArea
		if (tcontrol->Bits&CVScroll) {
			//determine number of rows of text - 
			while(i<=strlen(tcontrol->text)) {
//				if (i==tcontrol->i[1]) {
				if (i==tcontrol->i[0]) {  //used i[0] but now i[1] since scroll follows page not cursor
				if (tcontrol->text[i]==10) {
			//perhaps clip and then use tcontrol2->cx1, etc. 
			sprintf(tstr,"%s%s",PStatus.PrefixVScrollSlide,tcontrol->name);
				sprintf(tstr,"%s%s",PStatus.PrefixVScrollBack,tcontrol->name);
						cy=(float)((tcontrol3->y2-tcontrol3->y1)*maxheight)/(float)numrow; //button size
						tcontrol2->y1=tcontrol3->y1+(tcontrol3->y2-tcontrol3->y1-cy)*(float)currow/(float)numrow;
						tcontrol2->y2=tcontrol2->y1+cy; //maxheight/numrow * scroll back button size
//						fprintf(stderr,"y12=%d y2=%d\n",tcontrol2->y1,tcontrol2->y2);
					DrawFTControl(tcontrol3); //redraw scroll bar back - to erase any scroll bar button
    if (tcontrol->OnDraw!=0) {
			(*tcontrol->OnDraw) (twin,tcontrol);
  		//fw=tcontrol->font->max_bounds.width;
			//fh=tcontrol->font->max_bounds.ascent+tcontrol->font->max_bounds.descent;
//       fprintf(stderr,"FTControl %s is checkbox in window %d\n",tcontrol->name,win);
	//todo: change CTCheckBox to use x1->x2 as full size and x3=point between checkbox and label text
   bw=tcontrol->x3-tcontrol->x1;
   bh=tcontrol->y3-tcontrol->y1; 
   tcontrol->x2=tcontrol->x1+bw+(fw*(strlen(tcontrol->text)+1));
   tcontrol->y2=tcontrol->y3;
    //fprintf(stderr,"checkbox FTControl %s is button in window %d\n",tcontrol->name,win);
    XSetForeground (PStatus.xdisplay, twin->xgc, tcontrol->color[1]);
    XFillRectangle(PStatus.xdisplay,twin->xwindow, twin->xgc, tcontrol->x1, tcontrol->y1, bw, bh);
    XSetForeground (PStatus.xdisplay, twin->xgc, tcontrol->color[0]);
    XFillRectangle(PStatus.xdisplay,twin->xwindow, twin->xgc, tcontrol->x1+1, tcontrol->y1+1, bw-1, bh-1);
    //fprintf(stderr,"checkbox value =%d\n",tcontrol->value);
    if (tcontrol->value)
      //fprintf(stderr,"drawing line color =%d\n",tcontrol->color[1]);
      XSetForeground (PStatus.xdisplay, twin->xgc, tcontrol->color[1]);
      XDrawLine(PStatus.xdisplay,twin->xwindow, twin->xgc, tcontrol->x1+1, tcontrol->y1+1, tcontrol->x3-1, tcontrol->y3-1);
      XDrawLine(PStatus.xdisplay,twin->xwindow, twin->xgc, tcontrol->x1+1, tcontrol->y1+2, tcontrol->x3-2, tcontrol->y3-1);
      XDrawLine(PStatus.xdisplay,twin->xwindow, twin->xgc,tcontrol->x3-1,tcontrol->y1+1,tcontrol->x1+1, tcontrol->y3-1);
      XDrawLine(PStatus.xdisplay,twin->xwindow, twin->xgc,tcontrol->x3-2,tcontrol->y1+1,tcontrol->x1+1, tcontrol->y3-2);
    if (tcontrol->Bits&CShowText)
      XSetForeground (PStatus.xdisplay, twin->xgc, 0x0);
      XDrawString(PStatus.xdisplay,twin->xwindow,twin->xgc,tcontrol->x3+fw,tcontrol->y1+fh+1,tcontrol->text,strlen(tcontrol->text));
//      XDrawImageString(PStatus.xdisplay,twin->xwindow,twin->xgc,tcontrol->x2+fw,tcontrol->y1+fh,tcontrol->text,strlen(tcontrol->text));
      //fprintf(stderr,"%d = x2\n",tcontrol->x2);
      if (tcontrol->OnDraw!=0) {
				(*tcontrol->OnDraw) (twin,tcontrol);
	//todo: change CTRadio to use x1->x2 as full size and x3=point between checkbox and label text
//        fprintf(stderr,"FTControl %s is radio in window %d\n",tcontrol->name,win);
     bw=tcontrol->x3-tcontrol->x1;
     bh=tcontrol->y3-tcontrol->y1; tcontrol->x2=tcontrol->x1+bw+(tcontrol->font->max_bounds.width*(strlen(tcontrol->text)+1));
     tcontrol->y2=tcontrol->y3;
    //fprintf(stderr,"radio FTControl %s is button in window %d\n",tcontrol->name,win);
    XSetForeground (PStatus.xdisplay, twin->xgc, tcontrol->color[1]);
//XSetFillStyle(PStatus.xdisplay,twin->xgc, FillSolid  );
 XFillArc(PStatus.xdisplay,twin->xwindow,twin->xgc,tcontrol->x1,tcontrol->y1,bw,bh,0,360*64);
    //XFillRectangle(PStatus.xdisplay,twin->xwindow, twin->xgc, tcontrol->x1, tcontrol->y1, bw, bh);
    XSetForeground (PStatus.xdisplay, twin->xgc, tcontrol->color[0]);
XFillArc(PStatus.xdisplay,twin->xwindow,twin->xgc,tcontrol->x1+bw/12,tcontrol->y1+bh/12,bw*5/6,bh*5/6,0,360*64);
    //XFillRectangle(PStatus.xdisplay,twin->xwindow, twin->xgc, tcontrol->x1+1, tcontrol->y1+1, bw-1, bh-1);
    //fprintf(stderr,"checkbox value =%d\n",tcontrol->value);
    if (tcontrol->value)
      //fprintf(stderr,"drawing line color =%d\n",tcontrol->color[1]);
      XSetForeground (PStatus.xdisplay, twin->xgc, tcontrol->color[1]);
//XFillArc(PStatus.xdisplay,twin->xwindow,twin->xgc,tcontrol->x1+bw*3/16,tcontrol->y1+bh*3/16,bw*5/8,bh*5/8,0,360*64);
      XFillArc(PStatus.xdisplay,twin->xwindow,twin->xgc,tcontrol->x1+bw/4,tcontrol->y1+bh/4,bw/2,bh/2,0,360*64);
    if (tcontrol->Bits&CShowText)
      XSetForeground (PStatus.xdisplay, twin->xgc, 0x0);
      XDrawString(PStatus.xdisplay,twin->xwindow,twin->xgc,tcontrol->x3+tcontrol->font->max_bounds.width,tcontrol->y1+tcontrol->font->max_bounds.ascent+tcontrol->font->max_bounds.descent+1,tcontrol->text,strlen(tcontrol->text));
      //fprintf(stderr,"%d = x2\n",tcontrol->x2);
      if (tcontrol->OnDraw!=0) {
				(*tcontrol->OnDraw) (twin,tcontrol);
//        fprintf(stderr,"FTControl %s is fileopen in window %d\n",tcontrol->name,win);
//      bw=tcontrol->x2-tcontrol->x1+10;//tcontrol->font->max_bounds.width;
//      bh=tcontrol->y2-tcontrol->y1+64;
//50+(tcontrol->font->max_bounds.ascent+tcontrol->font->max_bounds.descent)
      pmap = XCreatePixmap(PStatus.xdisplay,twin->xwindow,bw,bh,PStatus.depth);
      XSetForeground(PStatus.xdisplay,twin->xgc,tcontrol->color[1]);
      XFillRectangle(PStatus.xdisplay,pmap, twin->xgc, tcontrol->x1, tcontrol->y1, bw, bh);
//possibly just drawing 2 lines is faster - this is to pmap
      XFillRectangle(PStatus.xdisplay,pmap,twin->xgc,0,0,bw,bh);
      XSetForeground(PStatus.xdisplay,twin->xgc,tcontrol->color[0]);  //only white?
//      XFillRectangle(PStatus.xdisplay,pmap, twin->xgc, tcontrol->x1+1, tcontrol->y1+1, bw-1, bh-1);
      XFillRectangle(PStatus.xdisplay,pmap,twin->xgc,1,1,bw-1,bh-1);
//      XSetForeground(PStatus.xdisplay,twin->xgc,tcontrol->color[1]);
 //     XDrawLine(PStatus.xdisplay,pmap,twin->xgc,0,0,bw,bh);
     XSetForeground(PStatus.xdisplay,twin->xgc,tcontrol->textcolor[0]);  //text color
//      cx=tcontrol->x1;//+tcontrol->cx;//+tcontrol->font->max_bounds.width;
      cx=0;//tcontrol->x1;//+tcontrol->cx;//+tcontrol->font->max_bounds.width;
//      fprintf(stderr,"above free FTItem list %p\n",tcontrol->ilist);
      if (tcontrol->ilist==0 || tcontrol->ilist->item==0 || (tcontrol->ilist->Bits&FTIL_REREAD)) {
        if (tcontrol->ilist!=0) {
//         fprintf(stderr,"free FTItem list %p\n",tcontrol->ilist);
//          tcontrol->ilist=FreeFTItemList(tcontrol->ilist);  //could FreeFTItems(tcontrol->ilist)
          //FreeFTItems(&tcontrol->ilist);
					//CloseFTItemList(&tcontrol->ilist);  
					DelFTItemList(tcontrol->ilist);
					tcontrol->ilist=0;
          //tcontrol->ilist=(FTItemList *)malloc(sizeof(FTItemList));
          //memset(tcontrol->ilist,0,sizeof(FTItemList));
          //tcontrol->i[0]=0;  //reset fileopen pointers
          //tcontrol->ilist->cur=tcontrol->i[1];  //restore cur
          //tcontrol->i[1]=0;
//          fprintf(stderr,"cur=%d\n",tcontrol->ilist->cur);
      //fprintf(stderr,"after free FTItem list tcontrol->ilist=%p\n",tcontrol->ilist);
//        tcontrol->numvisible=(tcontrol->y2-tcontrol->y1-1)/(tcontrol->font->max_bounds.ascent+tcontrol->font->max_bounds.descent);
        tcontrol->i[0]=0;  //first FTItem is top of window
//        fprintf(stderr,"b4 getFTItem0 %d\n",tcontrol->i[0]);
  //    fprintf(stderr,"tcontrol->numvisible= %d\n",tcontrol->numvisible);
        //tcontrol->i[0]=0;  //i[0] is filename index entry at top of FTControl (box/rect/window)
//       fprintf(stderr,"before readdir twin=%s\n",twin->name);
        XDefineCursor(PStatus.xdisplay,twin->xwindow,watch);
           //fprintf(stderr,"%s\n",direp->d_name);
//           fprintf(stderr,"%d\n",stat(direp->d_name, &statBuffer));
  //         fprintf(stderr,"tcontrol->ilist=%p\n",tcontrol->ilist);
           if (strcmp(direp->d_name,".")!=0) {
             if (stat(direp->d_name, &statBuffer)==0) {
//               tcontrol->ilist=AddFTItem(tcontrol->ilist,direp->d_name,1);
//               tcontrol->ilist=AddFTItem(tcontrol->ilist,direp->d_name,S_ISDIR(statBuffer.st_mode));
                 //litem->name=(char *)malloc(strlen(direp->d_name)+1);
                 strcpy(litem->name,direp->d_name);
                 litem->Bits=S_ISDIR(statBuffer.st_mode);
                 litem->idate = *localtime(&statBuffer.st_mtime);
                 litem->size = statBuffer.st_size;
//                 AddFTItem(&tcontrol->ilist,litem);
                 //free(litem->name);
                 //litem->name=0;
								strcpy(litem->name,"");
        XUndefineCursor(PStatus.xdisplay,twin->xwindow);
        tcontrol->numvisible=(tcontrol->y2-tcontrol->y1-1)/fh;   //is calc again later, because may be resize with no new file read
        if (tcontrol->Bits&CVScroll) {
        } //tcontrol->Bits
        if (tcontrol->Bits&CHScroll) {
        } //tcontrol->Bits
        tcontrol->ilist->Bits&=~(FTIL_REREAD);
        SortFTItemList(tcontrol->ilist,tcontrol->i[1],tcontrol->i[2]); 
//        SortFTItemList(tcontrol->ilist,0,0); 
        }  //end if ilist==0 || tcontrol->ilist->Bits&I_REREAD
  //      fprintf(stderr,"nums=%d\n",tcontrol->ilist->num);
  //      fprintf(stderr,"getFTItem %p i[0]=%d\n",tcontrol->ilist,tcontrol->i[0]);
//        fprintf(stderr,"getFTItem tcontrol->ilist=%p\n",tcontrol->ilist);
//        cx=tcontrol->x1+1;
//        cy=tcontrol->y1+tcontrol->font->max_bounds.ascent+1;
//        fprintf(stderr,"b4 getFTItem %d\n",tcontrol->i[0]);
//        litem=GetFTItem(tcontrol->ilist,0,tcontrol->i[0]);
//        litem=GetFTItemByNum(tcontrol->ilist,tcontrol->i[0]);
//        litem=GetFTItemByNum(tcontrol,tcontrol->i[0]);
//get item 1 is the first item tlist->cur=0 is no selection
        litem=GetFTItemByNum(tcontrol,tcontrol->i[0]+1);
        tcontrol->numvisible=(tcontrol->y2-tcontrol->y1-1)/fh;
          maxwidth=(bw-fh-1)/fw;
          j=(tcontrol->numvisible>tcontrol->ilist->num)?tcontrol->ilist->num:tcontrol->numvisible;
//          fprintf(stderr,"numvis=%d nums=%d\n",tcontrol->numvisible,tcontrol->ilist->num);
  //      fprintf(stderr,"after getFTItem %p\n",tcontrol->ilist);
      //  fprintf(stderr,"tcontrol->font width=%d\n",tcontrol->font->max_bounds.width);
      //  fprintf(stderr,"bw=%d FTControl->x2-x1=%d\n",bw,tcontrol->x2-tcontrol->x1);
              if (tcontrol->Bits&CFOName) {
                sprintf(tstr,"%s%s",PStatus.PrefixName,tcontrol->name);
                ti=(int)(maxwidth*((float)tcontrol2->x2/(float)tcontrol->x2));
                //fprintf(stderr,"%s %d %d %d\n",tcontrol2->name,ti,tcontrol2->x2,tcontrol->x2);
              if (tcontrol->Bits&CFOSize) {
                sprintf(tstr,"%s%s",PStatus.PrefixSize,tcontrol->name);
                tj=(int)(maxwidth*((float)tcontrol2->x2/(float)tcontrol->x2));
                //fprintf(stderr,"%s %d %d %d\n",tcontrol2->name,ti,tcontrol2->x2,tcontrol->x2);
          for(i=tcontrol->i[0];i<tcontrol->i[0]+j;i++) {
//        fprintf(stderr,"tcontrol=%s i=%d\n",tcontrol->name,i);
//        fprintf(stderr,"litem=%s\n",litem->name);
            if (cy<tcontrol->y2) {
//              sprintf(tstr,"%s %d %02d/%02d/%02d",litem->name,litem->size,litem->idate.tm_mon+1,litem->idate.tm_mday,litem->idate.tm_year-100);
//              memcpy(tstr,litem->name,strlen(litem->name));
              cx=strlen(litem->name);
              memcpy(tstr,litem->name,ti>cx?cx:ti);
//              sprintf(tstr,"%s",litem->name);
              //sprintf(&tstr[ti],"%d",litem->size);              
               if (tcontrol->Bits&CFOSize) {
                if (litem->size>1000000000) {
                  sprintf(tstr2,"%d GB",litem->size/1000000000);
                  //sprintf(&tstr[tj-strlen(tstr2)-1],"%s",tstr2);
                  if (litem->size>1000000) {
                    sprintf(tstr2,"%d MB",litem->size/1000000);
//                    sprintf(&tstr[tj-strlen(tstr2)-1],"%s",tstr2);
                    if (litem->size>1000) {
                      sprintf(tstr2,"%d KB",litem->size/1000);
//                      sprintf(&tstr[tj-strlen(tstr2)-1],"%s",tstr2);
                      sprintf(tstr2,"%d  B",litem->size/1000000);
//                      sprintf(&tstr[tj-strlen(tstr2)-1],"%s",tstr2);
                cw=tj-cx-1<ti?ti:tj-cx-1;
//                memcpy(tstr,litem->name,ti>cx?cx:ti);                
//                memcpy(&tstr[tj-cx-1],tstr2,cx);
                memcpy(&tstr[cw],tstr2,tj-ti>cx?cx:tj-ti);
//                memcpy(&tstr[tj-strlen(tstr2)-1],tstr2,strlen(tstr2));
                }  //end if (tcontrol->flagas&CFOSize) {
               if (tcontrol->Bits&CFODate) {
              if (litem->idate.tm_hour>12)              
                sprintf(tstr2,"%02d/%02d/%02d %02d:%02d:%02d PM",litem->idate.tm_mon+1,litem->idate.tm_mday,litem->idate.tm_year-100,litem->idate.tm_hour-12,litem->idate.tm_min,litem->idate.tm_sec);
                sprintf(tstr2,"%02d/%02d/%02d %02d:%02d:%02d AM",litem->idate.tm_mon+1,litem->idate.tm_mday,litem->idate.tm_year-100,litem->idate.tm_hour,litem->idate.tm_min,litem->idate.tm_sec);
                cw=maxwidth-cx-1<tj?tj:maxwidth-cx-1;
                memcpy(&tstr[cw],tstr2,maxwidth-tj>cx?cx:maxwidth-tj);
               } //if (tcontrol->Bits&CFODate)
//              fprintf(stderr,"%d FTItem=%s cur=%d\n",i,litem->name,tcontrol->ilist->cur);
              if (i==tcontrol->ilist->cur) { //this is the selected file 0=none selected
              //strcpy(tcontrol->filename,litem->name);
                XSetForeground (PStatus.xdisplay, twin->xgc, blue);
//I think this should be tcontrol->textcolor3 - for selected file menu files and folders
                //XSetForeground (PStatus.xdisplay, twin->xgc,tcontrol->textcolor3);        
//                XFillRectangle(PStatus.xdisplay,pmap,twin->xgc,tcontrol->x1,cy-tcontrol->font->max_bounds.ascent,bw-1,tcontrol->font->max_bounds.descent+tcontrol->font->max_bounds.ascent);
                XFillRectangle(PStatus.xdisplay,pmap,twin->xgc,0,cy-fh,bw-1,fh);
                XSetForeground (PStatus.xdisplay, twin->xgc, white);    
                XSetBackground (PStatus.xdisplay, twin->xgc, blue);    
                XSetForeground (PStatus.xdisplay, twin->xgc, black);    
                XSetBackground (PStatus.xdisplay, twin->xgc, white);    
                if (litem->Bits&FTI_FOLDER) {
//             fprintf(stderr,"here3 %p\n",tcontrol->image);
                  //cx=tcontrol->x1+1;
                  XPutImage(PStatus.xdisplay,pmap,twin->xgc,tcontrol->image,0,0,cx,cy-fh,fh,fh);
                  //cx=tcontrol->x1+1;
                  XPutImage(PStatus.xdisplay,pmap,twin->xgc,tcontrol->image2,0,0,cx,cy-fh,fh,fh);
//              sprintf(tstr,"%s %2d/%2d/%2d",litem->name,litem->idate.tm_mon+1,litem->idate.tm_mday,litem->idate.tm_year);
                XDrawString(PStatus.xdisplay,pmap,twin->xgc,cx,cy-2,tstr,cw);         
//              XDrawImageString(PStatus.xdisplay,twin->xwindow,twin->xgc,cx,cy,litem->name,cw);         
            }//(cy<tcontrol->y2)
//          if (cy>tcontrol->y2-tcontrol->font->max_bounds.ascent-tcontrol->font->max_bounds.descent) break;
//          puts (direp->d_name);
           if (litem->next !=0) litem=(FTItem *)litem->next;
//      XDrawImageString(PStatus.xdisplay,twin->xwindow,twin->xgc,tcontrol->x1,tcontrol->y1+tcontrol->font->max_bounds.ascent,tcontrol->text,strlen(tcontrol->text));
//      XDrawLine(PStatus.xdisplay,twin->xwindow,twin->xgc,cx,tcontrol->y1+1,cx,tcontrol->y2-1);
      //XPutImage(PStatus.xdisplay,twin->xwindow,twin->xgc,Timage,tcontrol->x1,tcontrol->y1,tcontrol->x1,tcontrol->y1,bw,bh);
      XPutImage(PStatus.xdisplay,twin->xwindow,twin->xgc,Timage,0,0,tcontrol->x1,tcontrol->y1,bw,bh);
      if (tcontrol->OnDraw!=0) {
				(*tcontrol->OnDraw) (twin,tcontrol);
      if (tcontrol->Bits&CVScroll) {
        sprintf(tstr,"%s%s",PStatus.PrefixVScrollUp,tcontrol->name);
        sprintf(tstr,"%s%s",PStatus.PrefixVScrollDown,tcontrol->name);
        sprintf(tstr,"%s%s",PStatus.PrefixVScrollBack,tcontrol->name);
        sprintf(tstr,"%s%s",PStatus.PrefixVScrollSlide,tcontrol->name);
      if (tcontrol->Bits&CHScroll) {
      if (tcontrol->Bits&CFOName) {
        sprintf(tstr,"%s%s",PStatus.PrefixName,tcontrol->name);
      if (tcontrol->Bits&CFOSize) {
        sprintf(tstr,"%s%s",PStatus.PrefixSize,tcontrol->name);
      if (tcontrol->Bits&CFODate) {
        sprintf(tstr,"%s%s",PStatus.PrefixDate,tcontrol->name);
//      fprintf(stderr,"DrawImage %s\n",tcontrol->name);
//      fprintf(stderr,"x,y,w,h %d %d %d %d\n",tcontrol->x1,tcontrol->y1,bw,bh);
      if (tcontrol->image!=0) {
        XPutImage(PStatus.xdisplay,twin->xwindow,twin->xgc,tcontrol->image,0,0,tcontrol->x1,tcontrol->y1,bw,bh);
      }  //tcontrol->image!=0
         bw=tcontrol->x2-tcontrol->x1+1;  //may need a scroll bar for text that is larger
         bh=tcontrol->y2-tcontrol->y1+1;
//      if (tcontrol->type==CTCombo  && !(tcontrol->Bits&CSubMenu))  {	//Combo box
      if (tcontrol->type==CTCombo)  {	//Combo box
       if (tcontrol->x3==0) //over write start x location of box with triangle
           tcontrol->x3=tcontrol->x2-20;// just make size of box standard at 32 pixels bw/5;
    //fprintf(stderr,"Draw combo box FTControl %s is button in window %d\n",tcontrol->name,win);
         cx=tcontrol->x1;
         cx2=tcontrol->x2;
         cy=tcontrol->y1;
         cy2=tcontrol->y2;
          XSetForeground (PStatus.xdisplay, twin->xgc, tcontrol->color[1]);
//          XFillRectangle(PStatus.xdisplay,twin->xwindow, twin->xgc, tcontrol->x1, tcontrol->y1, bw+bw/5, bh);
          XFillRectangle(PStatus.xdisplay,twin->xwindow, twin->xgc, tcontrol->x1, tcontrol->y1, bw-1,bh-1);
          XSetForeground (PStatus.xdisplay, twin->xgc, tcontrol->color[0]);
//          XFillRectangle(PStatus.xdisplay,twin->xwindow, twin->xgc, tcontrol->x1+1, tcontrol->y1+1, bw-1+bw/5, bh-1);
          XFillRectangle(PStatus.xdisplay,twin->xwindow, twin->xgc, tcontrol->x1+1, tcontrol->y1+1, bw-2, bh-2);
        if (!(tcontrol->Bits&C2D)) {
          XSetForeground(PStatus.xdisplay,twin->xgc,white);
          XDrawLine(PStatus.xdisplay,twin->xwindow,twin->xgc,tcontrol->x1,tcontrol->y1,tcontrol->x2-1,tcontrol->y1);
          XDrawLine(PStatus.xdisplay,twin->xwindow,twin->xgc,tcontrol->x1,tcontrol->y1,tcontrol->x1,tcontrol->y2-1);
          XSetForeground(PStatus.xdisplay,twin->xgc,black);
          XDrawLine(PStatus.xdisplay,twin->xwindow,twin->xgc,tcontrol->x1,tcontrol->y2-1,tcontrol->x2-1,tcontrol->y2-1);
          XDrawLine(PStatus.xdisplay,twin->xwindow,twin->xgc,tcontrol->x2-1,tcontrol->y1,tcontrol->x2-1,tcontrol->y2-1);
          if (tcontrol->Bits&CMouseOver) {  //mouse is over FTControl
//              fprintf(stderr,"draw mouse move color[2]=%x\n",tcontrol->color[2]);
              if (tcontrol->Bits&CButtonDown(0)) //and button is down
                XSetForeground (PStatus.xdisplay, twin->xgc, tcontrol->color[3]);
                XSetForeground (PStatus.xdisplay, twin->xgc, tcontrol->color[2]);
            XSetForeground (PStatus.xdisplay, twin->xgc, tcontrol->color[1]);
          }//tcontrol->Bits&CMouseOver
//          XFillRectangle(PStatus.xdisplay,twin->xwindow, twin->xgc, tcontrol->x1+1+bw, tcontrol->y1+1, bw/5-2, bh-2);
          XSetForeground (PStatus.xdisplay, twin->xgc, tcontrol->color[1]); //should be wingray
          XFillRectangle(PStatus.xdisplay,twin->xwindow, twin->xgc, tcontrol->x3, tcontrol->y1+1, tcontrol->x2-tcontrol->x3, bh-2);
          XSetForeground (PStatus.xdisplay, twin->xgc, tcontrol->textcolor[0]); //tcontrol->color[1]);
//      XDrawLine(PStatus.xdisplay,twin->xwindow, twin->xgc, tcontrol->x2+1, tcontrol->y1+1, (bw/10)-1, bh-1);
          points[0].x=tcontrol->x3+2;
          points[0].y=tcontrol->y1+1+bh/3;
          points[1].x=tcontrol->x3+(tcontrol->x2-tcontrol->x3)/2;
          points[1].y=tcontrol->y1+1+bh*2/3;
          points[2].x=tcontrol->x2-2; 
          points[2].y=tcontrol->y1+1+bh/3;
//Draw a filled triangle - could do this for scroll bars
          XFillPolygon(PStatus.xdisplay,twin->xwindow,twin->xgc,points,3,Nonconvex,CoordModeOrigin);
 //XFillPolygon(PStatus.xdisplay,twin->xwindow,twin->xgc,points,3,Nonconvex,CoordModePrevious);
      if (tcontrol->Bits&CShowText)	{  //for now show text right of checkbox
				//probably just use tcontrol->text which is set on buttonup
				//get selected text - this is set in the Combo box
				if (tcontrol->value==0) { //no item has been selected
					strcpy(tstr,tcontrol->text); //just copy original text if any
					//if a person escapes - there should be the original selection
					//strcpy(tstr,""); //make empty - any original text is ignored
				} else { //tcontrol->value!=0 - get item
					//fprintf(stderr,"combo value=%d\n",tcontrol->value);
					//tlist=tcontrol2->ilist;
					//titem=GetFTItemByNum(tlist,tcontrol->value-1);
					titem=GetFTItemByNum(tcontrol,tcontrol->value);
					//titem=GetSelectedFTItem(tcontrol->ilist);
						strcpy(tstr,titem->name);
						//fprintf(stderr,"item name=%d\n",titem->name);
				} ////tcontrol->value==0
        XSetForeground (PStatus.xdisplay, twin->xgc, tcontrol->textcolor[0]);
//        XDrawImageString(PStatus.xdisplay,twin->xwindow,twin->xgc,tcontrol->x1+tcontrol->font->max_bounds.width,tcontrol->y1+tcontrol->font->max_bounds.ascent,tcontrol->text,strlen(tcontrol->text));
				 XDrawString(PStatus.xdisplay,twin->xwindow,twin->xgc,tcontrol->x1+fw,tcontrol->y1+fh,tstr,bw/fw);
	        XDrawString(PStatus.xdisplay,twin->xwindow,twin->xgc,tcontrol->x1+fw,tcontrol->y1+fh,tstr,strlen(tstr));
        //fprintf(stderr,"%d = x2\n",tcontrol->x2);
        if (!(tcontrol->Bits&C2D)) {
//          XSetForeground(PStatus.xdisplay,twin->xgc,white);
          XSetForeground(PStatus.xdisplay,twin->xgc,black);
          XDrawLine(PStatus.xdisplay,twin->xwindow,twin->xgc,tcontrol->x1,tcontrol->y1,tcontrol->x2-1,tcontrol->y1);
          XDrawLine(PStatus.xdisplay,twin->xwindow,twin->xgc,tcontrol->x1,tcontrol->y1,tcontrol->x1,tcontrol->y2-1);
          XDrawLine(PStatus.xdisplay,twin->xwindow,twin->xgc,tcontrol->x1,tcontrol->y2-1,tcontrol->x2-1,tcontrol->y2-1);
          XDrawLine(PStatus.xdisplay,twin->xwindow,twin->xgc,tcontrol->x2-1,tcontrol->y1,tcontrol->x2-1,tcontrol->y2-1);
//in fact - buttons should have underline hotkey text too
//    if (tcontrol->type==CTFileMenu && !(tcontrol->Bits&CSubMenu)) {
    if (tcontrol->type==CTFileMenu) {
        if (!(tcontrol->Bits&CNoColorChangeMouse)) { // && !(twin->Bits&WItemListOpen)) { 
            if (tcontrol->Bits&CMouseOver || tcontrol->Bits&CItemListOpen) {  //mouse is over FTControl
              XSetForeground (PStatus.xdisplay, twin->xgc, tcontrol->color[2]);
              //fprintf(stderr,"fg color %d",tcontrol->color[0]);
              XSetForeground (PStatus.xdisplay, twin->xgc, tcontrol->color[0]);
          XSetForeground (PStatus.xdisplay, twin->xgc, tcontrol->color[0]);
        XFillRectangle(PStatus.xdisplay,twin->xwindow, twin->xgc, tcontrol->x1, tcontrol->y1, bw, bh);
    if (tcontrol->image!=0) {
      XPutImage(PStatus.xdisplay,twin->xwindow,twin->xgc,tcontrol->image,0,0,tcontrol->x1,tcontrol->y1,tcontrol->x2-tcontrol->x1,tcontrol->y2-tcontrol->y1);
        if (tcontrol->Bits&CShowText)
        if (!(tcontrol->Bits&CNoColorChangeMouse)) { // && !(twin->Bits&WItemListOpen)) { 
            if (tcontrol->Bits&CMouseOver || tcontrol->Bits&CItemListOpen) {  //mouse is over FTControl
//              fprintf(stderr,"draw mouse move color[2]=%x\n",tcontrol->color[2]);
//              if (tcontrol->Bits&CButtonDown) //and button is down
  //              XSetForeground (PStatus.xdisplay, twin->xgc, ~tcontrol->color[1]);
                XSetForeground (PStatus.xdisplay, twin->xgc, ~tcontrol->textcolor[0]);
              //fprintf(stderr,"fg color[0] %d",tcontrol->color[0]);
              XSetForeground (PStatus.xdisplay, twin->xgc, tcontrol->textcolor[0]);
          XSetForeground (PStatus.xdisplay, twin->xgc, tcontrol->textcolor[0]);
//          XSetForeground (PStatus.xdisplay, twin->xgc, 0x0);
          cx=tcontrol->x1;//+tcontrol->font->max_bounds.width;
//					fprintf(stderr,"filemenu text= %s\n",tcontrol->text);  
         strcpy(tstr," ");  //pad string - could just add to cx
         strcat(tstr,tcontrol->text);
//         while(ex3<strlen(tcontrol->text))
       while(ex3<strlen(tstr) && cx<tcontrol->x2) {// && cx<bw)	{
//           if (tcontrol->text[ex3]==0x26)  //& underline
//             XDrawImageString(PStatus.xdisplay,twin->xwindow,twin->xgc,cx,tcontrol->y1+tcontrol->font->max_bounds.ascent,&tcontrol->text[ex3],1);
             XDrawString(PStatus.xdisplay,twin->xwindow,twin->xgc,cx,tcontrol->y1+fh,&tstr[ex3],1);
		           XDrawLine(PStatus.xdisplay,twin->xwindow, twin->xgc,cx,tcontrol->y1+fh+1, cx+fw,tcontrol->y1+fh+1);
  if (tcontrol->OnDraw!=0) {
		(*tcontrol->OnDraw) (twin,tcontrol);
//			fprintf(stderr,"Draw Data control %s\n",tcontrol->name);
//this may represent any line-drawn data such as audio, oscilloscope (can be set for 1 bit a track - possibly I should change this - or somehow make it person customized), etc.
     if (strlen(tcontrol->filename)>0 && tcontrol->data!=0 && !(tcontrol->Bits2&CDoNotDrawData)) {
				tTimeLine=tcontrol->TimeLineFTControl;
					fprintf(stderr,"Error: Data control %s has no connected TimeLine control.\n",tcontrol->name);
				rx2=tTimeLine->TimeScale*(long double)tcontrol->nSamplesPerSec;
				bps=(tcontrol->nBitsPerSample>>3)*tcontrol->nChannels;
				if (tcontrol->nBitsPerSample<8) {
					bps=tcontrol->nChannels; //we presume a 1-byte data minimum
//if no, the data read in may be very large - for example looking at 1 second of 1us 1-byte samples is 1e6 bytes
				if (!(tcontrol->Bits2&CDoNotReadInData)) {
//What is drawn is based only on tcontrol->StartTimeVisible, tcontrol->TimeScale, and x2-x1 (clipped coordinates of the control)
					//determine duration of data showing in seconds - duration changes (oDuration is full data duration)
					if (!(tcontrol->Bits2&CDataFileOpen) || tcontrol->StartTimeBuffer!=tcontrol->StartTimeVisible || tcontrol->EndTimeBuffer!=tcontrol->EndTimeVisible || tcontrol->TimeScaleBuffer!=tTimeLine->TimeScale) {
						//we could also get StartTimeBuffer from (lx1-tcontrol->lx1)*tcontrol->TimeScale
						//possibly I should calculate StartTimeBuffer by (lx1-tcontrol->lx1)*tcontrol->TimeScale
						rx=((long double)((u32)(tcontrol->StartTimeVisible/tTimeLine->TimeScale)))*tTimeLine->TimeScale;
//						tcontrol->StartTimeBuffer=tcontrol->StartTimeVisible+tcontrol->StartTimeData;
						tcontrol->StartTimeBuffer=rx+tcontrol->StartTimeData;
						//fprintf(stderr,"buffer st:%Lg\n",tcontrol->StartTimeBuffer);
						//tcontrol->StartTimeBuffer=(long double)(x1-tcontrol->lx1)*tcontrol->TimeScale;
						tcontrol->TimeScaleBuffer=tTimeLine->TimeScale;
						//adjust tcontrol->DurationVisible and tcontrol->EndTimeVisible just in case some how inaccurate
//						tcontrol->DurationVisible=((long double)(x2-x1))*tcontrol->TimeScale; //pixels*seconds/pixel
						DurationVisible=((long double)(x2-x1))*tTimeLine->TimeScale;
						tcontrol->EndTimeVisible=tcontrol->StartTimeVisible+DurationVisible;
						//tcontrol->DurationBuffer=tcontrol->DurationVisible; //pixels*seconds/pixel
						//tcontrol->DurationBuffer=((long double)(x2-x1))*tcontrol->TimeScale; //pixels*seconds/pixel
						tcontrol->EndTimeBuffer=tcontrol->StartTimeBuffer+DurationVisible;
//						fprintf(stderr,"Data DurationVisible=%Lg timescale=%Lg\n",tcontrol->DurationVisible,tcontrol->TimeScale);
//						if (tcontrol->Channel==0) {
//							fprintf(stderr,"Draw st %Lg et %Lg\n",tcontrol->StartTimeVisible,tcontrol->EndTimeVisible);
						//	fprintf(stderr,"Draw x1=%d x2=%d\n",tcontrol->x1,tcontrol->x2);
						if (!(tcontrol->Bits2&CDataFileOpen)) {
							tcontrol->datafptr=fopen(tcontrol->filename,"rb");
							if (tcontrol->datafptr==0) {
								fprintf(stderr,"Error: Could not open data file '%s'.\n",tcontrol->filename);
							tcontrol->Bits2|=CDataFileOpen;
//						tcontrol->StartByte=(i64)(tcontrol->StartTimeBuffer*(long double)(tcontrol->nSamplesPerSec*tcontrol->nBytesPerSample*tcontrol->nChannels));  //s * sample/s * bytes/sample * channels = bytes-channels
						tcontrol->StartByte=(i64)(tcontrol->StartTimeBuffer*(long double)(tcontrol->nSamplesPerSec*bps));  //s * sample/s * bytes/sample * channels = bytes-channels
						//fprintf(stderr,"Startbyte:%lli\n",tcontrol->StartByte);
						//fgetpos(tcontrol->datafptr,&fposition);
						fposition=ftell(tcontrol->datafptr);
						if (fposition!=tcontrol->StartByte) {
//							fprintf(stderr,"seeking %lli to StartByte %lli\n",tcontrol->StartByte-fposition,tcontrol->StartByte);
							fseek(tcontrol->datafptr,tcontrol->StartByte-fposition,SEEK_CUR);							
						//fsetpos(tcontrol->datafptr,tcontrol->StartByte,
//						fprintf(stderr,"TimeScale=%Lg rx2=%Lg\n",tcontrol->TimeScale,rx2);
						nextsample=tcontrol->StartTimeBuffer/(tTimeLine->TimeScale*tTimeLine->TimeSpace*10.0);
						nextsample-=(long double)((int)nextsample);
						//fprintf(stderr,"for: %s %d\n",tcontrol->name,x2-x1);
						for(i=0;i<x2-x1;i++) {
//each pixel represents tcontrol->TimeScale units of time
//						for(fi=tcontrol->StartTimeVisible;fi<tcontrol->StartTimeVisible+tcontrol->DurationVisible;fi+=tcontrol->TimeScale) {
	//						fprintf(stderr,"%d=%lli ",i,((u64)rx2)&tcontrol->nBitsPerSample);
							//if (tcontrol->Channel==0) { fprintf(stderr,"(%Lg)",nextsample);}
								//fread(&tcontrol->data[j],tcontrol->nBitsPerSample,1,tcontrol->datafptr);
								fread(&tcontrol->data[j],bps,1,tcontrol->datafptr);
	//							fprintf(stderr,"read:%d\t",tcontrol->data[j]);
									nextsample-=1.0; //subtract a single sample
								//if (tcontrol->Channel==0) { fprintf(stderr," %d-%d ",j,tcontrol->data[j]);}
									fseek(tcontrol->datafptr,(u64)((int)nextsample)*bps,SEEK_CUR); //move to the next drawn sample
									//if (tcontrol->Channel==0) { fprintf(stderr," seek=%d %d=%d ",((int)nextsample)*bps,j,tcontrol->data[j]);}
									nextsample-=(int)nextsample; //keep any remainder was: nextsample=0.0;
								memcpy(&tcontrol->data[j],&tcontrol->data[j-bps],bps); //just use last read sample
								//if (tcontrol->Channel==0) { fprintf(stderr," %d=%d ",j,tcontrol->data[j]);}
							//fprintf(stderr,"s:%lli ",(rx2&((u64)tcontrol->nBitsPerSample)));
							//if (tcontrol->Channel==0) { fprintf(stderr,"%Lg ",nextsample);}
						tcontrol->BufferSize=j;
//at this point DrawFTControl expects the necessary range of data to be loaded into tcontrol->data
//start and end time of data is determined by the width of the control (x2-x1) and timescale of control (ns/pixel) - perhaps timescale should be a double and seconds/pixel 0.000000001 being 1ns/pixel
//tcontrol->data is read in, in other places
       	//fprintf(stderr,"tcontrol->filename=%s,tcontrol->data=%p\n",tcontrol->filename,tcontrol->data);
         if (tcontrol->Bits&CDataSigned)	{
           //ypos=y1+(y2-y1)/2;
						ypos=tcontrol->y1+(tcontrol->y2-tcontrol->y1)/2;
           //ypos=y1+(y2-y1)*9/10;
						ypos=tcontrol->y1+(tcontrol->y2-tcontrol->y1)*9/10;
	  //fprintf(stderr,"FTControl filename  %s with ypos %d\n",tcontrol->filename,ypos);
//  sy=(float)((y2-y1)*8/10)/pow(2.0,1-1*(!(tcontrol->Bits&CDataSigned)));
//use unclipped points - drawing below will clip
//  sy=(float)((tcontrol->y2-tcontrol->y1)*8/10)/pow(2.0,1-1*(!(tcontrol->Bits&CDataSigned)));
  sy=(float)((tcontrol->y2-tcontrol->y1)*8/10)/pow(2.0,tcontrol->nBitsPerSample-1*(!(tcontrol->Bits&CDataSigned)));
	b=(i64)pow(2.0,tcontrol->Channel);
	//fprintf(stderr,"2^%d=%llx\n",tcontrol->Channel,b);
//	rx2=(long double)(tcontrol2->time*(i64)tcontrol->nSamplesPerSec*(i64)tcontrol->nBitsPerSample*(i64)tcontrol->nChannels)/((long double)PStatus.timespace*8000000000.0);
//char 	8 	-127 to 127
//short 	16 	-32,767 to 32,767
//int 	32 	-2,147,483,647 to 2,147,483,647
//long 	32 	-2,147,483,647 to 2,147,483,647
//long long 	64 	-9,223,372,036,854,775,807 to 9,223,372,036,854,775,807
//float 	32 	1e-38 to 1e+38
//double 	64 	2e-308 to 1e+308
//long double 	64 	2e-308 to 1e+308 
//ns-sample-bits-channels/pixel-8gs-sample = bytes/pixel
//	rx2=((long double)tcontrol->timescale*(long double)tcontrol->nSamplesPerSec*(long double)tcontrol->nBitsPerSample*(long double)tcontrol->nChannels)/((long double)PStatus.timespace*8000000000.0);
//	rx2=((long double)tcontrol->timescale*(long double)tcontrol->nSamplesPerSec*(long double)tcontrol->nBitsPerSample*(long double)tcontrol->nChannels)/8.0;
	//now initial offset samples/pixel - can go by time
//	dc=((long double)((StartTimeVisible-tcontrol->StartTimeVisible+tcontrol->StartTime)*(i64)tcontrol->nSamplesPerSec*(i64)tcontrol->nBitsPerSample*(i64)tcontrol->nChannels))/8000000000.0;
//this can be StartTimeVisible-StartTime, but perhaps should be done in outside functoin and called
//StartTimeVisible-StartTime will be independent of timeline, FTControl is at 10ns, but is resize 10ns on left
//StartTime=10ns but StartTimeVisible will be 20ns, 20-10 = start 10ns in 
//ia[0] holds the start time of the data - why not use StartTimeVisible?
//	dc=((long double)(tcontrol->ia[0]*(i64)tcontrol->nSamplesPerSec*(i64)tcontrol->nBitsPerSample*(i64)tcontrol->nChannels))/8000000000.0;
//fprintf(stderr,"st=%lli ost=%lli nsamp=%d nbit=%d nchan=%d\n",tcontrol->StartTimeVisible,tcontrol->StartTime,tcontrol->nSamplesPerSec,tcontrol->nBitsPerSample,tcontrol->nChannels);
//lindex is last data index - used to determine where to draw the line from
	//fprintf(stderr,"timescale=%llins each pixel=rx2=%LF samples\n",tcontrol2->time,rx2);
        //fprintf(stderr,"channel=%d\n",tcontrol->Channel);
//and presume that the control will be clipped as part of a frame - but then need to clip before loading data
//	fprintf(stderr,"x1=%i\tx2=%i\n",tcontrol->x1,tcontrol->x2);
//remember that the data is already scaled, and so we only need to draw data[0], data[1], etc (for 8-bit data), data[0], data[2] for 16 bit, etc. 
	tsample[1]=0; //added to avoid warning - verify	
	mask=~(i64)(pow(2.0,(long double)tcontrol->nChannels-1));
		//if (tcontrol->nBitsPerSample==1 && tcontrol->nBitsPerChannel==1)
		if (tcontrol->nBitsPerSample==1 && tcontrol->nBitsPerChannel==1)
		  XSetForeground (PStatus.xdisplay, twin->xgc, 0xffffff);  //background color
			//XDrawLine(PStatus.xdisplay,twin->xwindow,twin->xgc,b,tcontrol->y1,b,tcontrol->y2-2);
			XDrawLine(PStatus.xdisplay,twin->xwindow,twin->xgc,i,y1,i,y2);
			XSetForeground(PStatus.xdisplay, twin->xgc, green);
			if ((y1+1>tcontrol->y1) && (y1+1<tcontrol->y2)) {
				XDrawPoint(PStatus.xdisplay,twin->xwindow,twin->xgc,i,y1+1);
			if ((y2-1<tcontrol->y2) && (y2-1>tcontrol->y1)) {
				XDrawPoint(PStatus.xdisplay,twin->xwindow,twin->xgc,i,y2-1);  
			XSetForeground(PStatus.xdisplay, twin->xgc, 0x0);  //text color
		  //fprintf(stderr,"%f\t",ypos-((tcontrol->data[(i64)dc]&b)!=0)*sy);
			//fprintf(stderr,"%x\t",tcontrol->data[(i64)(dc-rx2)]);
//			j+=tcontrol->nBitsPerSample;
			//fprintf(stderr,"st=%lli sps=%lli\n",(a-tcontrol->StartTimeVisible+tcontrol->StartTime),(i64)(tcontrol->nSamplesPerSec*tcontrol->nBitsPerSample));
			//fprintf(stderr,"b=%lli data=%lli\n",b,tcontrol->filesize);
			//if (dindex<tcontrol->filesize) {
//			if (dc<tcontrol->BufferSize) {
//			if (j<tcontrol->BufferSize) {
//				tsample[1]=tcontrol->data[j];
				cy=	ypos-((tcontrol->data[lindex]&b)!=0)*sy;
				cy2=ypos-((tcontrol->data[j]&b)!=0)*sy;
							cy2=y2-1;
							cy=y2-1;
						XDrawLine(PStatus.xdisplay,twin->xwindow,twin->xgc,i,cy,i,cy2);		
					} //cy>tcontrol->y1
//			} //j<tcontrol->BufferSize
			} //tcontrol->nBitsPerSample==1
		if (tcontrol->nBitsPerSample==8) // && tcontrol->nBitsPerChannel==8)
	//    fprintf(stderr,"b size=%lli\n",tcontrol->filesize);
	//    fprintf(stderr,"dindex=%lli tcontrol->Channel=%d\n",dindex,tcontrol->Channel);
		  //if (dc<tcontrol->BufferSize) {
			 if (j<tcontrol->BufferSize) {
//				tsample[1]=tcontrol->data[dc];
				tsample[1]=tcontrol->data[j];
//		  if (dindex<tcontrol->filesize) {
//				tsample[1]=tcontrol->data[dindex];
	//        fprintf(stderr,"sampy=%llx\n",ypos-tsample[1]);
		  XSetForeground (PStatus.xdisplay, twin->xgc, 0xffffff);  //background color
			XDrawLine(PStatus.xdisplay,twin->xwindow,twin->xgc,i,y1,i,y2-2);
			XSetForeground (PStatus.xdisplay, twin->xgc, green);  //draw border of track
//			XDrawPoint(PStatus.xdisplay,twin->xwindow,twin->xgc,a,y1);
//			XDrawPoint(PStatus.xdisplay,twin->xwindow,twin->xgc,a,y2-2); //1
			if ((y1+1>tcontrol->y1) && (y1+1<tcontrol->y2)) {
				XDrawPoint(PStatus.xdisplay,twin->xwindow,twin->xgc,i,y1+1);
			if ((y2-1<tcontrol->y2) && (y2-1>tcontrol->y1)) {
				XDrawPoint(PStatus.xdisplay,twin->xwindow,twin->xgc,i,y2-1);  
			XSetForeground (PStatus.xdisplay, twin->xgc,0x0);  //text color - draw actual sample
//			cy=	ypos-((tcontrol->data[lindex]&b)!=0)*sy;
//			cy2=ypos-((tcontrol->data[j]&b)!=0)*sy;
			cy=	ypos-(tcontrol->data[lindex])*sy;
			cy2=ypos-(tcontrol->data[j])*sy;
//			fprintf(stderr," %d",tcontrol->data[j]);
						cy2=y2-1;
						cy=y2-1;
					XDrawLine(PStatus.xdisplay,twin->xwindow,twin->xgc,i,cy,i,cy2);		
				} //cy>tcontrol->y1
//			XDrawLine(PStatus.xdisplay,twin->xwindow,twin->xgc,a,ypos-tsample[0]*sy,a,ypos-tsample[1]*sy);
			}  // //tcontrol->nBitsPerSample>>3==1
		if (tcontrol->nBitsPerSample==16)
	//    fprintf(stderr,"b size=%lli\n",tcontrol->filesize);
				//probably only one channel can be shown on 1 track anyway - probably remove COnlyShowOneChannel
				if (tcontrol->Bits2&COnlyShowOneChannel) {
					//dc+=tcontrol->Channel;
					j+=tcontrol->Channel;
	//    fprintf(stderr,"dindex=%lli tcontrol->Channel=%d\n",dindex,tcontrol->Channel);
		  if (j<tcontrol->BufferSize)	{
		    tsample[1]=(tcontrol->data[j+1]<<0x8)|(u8)tcontrol->data[j];
//		  if (dc<tcontrol->BufferSize)	{
//		    tsample[1]=(tcontrol->data[dc+1]<<0x8)|(u8)tcontrol->data[dc];
			//	tsample[1]=(tcontrol->data[tcontrol->filesize-1]<<0x8)|(u8)tcontrol->data[tcontrol->filesize-2];  //end of file data?
	//        fprintf(stderr,"sampy=%llx\n",ypos-tsample[1]);
		  //if (a==tcontrol->x1)
		  XSetForeground (PStatus.xdisplay, twin->xgc, 0xffffff);  //background color
			XDrawLine(PStatus.xdisplay,twin->xwindow,twin->xgc,i,y1,i,y2-2);
			XSetForeground (PStatus.xdisplay, twin->xgc, green);  //draw border of track
//			XDrawPoint(PStatus.xdisplay,twin->xwindow,twin->xgc,a,y1);
//			XDrawPoint(PStatus.xdisplay,twin->xwindow,twin->xgc,a,y2-2); //1
			if ((y1+1>tcontrol->y1) && (y1+1<tcontrol->y2)) {
				XDrawPoint(PStatus.xdisplay,twin->xwindow,twin->xgc,i,y1+1);
			if ((y2-1<tcontrol->y2) && (y2-1>tcontrol->y1)) {
				XDrawPoint(PStatus.xdisplay,twin->xwindow,twin->xgc,i,y2-1);  
			XSetForeground (PStatus.xdisplay, twin->xgc, 0x0);  //text color - draw actual sample
//				cy=	ypos-((tcontrol->data[lindex]&b)!=0)*sy;
//				cy2=ypos-((tcontrol->data[j]&b)!=0)*sy;
//				cy=	ypos-(int)tcontrol->data[lindex]*sy;
//				cy2=ypos-(int)tcontrol->data[j]*sy;
				cy=	ypos-(int)tsample[1];
				cy2=ypos-(int)tsample[0];
						cy2=y2-1;
						cy=y2-1;
					XDrawLine(PStatus.xdisplay,twin->xwindow,twin->xgc,i,cy,i,cy2);		
				} //cy>tcontrol->y1
//			XDrawLine(PStatus.xdisplay,twin->xwindow,twin->xgc,a,ypos-tsample[0],a,ypos-tsample[1]); //*sy?
			}  // //tcontrol->nBitsPerSample==16
      if (tcontrol->OnDraw!=0) {
				(*tcontrol->OnDraw) (twin,tcontrol);
				//To draw a frame - we need to erase all controls on the frame and draw them again
			if (tcontrol->TimeLineFTControl!=0) {
				DrawFTControl(tcontrol->TimeLineFTControl);
			} //	if (tcontrol->TimeLineFTControl!=0) 
        XSetForeground (PStatus.xdisplay, twin->xgc, tcontrol->color[0]);
        XFillRectangle(PStatus.xdisplay,twin->xwindow,twin->xgc,x1,y1,bw,bh);
				tcontrol2=twin->icontrol;
					if (tcontrol2->FrameFTControl==tcontrol) {
					tcontrol2=tcontrol2->next;
				tcontrol2=twin->icontrol;
					if (tcontrol2->FrameFTControl==tcontrol) {
						if (tcontrol2->type==CTData && tcontrol2->DataLabelFTControl!=0) {
							DrawFTControl(tcontrol2->DataLabelFTControl);
					tcontrol2=tcontrol2->next;
		    if (tcontrol->Bits&CVScroll) {
		      sprintf(tstr,"%s%s",PStatus.PrefixVScrollUp,tcontrol->name);
		      sprintf(tstr,"%s%s",PStatus.PrefixVScrollDown,tcontrol->name);
		      sprintf(tstr,"%s%s",PStatus.PrefixVScrollBack,tcontrol->name);
		      sprintf(tstr,"%s%s",PStatus.PrefixVScrollSlide,tcontrol->name);
		    if (tcontrol->Bits&CHScroll) {
		      sprintf(tstr,"%s%s",PStatus.PrefixHScrollLeft,tcontrol->name);
		      sprintf(tstr,"%s%s",PStatus.PrefixHScrollRight,tcontrol->name);
		      sprintf(tstr,"%s%s",PStatus.PrefixHScrollBack,tcontrol->name);
		      sprintf(tstr,"%s%s",PStatus.PrefixHScrollSlide,tcontrol->name);
				if (tcontrol->OnDraw!=0) {
					(*tcontrol->OnDraw) (twin,tcontrol);
		  XSetForeground (PStatus.xdisplay,twin->xgc,tcontrol->color[0]);
	    XFillRectangle(PStatus.xdisplay,twin->xwindow,twin->xgc,x1,y1,bw,bh);
 		  XSetForeground (PStatus.xdisplay, twin->xgc, tcontrol->textcolor[0]);  
			TimeScale=tcontrol->TimeScale;
//			rx=tcontrol->StartTimeVisible; //initial potential time line
//			fpi=tcontrol->TimeSpace*tcontrol->TimeScale;
				//perhaps should use tcontrol->TimeSpace for space between time lines, or i[0] instead of ScrollPixelsX
//			a=(u64)(10000000000ULL*VStatus.TimeSpace*tcontrol->TimeScale);
//			a=(u64)(10000000000ULL*tcontrol->TimeSpace*tcontrol->TimeScale);
			//a=(u64)(10000000000ULL*PStatus.ScrollPixelsX*tcontrol->TimeScale);
			//a=(u64)(10000000000ULL*tcontrol->TimeSpace*tcontrol->TimeScale);
			//rx=((long double)((u64)(tcontrol->StartTimeVisible/tcontrol->TimeSpace)))*tcontrol->TimeSpace;
			//rx=tcontrol->StartTimeVisible;///tcontrol->TimeSpace;
			//round rx to nearest time unit - otherwise we get 16.009us at 10ns/pixel resolution
			rx=((long double)((u32)(tcontrol->StartTimeVisible/tcontrol->TimeScale)))*tcontrol->TimeScale;
//			fprintf(stderr,"Starttime=%Lg rounded=%Lg\n",tcontrol->StartTimeVisible,rx);
			rx2=tcontrol->TimeSpace*TimeScale;
			//rx2=tcontrol->TimeScale*tcontrol->TimeSpace;
//truncate rx to .001*TimeScale for printing (and perhaps it should be truncated itself - it shouldn't matter (we don't loose a significant representation of data by truncating here) because it is 3 orders less than the time unit - it just looks bad displaying: 2.003ms @ 100ns because the first 100 pixels are 148-247, which moves 0.001483 to 0.001503 seconds by adding 2 at the timescale resolution. We could probe further by *10 *100, etc but it seems not necessary. we only need to quantize the start time since the interval should be in units
			//rx=(long double)((u32)(rx*1000.0/tcontrol->TimeScale))/(1000.0/tcontrol->TimeScale);
			//rx2=(long double)((u32)(rx2*1000.0/tcontrol->TimeScale))/(1000.0/tcontrol->TimeScale);
//need to change back to 1) because a page right or left moves the timeline by a non-timeline divisible quantity, and so we need to find on the timeline where the 10s are. This can be done by multiplying the time by 10*timescale*timespace (because of round off apparently - remainder is more accurate with integers) and finding the pixel that is closest to returning a remainder of 0, and then the first timeline is placed on that pixel.
//was: after more thought about this decision I decided to go with 2), because initially there is an empty space to the right of the data - at some high scales - like 10 min, there will always be empty space on the right, so it is ok to stay with the timeline based only on timescale*timespace, and let there be extra space on the right. In terms of scrolling, scrolling right should stop when maxx<=tframe.x2. So a timeline will always be at pixel 0, timespace, timespace*2, etc
//make the timeline conform to the timescale data, or make the timescale data not align perfectly in the frame at the end - for example if the timescale=10 seconds, but the data ends on some multiple of 1-9 seconds, either 1) the timeline shifts so the start time is offset by 1-9 1/timespace (1/10) timescale units or 2) there is a space of empty frame - the data control ending earlier than the 10th second. I am choosing option 1, since it looks better and maybe more simple.
			//quantize StartTime to TimeScale*TimeSpace - possiblyl should not be needed
		//	rx-=fmodl(rx,rx2); //remove any remainder from division by TimeScale*TimeSpace
//			tcontrol->StartTimeVisible=rx;
				//rx+=(10-j)*tcontrol->TimeScale;
				//rx+=j*tcontrol->TimeScale;
				//fprintf(stderr,"first line=%Lg first pixel=%d (%d)\n",rx,(10-j),x1);
				//x1+=(10-j);
				x1+=j;//(10-j);				
			//this part is needed because a data control may not end on a TimeScale*TimeSpace timeline and this throws off the beginning time on the timeline (which will not be at pixel 0, and TimeSpace pixel intervals after that, but instead at pixel 1 to TimeSpace-1. 
			//if 100s 100-j=pixel of starting timeline
			//for(rxi=rx;rxi<rx+10*rx2;rxi+=tcontrol->TimeScale) { //goes through 10 timelines one pixel at a time
			for(cx=x1;cx<x1+10*tcontrol->TimeSpace;cx++) {//goes through 10 timelines one pixel at a time
				//a=(u64)(rxi/tcontrol->TimeScale);					
				if (!(match&0x1) && (a%10)==0) { //10s line - gives first 10 line - used to find first time line
			//2) number the first timeline correctly (0-9) so that k=10 will be a 10,100,or 1000s line (the below code determines this)
			//so the first showing timeline will be (100-95)/10(timespace)=.5 rounds to 0 - the first line will be 0, sp the 10s line will be 10 lines from the first
			//if h=42, pixel 42 has a 1000s line, first pixel is (100-42)/10=5.8 rounds to 5 
			//if i=92, pixel 82 has a 100s line, (100-82)/10=1.8 rounds to 1, 
				//k=10-(int)rintl((float)h/((float)tcontrol->TimeSpace)); //move forward so that
				k=10-(int)((float)h/((float)tcontrol->TimeSpace)); //move forward so that
					//k=10-(int)rintl((float)i/((float)tcontrol->TimeSpace));
					k=10-(int)((float)i/((float)tcontrol->TimeSpace));
//					fprintf(stderr,"100s (%d) sets line to k=%d (timespace=%d) result=%f rounded=%Lg\n",i,k,tcontrol->TimeSpace,(float)i/((float)tcontrol->TimeSpace),rintl((float)i/((float)tcontrol->TimeSpace)));
//					k=10-(int)rint((float)j/((float)tcontrol->TimeSpace));
					k=10-(int)((float)j/((float)tcontrol->TimeSpace));
				//rx+=j*tcontrol->TimeScale; //move j timescale units forward, 1 for each pixel
//				rx+=(10-i)*tcontrol->TimeScale; //decrease starting visible time to
//				x1+=(10-i); //add 10-remainder pixels to the first timeline
//fmodl does not seem to work, for example returns 1e-5 for fmodl(0.00062,0.00001), remainderl also returns inaccurate remainders, but different from fmodl, for example: remainder(0.0001,1e-05)=1.65436e-24 - sometimes the same as fmodl.
				rx+=(10-i)*tcontrol->TimeScale; //decrease starting visible time to
				x1+=(10-i); //add 10-remainder pixels to the first timeline
				//fprintf(stderr,"first line=%Lg first pixel=%d (%d)\n",rx,(10-j),x1);
	//		rx2=tcontrol->TimeScale*tcontrol->TimeSpace; //rx2 is now used as the interval
			for(i=x1;i<x2;i+=tcontrol->TimeSpace) {
				  //fprintf(stderr,"time=%lli\n",tcontrol->time);
					sy=(float)(y1+(y2-y1)*4/10); //10s
					XDrawLine(PStatus.xdisplay,twin->xwindow,twin->xgc,i,(int)sy,i,y2-1);
					FT_FormatTime(tstr,rx,0); //create label for time (tx is in seconds - but labels can be "1 ns","1 us", etc)
//					FT_FormatTime(tstr,a*TimeScale,0); //create label for time (tx is in seconds - but labels can be "1 ns","1 us", etc)
				  if (rx>0.0 && i>x1 && ((i+((strlen(tstr)/2)*tcontrol->font->max_bounds.width))<x2) && (i-(strlen(tstr)/2)*tcontrol->font->max_bounds.width)>cx) {
//			      XSetForeground (PStatus.xdisplay, twin->xgc, tcontrol->textcolor[0]);
				    XDrawString(PStatus.xdisplay,twin->xwindow,twin->xgc,i-(strlen(tstr)/2)*tcontrol->font->max_bounds.width,y1+tcontrol->font->max_bounds.ascent,tstr,strlen(tstr));
						cx=i+(strlen(tstr)/2)*tcontrol->font->max_bounds.width; //last character printed
					  sy=(float)(y1+(y2-y1)*6/10);  //5s
						XDrawLine(PStatus.xdisplay,twin->xwindow,twin->xgc,i,(int)sy,i,y2-1);
					  sy=(float)(y1+(y2-y1)*9/10);  //1s
						XDrawLine(PStatus.xdisplay,twin->xwindow,twin->xgc,i,(int)sy,i,y2-1);
		if (tcontrol->OnDraw!=0) {
			(*tcontrol->OnDraw) (twin,tcontrol);
	//there must be a better way to do z-buffering and drawing, but for now I simply redraw any controls that have a lower z and cover any part of this control
//if drawing all controls - order by z, set WControlsZOrdered bit (reset if any control added or deleted to/from this window)
//if drawing only a single control - use the belo method of redrawing any controls higher
	tcontrolz=twin->icontrol;
		if (tcontrolz!=tcontrol && tcontrolz->z<tcontrol->z) {
//			fprintf(stderr,"Control %s has lower z than %s\n",tcontrolz->name,tcontrol->name);
//			fprintf(stderr,"z x1=%d x2=%d, x1=%d x2=%d\n",tcontrolz->x1,tcontrolz->x2,x1,x2);
				//control on a higher plane, see if any part is in x-y rectangle of this control
			if (tcontrolz->x1<x2 && tcontrolz->x2>x1) {//part of X is in
//				fprintf(stderr,"X of %s is within X of %s\n",tcontrolz->name,tcontrol->name);
				if (tcontrolz->y1<y2 && tcontrolz->y2>y1) {//part of Y is in
//					fprintf(stderr,"And %s is clipped by %s\n",tcontrolz->name,tcontrol->name);
				} 	//tcontrolz->y1<y2
			} //tcontrolz->x1<x2
		tcontrolz=tcontrolz->next;
    tcontrol=(FTControl *)tcontrol->next;
//This is used only for TimeLine controls - perhaps FT_FormatTimeLine
itime-=hrs*3600;
itime-=mns*60;
itime-=sec;
itime-=(msec*0.001);
itime-=(usec*0.000001);
//fprintf(stderr,"Timescale= %Lg\n",tcontrol->TimeScale);
timeunit=tcontrol->TimeScale*tcontrol->TimeSpace;
//all larger resolutions are displayed too, although perhaps this can be a setting - to ignore the higher scale values at small scale
		hrs-=hrs/24;
//  sprintf(text,"%i days %i:%02i:%02i",hrs/24,hrs-hrs/24,mns,sec);
//scale is 1-999 milliseconds
//fprintf(stderr,"tcontrol->TimeScale=%Lg timescale>=0.0001 is %d\n",tcontrol->TimeScale,(tcontrol->TimeScale>=(long double)0.0001));
//for some reason tcontrol->TimeScale>=0.0001 does not work when tcontrol->TimeScale==0.0001
//fprintf(stderr,"%Lg>1.0 is %d\n",tcontrol->TimeScale*10000.0,((tcontrol->TimeScale*10000.0)>=1.0));
//if (tcontrol->TimeScale>=(long double)0.0001)	{
	//scale is 1-999 microseconds
//	if (tcontrol->TimeScale>=0.0000001)	{
		//scale is 1-999 nanoseconds
//		if (tcontrol->TimeScale>=0.0000000001)	{
//  sprintf(text,"%i days %i:%02i:%02i",hrs/24,hrs-hrs/24,mns,sec);
		  //if (tcontrol->TimeScale*VStatus.TimeSpace<1.0)
//			if (tcontrol->TimeScale*PStatus.ScrollPixelsX<1.0)
			if (tcontrol->TimeScale*tcontrol->TimeSpace<1.0)
//		    if (tcontrol->TimeScale*VStatus.TimeSpace<0.001)
//		    if (tcontrol->TimeScale*PStatus.ScrollPixelsX<0.001)
		    if (tcontrol->TimeScale*tcontrol->TimeSpace<0.001)
//		      if (tcontrol->TimeScale*VStatus.TimeSpace<0.000001)
//		      if (tcontrol->TimeScale*PStatus.ScrollPixelsX<0.000001)
		      if (tcontrol->TimeScale*tcontrol->TimeSpace<0.000001)
//if ((bw*numbut+2*PStatus.PadX)>tfont->max_bounds.width*(strlen(message)+2)) 
if ((bw*numbut)>tfont->max_bounds.width*(strlen(message)+2)) 
  twin.w=tfont->max_bounds.width*(strlen(message)+2);
twin.h=(tfont->max_bounds.ascent+tfont->max_bounds.descent)+bh+2*PStatus.PadY;
//twin.h=(tfont->max_bounds.ascent+tfont->max_bounds.descent)+bh;
    x=twin2->x+twin2->w/2-twin.w/2;
    y=twin2->y+twin2->h/2-twin.h/2;
//XMoveWindow(PStatus.xdisplay,twin2->xwindow,x,y);
strcpy(tcontrol->name,tstr);
tcontrol->font=XLoadQueryFont(PStatus.xdisplay,"*ISO8859*");
if (tcontrol->font==0) fprintf(stderr,"Could not find font for FTControl %s.\n",tcontrol->name);
tcontrol->type=CTLabel;
tcontrol->x1=tcontrol->font->max_bounds.width;
tcontrol->y1=PStatus.PadY;
tcontrol->x2=tcontrol->font->max_bounds.width*(strlen(PStatus.mbmesg)+2);
tcontrol->y2=(tcontrol->font->max_bounds.ascent+tcontrol->font->max_bounds.descent)+PStatus.PadY;
if (PStatus.depth==16) {tcontrol->color[0]=wingray16;}  //background no press
else {tcontrol->color[0]=wingray;}  //background no press
tcontrol->color[1]=black;//black; //dkgray;  //text
tcontrol->color[2]=gray;//blue;  //background (mouse over)
tcontrol->color[3]=dkgray;  //bkground press
//tcontrol->win=twin->num;
tcontrol->Bits=CShowText;
//tcontrol->hotkey=PAlt|0x66;  //alt-f
//tcontrol->hotkey2=PAlt|0x46;  //alt-F
strcpy(tcontrol->text,PStatus.mbmesg);
strcpy(tcontrol->name,tstr);
tcontrol->font=XLoadQueryFont(PStatus.xdisplay,"*ISO8859*");
if (tcontrol->font==0) fprintf(stderr,"Could not find font for FTControl %s.\n",tcontrol->name);
tcontrol->type=CTButton;
//tcontrol->x1=PStatus.PadX+bw*j;
tcontrol->x1=bw*j;
tcontrol->y1=(tcontrol->font->max_bounds.ascent+tcontrol->font->max_bounds.descent)+PStatus.PadY;
//tcontrol->y1=(tcontrol->font->max_bounds.ascent+tcontrol->font->max_bounds.descent);
tcontrol->x2=tcontrol->x1+bw;
tcontrol->y2=tcontrol->y1+bh;
tcontrol->color[0]=ltgray;  //background no press
tcontrol->color[1]=black;//dkgray;  //text
tcontrol->color[2]=gray;//blue;  //background (mouse over)
tcontrol->color[3]=dkgray;  //bkground press
//tcontrol->win=twin->num;
tcontrol->Bits=CShowText;
//tcontrol->hotkey=PAlt|0x66;  //alt-f
//tcontrol->hotkey2=PAlt|0x46;  //alt-F
    strcpy(tcontrol->text,"OK");
    tcontrol->ButtonDownUp[0]=(FTControlfuncwcxy *)mbok_ButtonDownUp;
    strcpy(tcontrol->text,"Cancel");
    tcontrol->ButtonDownUp[0]=(FTControlfuncwcxy *)mbcancel_ButtonDownUp;
    strcpy(tcontrol->text,"Yes");
    tcontrol->ButtonDownUp[0]=(FTControlfuncwcxy *)mbyes_ButtonDownUp;
    strcpy(tcontrol->text,"No");
    tcontrol->ButtonDownUp[0]=(FTControlfuncwcxy *)mbno_ButtonDownUp;
    strcpy(tcontrol->text,"Yes All");
    tcontrol->ButtonDownUp[0]=(FTControlfuncwcxy *)mbyesall_ButtonDownUp;
    strcpy(tcontrol->text,"No All");
    tcontrol->ButtonDownUp[0]=(FTControlfuncwcxy *)mbnoall_ButtonDownUp;
tcontrol=tcontrol->parent;  //get parent FTControl
if (tcontrol->type==CTFileOpen) {
	if (tcontrol->i[0]>0) {
		tcontrol->i[0]--;
if (tcontrol->type==CTTextArea) {
if (tcontrol->type==CTFrame) { //scrollbar connected to frame
//if (twin!=0) twin->focus=tcontrol->tab;
tcontrol=tcontrol->parent;//GetFTControl("foOpenFile2");
//fprintf(stderr,"i[0]=%d num=%d-numvis=%d \n",tcontrol->i[0],tcontrol->num,tcontrol->numvisible);
if (tcontrol->type==CTFileOpen) {
	if (tcontrol->i[0]<tcontrol->ilist->num-tcontrol->numvisible) {
		tcontrol->i[0]++;
	//  fprintf(stderr,"i[0]=%d\n",tcontrol->i[0]);
if (tcontrol->type==CTTextArea) {
if (tcontrol->type==CTFrame) { //scrollbar connected to frame
//twin=GetFTWindowN(tcontrol->win);
//if (twin!=0) twin->focus=tcontrol->tab;
//XDefineCursor(PStatus.xdisplay,twin->xwindow,watch);
tparent=tcontrol->parent;
	if (tparent->type==CTTextArea) {  //scrollbar connected to textarea
		if (y<tcontrol->y1) {
		if (y>tcontrol->y2) {
		}//y>tcontrol->y2
	} //tparent->type==CTTextArea
	if (tparent->type==CTFrame) { //scrollbar connected to frame
			sprintf(tstr,"%s%s",PStatus.PrefixVScrollSlide,tparent->name);
			if (y<tslide->y1) {
			}//y<tcontrol->y1
	if (tparent->type==CTFileOpen) {
		if (y>tcontrol->y2) {
		if (y<tcontrol->y1) {
tcontrol3=tcontrol->parent;  //get parent FTControl
sprintf(tstr,"%s%s",PStatus.PrefixVScrollSlide,tcontrol3->name);
//if (y>tcontrol2->y2) foOpenFile2_Keypress(twin,tcontrol,XK_Page_Down);  //PageDown
//if (y<tcontrol2->y1) foOpenFile2_Keypress(twin,tcontrol,XK_Page_Up);  //PageUp
//if (y>tcontrol2->y2) CheckFTWindowKeypress(twin,XK_Page_Down);  //PageDown
//if (y<tcontrol2->y1) CheckFTWindowKeypress(twin,XK_Page_Up);  //PageUp
if (y>tcontrol2->y2) ScrollFTItemList(twin,tcontrol3,XK_Page_Down,0); //CheckFTWindowKeypress(twin,PGDN);  //PageDown
if (y<tcontrol2->y1) ScrollFTItemList(twin,tcontrol3,XK_Page_Up,0);  //PageUp
//perhaps should be VScrollSlide_Button0DownMouseMove - since mousemove over scrollslide without buttondown is not important
//fprintf(stderr,"%s\n",tcontrol->name);
//tcontrol is control with CVSlide bit set - the slide button itself
tcontrol2=tcontrol->parent;
sprintf(tstr,"%s%s",PStatus.PrefixVScrollBack,tcontrol2->name);
//sprintf(tstr,"%s%s",PStatus.PrefixVScrollSlide,tcontrol2->name);
//if (tcontrol->Bits&CButtonDown(0)) {// && y<tcontrol3->y2 && y>tcontrol3->y1) { //only move if within y of middle button
  tnum=(y-PStatus.LastMouseY);
//  bw=(tcontrol->x2-tcontrol->x1);
  bh=(tcontrol->y2-tcontrol->y1);
if (tcontrol->type==CTFileOpen) {
    if (tcontrol->y2+tnum>tback->y2) {
      tcontrol->y2=tback->y2;
      tcontrol->y1=tback->y2-bh;
      tcontrol->y1+=tnum;
      tcontrol->y2+=tnum;
      //fprintf(stderr,"added tcontrol->y1=%d\n",tcontrol->y1);
    }  //tcontrol->y2+tnum>
    if (tcontrol->y1+tnum<tback->y1) {
      tcontrol->y1=tback->y1;
      tcontrol->y2=tback->y1+bh;
      tcontrol->y1+=tnum;
      tcontrol->y2+=tnum;
//fprintf(stderr,"tcontrol2->y1=%d\n",tcontrol2->y1);
	if (tcontrol2->ilist!=0) {
		ratio=1.0-((float)(tcontrol->y2-tcontrol->y1)/(float)(tback->y2-tback->y1));
		  ratio=(1.0-((float)(tback->y2-tcontrol->y1)/(float)(tback->y2-tback->y1)))/ratio;
		  tcontrol2->i[0]=ratio*(tcontrol2->ilist->num-tcontrol2->numvisible);
		  //fprintf(stderr,"ratio=%f tcontrol->i[0]=%d\n",ratio,tcontrol->i[0]);
	} //tcontrol2->ilist!=0
//	fprintf(stderr,"tcontrol=%s\n",tcontrol->name);
if (tcontrol2->type==CTFrame) {
    if (tslide->y2+tnum>tback->y2) {
			tnum=tback->y2-tslide->y2;//mouse move larger than available space
      tslide->y2=tback->y2;
      tslide->y1=tback->y2-bh;
      tslide->y1+=tnum;
      tslide->y2+=tnum;
      //fprintf(stderr,"added tcontrol->y1=%d\n",tcontrol->y1);
    if (tslide->y1+tnum<tback->y1) { 
			tnum=tslide->y1-tback->y1;//mouse move larger than available space
      tslide->y1=tback->y1;
      tslide->y2=tback->y1+bh;
      tslide->y1+=tnum;
      tslide->y2+=tnum;
    } //tslide->y1+
	miny=tcontrol2->y1;
	maxy=tcontrol2->y2;
	tcontrol3=twin->icontrol;
		if (tcontrol3->FrameFTControl==tcontrol2 && !(tcontrol3->Bits&CNotVisible)) {
			tlabel=tcontrol3->DataLabelFTControl;
				if (!(tlabel->Bits2&CDoNotScrollY)) {
					if (tcontrol3->y1<miny) {
						miny=tcontrol3->y1;
					if (tcontrol3->y2>maxy) {
						maxy=tcontrol3->y2;
				} //tlabel-?Bits2
		} //if tcontrol3->FrameFTControl			
	tcontrol3=tcontrol3->next;
	ratio=(float)(maxy-miny)/(float)(tback->y2-tback->y1);
	tcontrol3=twin->icontrol;
		if (tcontrol3->FrameFTControl==tcontrol2 && !(tcontrol3->Bits&CNotVisible)) {
			if (!(tcontrol3->Bits2&CDoNotScrollY)) {
				tcontrol3->y1-=(int)((float)tnum*ratio);
				tcontrol3->y2-=(int)((float)tnum*ratio);
				if (tcontrol3->DataLabelFTControl!=0) {
					tlabel=tcontrol3->DataLabelFTControl;
							if (!(tlabel->Bits2&CDoNotScrollY)) {
							tlabel->y1-=(int)((float)tnum*ratio);
							tlabel->y2-=(int)((float)tnum*ratio);
							} //tlabel->Bits
			} //tcontrol->Bits2&CDoNotScrollY
		} //if tcontrol3->FrameFTControl			
	tcontrol3=tcontrol3->next;
//twin->focus=tcontrol->tab;
sprintf(tstr,"%s%s",PStatus.PrefixVScrollSlide,tcontrol->name);
sprintf(tstr,"%s%s",PStatus.PrefixVScrollBack,tcontrol->name);
if (tcontrol->type==CTFileOpen) {
	if (tcontrol->ilist!=0) {
		pos=(float)tcontrol->i[0]/(float)tcontrol->ilist->num;
		tslide->y1=tback->y1+((float)(tback->y2-tback->y1))*pos;
		ratio=(float)tcontrol->numvisible/(float)tcontrol->ilist->num;
	    tslide->y1=tback->y1;
	    tslide->y2=tback->y2;
//      pos=(float)tcontrol->i[0]/(float)tcontrol->ilist->num;
//      tcontrol2->y1=tcontrol3->y1+((float)(tcontrol3->y2-tcontrol3->y1))*pos;
	    tslide->y2=tslide->y1+((float)(tback->y2-tback->y1))*ratio;//-1;//+1; //+1
//    fprintf(stderr,"y1=%d y2=%d\n",tcontrol2->y1,tcontrol2->y2);
//    fprintf(stderr,"numvis=%d num=%d\n",tcontrol->numvisible,tcontrol->ilist->num);
if (tcontrol->type==CTFrame) {
	tcontrol2=twin->icontrol;
	miny=tcontrol->y1;
	maxy=tcontrol->y2;
		if (tcontrol2->FrameFTControl==tcontrol) {
			if (tcontrol2->y1<miny) {
				miny=tcontrol2->y1;
			if (tcontrol2->y2>maxy) {
				maxy=tcontrol2->y2;
	tcontrol2=tcontrol2->next;
	ratio=(float)(tcontrol->y2-tcontrol->y1)/(float)(maxy-miny);
		tslide->y1=tback->y1;
		tslide->y2=tback->y2;
		pos=tback->y1+(int)((float)(tcontrol->y1-miny)*ratio);//PStatus.ScrollPixelsY;
		slideheight=(int)(ratio*(float)(tback->y2-tback->y1));
		minslideheight=(tback->y2-tback->y1)/20;
		tslide->y1=(int)pos;
		tslide->y2=(int)pos+slideheight;
		if (tslide->y2>tback->y2) { //adjust in case of minslideheight
			tslide->y2=tback->y2;
sprintf(tstr,"%s%s",PStatus.PrefixVScrollSlide,tcontrol->name);
bh=tcontrol2->y2-tcontrol2->y1;
sprintf(tstr,"%s%s",PStatus.PrefixVScrollBack,tcontrol->name);
if (tcontrol->ilist!=0) {
  pos=(float)tcontrol->i[0]/(float)tcontrol->ilist->num;
  tcontrol2->y1=tcontrol3->y1+((float)(tcontrol3->y2-tcontrol3->y1))*pos;
  tcontrol2->y2=tcontrol2->y1+bh;
fh=tcontrol->font->max_bounds.ascent+tcontrol->font->max_bounds.descent;
maxheight=(int)((tcontrol->y2-tcontrol->y1)/fh); 
		 if (tcontrol->i[2]==tcontrol->i[3]) {
		   tcontrol->i[2]=tcontrol->i[0];
		   tcontrol->i[3]=tcontrol->i[0];
i=tcontrol->i[0];
	if (tcontrol->text[i]==10) {
//				tcontrol->i[1]=i+1;
		if (j==maxheight-1) {
			i=-1; //exit
		} //j==maxheight-1
	i--;
	tcontrol->i[0]--;
i=tcontrol->i[1];
		tcontrol->i[1]=0;
	if (tcontrol->text[i]==10) {
		tcontrol->i[1]=i+1;
			i=-1; //exit loop
	i--;
		if (tcontrol->i[0]<=tcontrol->i[2]) {
			tcontrol->i[2]=tcontrol->i[0]; 
			tcontrol->i[3]=tcontrol->i[0]; 
fh=tcontrol->font->max_bounds.ascent+tcontrol->font->max_bounds.descent;
maxheight=(int)((tcontrol->y2-tcontrol->y1)/fh); 
			 if (tcontrol->i[2]==tcontrol->i[3]) {
			   tcontrol->i[2]=tcontrol->i[0];
			   tcontrol->i[3]=tcontrol->i[0];
//todo: need to preserve cursor column too - move to end of line if too long
	tlen=strlen(tcontrol->text);
	i=tcontrol->i[0];
		tcontrol->i[0]++;
		if (tcontrol->text[i]==10) {		
			if (j==maxheight-1) {
	if (j==maxheight-1) {  //page was forwarded
//			fprintf(stderr,"maxheight-1=%d j=%d\n",maxheight-1,j);
		i=tcontrol->i[1];
			if (tcontrol->text[i]==10) {		//top of page
				tcontrol->i[1]=i+1; //advance top of page
	}	//j==maxheight-1
		if (tcontrol->i[0]<=tcontrol->i[2]) {
			tcontrol->i[2]=tcontrol->i[0]; 
			tcontrol->i[3]=tcontrol->i[0]; 
     if (tcontrol->i[2]==tcontrol->i[3]) {
       tcontrol->i[2]=tcontrol->i[0];
       tcontrol->i[3]=tcontrol->i[0];
	tlen=strlen(tcontrol->text);
	i=tcontrol->i[1]; 
		if (i==tcontrol->i[0]) {
		if (tcontrol->text[i]==10) {
			//move forward i[1] to next line - or do in DrawText?
	if (cy2==0 && tcontrol->i[1]>0) { //we need to adjust i[1]
		i=tcontrol->i[1]-1;
			if (i==0) tcontrol->i[1]=0;
			else tcontrol->i[1]=i+1;
			if (tcontrol->text[i]==10) {
				if (j>1) i=-1; //exit
		i--;
	i=tcontrol->i[1];
				tcontrol->i[0]=i; //
		if (tcontrol->text[i]==10) {
	} //while i>-1
			//if (tcontrol->i[0]>tcontrol->i[5]) tcontrol->i[5]=tcontrol->i[0];
			if (tcontrol->i[0]<=tcontrol->i[2]) {
				tcontrol->i[2]=tcontrol->i[0];						
				tcontrol->i[3]=tcontrol->i[0];						
//fw=tcontrol->font->max_bounds.width;
fh=tcontrol->font->max_bounds.ascent+tcontrol->font->max_bounds.descent;
//maxwidth=(int)((tcontrol->x2-tcontrol->x1)/fw); 
maxheight=(int)((tcontrol->y2-tcontrol->y1)/fh); 
		//CTTextArea - down arrow may move down a row
     if (tcontrol->i[2]==tcontrol->i[3]) {
       tcontrol->i[2]=tcontrol->i[0];
       tcontrol->i[3]=tcontrol->i[0];
		//possibly store cx,cy in some variable - i[4]i[5]
		//maxwidth=(tcontrol->x2-tcontrol->x1)/fw;
		//maxheight=(tcontrol->y2-tcontrol->y1)/fh;
		tlen=strlen(tcontrol->text);
		//i=tcontrol->i[0];
		i=tcontrol->i[1];
			if (i==tcontrol->i[0]) {
			if (i>tcontrol->i[0]) {  //past cursor - now looking for same x on line below
						tcontrol->i[0]=i; //
			if (tcontrol->text[i]==10) {
				//move forward i[1] to next line - or do in DrawText?
		if (cy==maxheight) { //need to adjust i[1] - first character showing
			i=tcontrol->i[1];
				if (i==0) tcontrol->i[1]=0;
				else 	tcontrol->i[1]=i+1;				
				if (tcontrol->text[i]==10) {
			//if (tcontrol->i[0]>tcontrol->i[5]) tcontrol->i[5]=tcontrol->i[0];
			//else tcontrol->i[4]=tcontrol->i[0];
			if (tcontrol->i[0]>tcontrol->i[3]) {
				tcontrol->i[3]=tcontrol->i[0];						
				tcontrol->i[2]=tcontrol->i[0];						
//button down on scrollbar down button connected to frame control - move controls on frame up
i64 maxy; //need i64 for negative tcontrol->y comparison
//if maxy>tcontrol->y2 - scroll all controls
maxy=tcontrol->y2;
tcontrol2=twin->icontrol;
	if (tcontrol2->FrameFTControl==tcontrol && !(tcontrol2->Bits2&CDoNotScrollY)) {
		if (tcontrol2->y2>maxy) {
			maxy=tcontrol2->y2;
tcontrol2=tcontrol2->next;
if (maxy>tcontrol->y2) {  //at least one control is lower than frame control - scroll all frame controls up
//fprintf(stderr,"maxy=%lli y2=%d\n",maxy,tcontrol->y2);
		numpix=tcontrol->y2-tcontrol->y1;
	if (maxy-numpix<tcontrol->y2) {
		numpix=maxy-tcontrol->y2;
	tcontrol2=twin->icontrol;
		if (tcontrol2->FrameFTControl==tcontrol && !(tcontrol2->Bits2&CDoNotScrollY)) {
			tcontrol2->y1-=numpix;
			tcontrol2->y2-=numpix;
			if (tcontrol2->DataLabelFTControl!=0) {
				tlabel=tcontrol2->DataLabelFTControl;
				if (!(tlabel->Bits2&CDoNotScrollY)) {
					tlabel->y1-=numpix;
					tlabel->y2-=numpix;
	tcontrol2=tcontrol2->next;
} //maxy>tcontrol->y2
//button down on scrollbar up button connected to frame control - move controls on frame down
//if maxy>tcontrol->y2 - scroll all controls
miny=tcontrol->y1;
tcontrol2=twin->icontrol;
	if (tcontrol2->FrameFTControl==tcontrol && !(tcontrol2->Bits2&CDoNotScrollY)) {
		if (tcontrol2->y1<miny) {
			miny=(i64)tcontrol2->y1;
tcontrol2=tcontrol2->next;
if (miny<tcontrol->y1) {  //at least one control is higher than frame control - scroll all frame controls down
		numpix=tcontrol->y2-tcontrol->y1;
	if (miny+numpix>tcontrol->y1) {
		numpix=tcontrol->y1-miny;
	tcontrol2=twin->icontrol;
		if (tcontrol2->FrameFTControl==tcontrol && !(tcontrol2->Bits2&CDoNotScrollY)) {
			tcontrol2->y1+=numpix;
			tcontrol2->y2+=numpix;
			if (tcontrol2->DataLabelFTControl!=0) {
				tlabel=tcontrol2->DataLabelFTControl;
				if (!(tlabel->Bits2&CDoNotScrollY)) {
					tlabel->y1+=numpix;
					tlabel->y2+=numpix;
	tcontrol2=tcontrol2->next;
} //maxy>tcontrol->y2
tcontrol=tcontrol->parent;//GetFTControl("foOpenFile2");
if (tcontrol->type==CTFrame) { //scrollbar connected to frame
tcontrol=tcontrol->parent;//GetFTControl("foOpenFile2");
if (tcontrol->type==CTFrame) { //scrollbar connected to frame
	tparent=tcontrol->parent;
		if (tparent->type==CTFrame) { //scrollbar connected to frame
			sprintf(tstr,"%s%s",PStatus.PrefixHScrollSlide,tparent->name);
			if (x<tslide->x1) {
			if (x>tslide->x2) {
sprintf(tstr,"%s%s",PStatus.PrefixVScrollSlide,tcontrol->name);
sprintf(tstr,"%s%s",PStatus.PrefixVScrollBack,tcontrol->name);
if (tcontrol->ilist!=0) {
  pos=(float)tcontrol->i[0]/(float)tcontrol->ilist->num;
  tcontrol2->y1=tcontrol3->y1+((float)(tcontrol3->y2-tcontrol3->y1))*pos;
    ratio=(float)tcontrol->numvisible/(float)tcontrol->ilist->num;
      tcontrol2->y1=tcontrol3->y1;
      tcontrol2->y2=tcontrol3->y2;
//      pos=(float)tcontrol->i[0]/(float)tcontrol->ilist->num;
//      tcontrol2->y1=tcontrol3->y1+((float)(tcontrol3->y2-tcontrol3->y1))*pos;
      tcontrol2->y2=tcontrol2->y1+((float)(tcontrol3->y2-tcontrol3->y1))*ratio+1;
//    fprintf(stderr,"y1=%d y2=%d\n",tcontrol2->y1,tcontrol2->y2);
//fprintf(stderr,"%s\n",tcontrol->name);
tcontrol2=tcontrol->parent;
sprintf(tstr,"%s%s",PStatus.PrefixHScrollBack,tcontrol2->name);
//  tnum=(int)((float)(y-PStatus.LastMouseY)*(float)tcontrol3->time/(float)PStatus.timespace);
  tnum=(x-PStatus.LastMouseX);
  bw=(tslide->x2-tslide->x1);
if (tcontrol2->type==CTFrame) {
	tTimeLine=tcontrol2->TimeLineFTControl;
    if (tslide->x2+tnum>tback->x2) {
			tnum=tback->x2-tslide->x2;//mouse move larger than available space
      tslide->x2=tback->x2;
      tslide->x1=tback->x2-bw;
      tslide->x1+=tnum;
      tslide->x2+=tnum;
      //fprintf(stderr,"added tcontrol->y1=%d\n",tcontrol->y1);
    if (tslide->x1+tnum<tback->x1) { 
			tnum=tslide->x1-tback->x1;//mouse move larger than available space
      tslide->x1=tback->x1;
      tslide->x2=tback->x1+bw;
      tslide->x1+=tnum;
      tslide->x2+=tnum;
    } //tslide->x1+
	minx=(i64)tcontrol2->x1;
	maxx=(i64)tcontrol2->x2;
	tcontrol3=twin->icontrol;
		if (tcontrol3->FrameFTControl==tcontrol2 && !(tcontrol3->Bits&CNotVisible)) {
			if (!(tcontrol3->Bits2&CDoNotScrollX)) {
				if (tcontrol3->type!=CTTimeLine) { //ignore TimeLine controls
					if (tcontrol3->type==CTData) { //data controls have a virtual size and this needs to be calculated from StartTime and EndTime
							lx=tTimeLine->x1+(i64)((tcontrol3->StartTime-tTimeLine->StartTimeVisible)/tTimeLine->TimeScale);
							lx=tTimeLine->x1+(i64)((tcontrol3->EndTime-tTimeLine->StartTimeVisible)/tTimeLine->TimeScale);
						if ((i64)tcontrol3->x1<minx) {
							minx=tcontrol3->x1;
						if ((i64)tcontrol3->x2>maxx) {
							maxx=tcontrol3->x2;
		} //if tcontrol3->FrameFTControl			
	tcontrol3=tcontrol3->next;
	ratio=(long double)(maxx-minx)/(long double)(tback->x2-tback->x1);
		tTimeLine->StartTimeVisible+=((long double)tnum*ratio)*tTimeLine->TimeScale;		
		tTimeLine->EndTimeVisible+=((long double)tnum*ratio)*tTimeLine->TimeScale;
		if (tTimeLine->StartTimeVisible<0.0) {
			tTimeLine->StartTimeVisible=0.0;
			tTimeLine->EndTimeVisible=(long double)(tTimeLine->x2-tTimeLine->x1)*tTimeLine->TimeScale;
		}//tTimeLine->StartTimevisible<
		if (tTimeLine->StartTimeVisible>((long double)maxx*tTimeLine->TimeScale)) {
			tTimeLine->EndTimeVisible=(long double)maxx*tTimeLine->TimeScale;
			tTimeLine->StartTimeVisible=tTimeLine->EndTimeVisible-(long double)(tTimeLine->x2-tTimeLine->x1)*tTimeLine->TimeScale;
		}//tTimeLine->StartTimevisible>
	tcontrol3=twin->icontrol;
		if (tcontrol3->FrameFTControl==tcontrol2 && !(tcontrol3->Bits&CNotVisible)) {
			if (!(tcontrol3->Bits2&CDoNotScrollX)) {
				if (tcontrol3->type!=CTTimeLine) {
					if (tcontrol3->type==CTData) {
						if (tcontrol3->DataLabelFTControl!=0) {
							tlabel=tcontrol3->DataLabelFTControl;
									if (!(tlabel->Bits2&CDoNotScrollX)) {
									//tlabel->x1-=(int)((long double)tnum*ratio);
									//tlabel->x2-=(int)((long double)tnum*ratio);
									} //tlabel->Bits
						tcontrol3->x1-=(i64)((long double)tnum*ratio);
						tcontrol3->x2-=(i64)((long double)tnum*ratio);
					} //tcontrol3->type!=CTData
			} //tcontrol->Bits2&CDoNotScrollX
		} //if tcontrol3->FrameFTControl			
	tcontrol3=tcontrol3->next;
    if (tcontrol->y2+tnum>tcontrol3->y2) {
//      tcontrol->y2+=tcontrol3->y2-tcontrol->y2;
//      tcontrol->y1+=tcontrol3->y2-tcontrol->y2;
      tcontrol->y2=tcontrol3->y2;
      tcontrol->y1=tcontrol3->y2-bh;
      tcontrol->y1+=tnum;
      tcontrol->y2+=tnum;
      //fprintf(stderr,"added tcontrol->y1=%d\n",tcontrol->y1);
    if (tcontrol->y1+tnum<tcontrol3->y1) {
//      tcontrol->y1+=tcontrol->y1-tcontrol3->y1;
//      tcontrol->y2+=tcontrol->y1-tcontrol3->y1;
      tcontrol->y1=tcontrol3->y1;
      tcontrol->y2=tcontrol3->y1+bh;
      tcontrol->y1+=tnum;
      tcontrol->y2+=tnum;
//fprintf(stderr,"tcontrol2->y1=%d\n",tcontrol2->y1);
if (tcontrol2->ilist!=0) {
  ratio=1.0-((float)(tcontrol->y2-tcontrol->y1)/(float)(tcontrol3->y2-tcontrol3->y1));
    ratio=(1.0-((float)(tcontrol3->y2-tcontrol->y1)/(float)(tcontrol3->y2-tcontrol3->y1)))/ratio;
    tcontrol2->i[0]=ratio*(tcontrol2->ilist->num-tcontrol2->numvisible);
    //fprintf(stderr,"ratio=%f tcontrol->i[0]=%d\n",ratio,tcontrol->i[0]);
//twin->focus=tcontrol->tab;
sprintf(tstr,"%s%s",PStatus.PrefixHScrollSlide,tcontrol->name);
sprintf(tstr,"%s%s",PStatus.PrefixHScrollBack,tcontrol->name);
if (tcontrol->TimeLineFTControl!=0) {
	tTimeLine=tcontrol->TimeLineFTControl;
if (tcontrol->type==CTFrame) {
	tcontrol2=twin->icontrol;
//	minx=tcontrol->x1;
//	maxx=tcontrol->x2;
	framewidth=tcontrol->x2-tcontrol->x1;
	backwidth=tback->x2-tback->x1;
//	minx=tback->x1;
//	maxx=tback->x1;
	minx=tcontrol->x1;
	maxx=tcontrol->x2;
		if (tcontrol2->FrameFTControl==tcontrol) {
			if (tcontrol2->type==CTData) { //data controls have a virtual size and this needs to be calculated from StartTime and EndTime
					lx=tTimeLine->x1+(i64)((tcontrol2->StartTime-tTimeLine->StartTimeVisible)/tTimeLine->TimeScale);
					lx=tTimeLine->x1+(i64)((tcontrol2->EndTime-tTimeLine->StartTimeVisible)/tTimeLine->TimeScale);
				if (tcontrol2->x1<minx) {
					minx=tcontrol2->x1;
				if (tcontrol2->x2>maxx) {
					maxx=tcontrol2->x2;
	tcontrol2=tcontrol2->next;
//		maxx=tback->x2;
//	ratio=(long double)(tcontrol->x2-tcontrol->x1)/(long double)(maxx-minx);
//	ratio=(long double)(tback->x2-tback->x1)/(long double)(maxx-minx);
	//ratio=(long double)(tback->x2-tback->x1)/(long double)(maxx-minx-(tcontrol->x2-tcontrol->x1)/2);
//	ratio=(long double)(tTimeLine->x2-tTimeLine->x1)/(long double)(maxx-minx);
		controlswidth=maxx-minx;
//	ratio=(long double)(tTimeLine->x2-tTimeLine->x1)/(long double)(maxx-minx);
//	fprintf(stderr,"back x1=%d x2=%d w=%d wtimeline=%d\n",tback->x1,tback->x2,tback->x2-tback->x1,tTimeLine->x2-tTimeLine->x1);
		tslide->x1=tback->x1;
		tslide->x2=tback->x2;
//		ratio=(long double)(tTimeLine->x2-tTimeLine->x1)/(long double)(maxx-minx-(long double)(tcontrol->x2-tcontrol->x1));
		//minslidewidth=(tback->x2-tback->x1)/20;
		//pos=tback->x1+(int)((float)(tTimeLine->StartTimeVisible-minx)*ratio);//PStatus.ScrollPixelsY;
//		pos=(int)((tTimeLine->StartTimeVisible/tTimeLine->TimeScale)*(tback->x2-tback->x1)/(maxx-minx));
		pos=(int)((long double)(tcontrol->x1-minx)*(long double)backwidth/(long double)controlswidth);
			//pos=(int)(((long double)(tcontrol->x1-(newframewidth-framewidth)/2-minx)*(long double)backwidth)/(long double)controlswidth);
//			pos=(int)(((int)((u64)((long double)tcontrol->x1*)-minx))*(tback->x2-tback->x1)/((maxx-minx)*slidewidth));
			//this is like resizing the frame dimensions - think of the frame as the slide button to the scrolling control width
//			pos*=(((long double)FT_MIN_SLIDE_SIZE/(long double)slidewidth)/(long double)(tcontrol->x2-tcontrol->x1));
//			pos=(int)((float)pos-slideratio*((float)pos/(float)backwidth));
			pos=(int)((float)pos-(float)FT_MIN_SLIDE_SIZE*((float)pos/(float)backwidth));
//		pos=(int)((tTimeLine->StartTimeVisible/tTimeLine->TimeScale)*(tback->x2-tback->x1)/(maxx-minx));
			ratio=(long double)(tback->x2-tback->x1-FT_MIN_SLIDE_SIZE)/(long double)(tback->x2-tback->x1-slidewidth);
		tslide->x1=tback->x1+pos+1;
		tslide->x2=tslide->x1+slidewidth;
		//tslide->x2=(int)pos+(int)(ratio*(float)(tTimeLine->x2-tTimeLine->x1));
		//tslide->x2=(int)pos+(int)(ratio*(float)(tcontrol->x2-tcontrol->x1));
//		fprintf(stderr,"slide x1=%d x2=%d w=%d slidewidth=%d\n",tslide->x1,tslide->x2,tslide->x2-tslide->x1,slidewidth);
sprintf(tstr,"%s%s",PStatus.PrefixVScrollSlide,tcontrol->name);
bh=tcontrol2->y2-tcontrol2->y1;
sprintf(tstr,"%s%s",PStatus.PrefixVScrollBack,tcontrol->name);
if (tcontrol->ilist!=0) {
  pos=(float)tcontrol->i[0]/(float)tcontrol->ilist->num;
  tcontrol2->y1=tcontrol3->y1+((float)(tcontrol3->y2-tcontrol3->y1))*pos;
  tcontrol2->y2=tcontrol2->y1+bh;
i64 minx,lx1; //need i64 for negative tcontrol->y comparison
//if minx<tcontrol->x1 - scroll all controls
minx=tcontrol->x1;
tcontrol2=twin->icontrol;
	if (tcontrol2->FrameFTControl==tcontrol && !(tcontrol2->Bits2&CDoNotScrollX)) {
		//could be a data control which uses lx1,lx2 - but ly1,ly2 are probably not used and are mirrored in y1,y2
		if (tcontrol2->type==CTData) {
			if (tcontrol2->TimeLineFTControl!=0) {
				//determine x1 position of data based on (data->starttime-timeline->StartTimeVisible) (s) / timescale s/pixel)
				tTimeLine=tcontrol2->TimeLineFTControl;
				st=tcontrol2->StartTime;
				stt=tTimeLine->StartTimeVisible;
				lx1=tTimeLine->x1+(i64)((st-stt)/tTimeLine->TimeScale); 
			if (tcontrol2->x1<minx) {
				minx=(i64)tcontrol2->x1;
tcontrol2=tcontrol2->next;
if (minx<(i64)tcontrol->x1) {  //at least one control is left of the frame control - scroll all frame controls right
//fprintf(stderr,"minx=%lli x1=%d\n",minx,tcontrol->x1);
		numpix=tcontrol->x2-tcontrol->x1;
		numpix=PStatus.ScrollPixelsX;//tcontrol2->TimeSpace;
	if (minx+numpix>(i64)tcontrol->x1) {
		numpix=tcontrol->x1-minx;
	if (tcontrol->TimeLineFTControl!=0) {
		tTimeLine=tcontrol->TimeLineFTControl;
		tTimeLine->StartTimeVisible-=tTimeLine->TimeScale*(long double)numpix; //move time, in s
		tTimeLine->StartTimeVisible-=fmodl(tTimeLine->StartTimeVisible,tTimeLine->TimeScale*tTimeLine->TimeSpace);
		if (tTimeLine->StartTimeVisible<0.0) {
			tTimeLine->StartTimeVisible=0.0;
	} //tcontrol->TimeLineFTControl!=0
	tcontrol2=twin->icontrol;
		if (tcontrol2->FrameFTControl==tcontrol && !(tcontrol2->Bits2&CDoNotScrollX)) {
			//Data controls do not scroll in the x dimension (but do in the y)- only the data scrolls in the x, otherwise data would need to have 64-bit x1,x2 values, when for example there is a few seconds of data being looked at with a TimeScale of 1ns.
			if (tcontrol2->type==CTData) {
					if (tcontrol2->DataLabelFTControl!=0) {
						tlabel=tcontrol2->DataLabelFTControl;
						if (!(tlabel->Bits2&CDoNotScrollX)) {
							tlabel->x1+=numpix;
							tlabel->x2+=numpix;
				tcontrol2->x1+=numpix;
				tcontrol2->x2+=numpix;
			} //tcontrol2->type==CTData
//			fprintf(stderr,"scroll left %s st=%Lg et=%Lg\n",tcontrol2->name, tcontrol2->StartTimeVisible,tcontrol2->EndTimeVisible);
//			fprintf(stderr,"Scroll %s left x1=%d x2=%d\n",tcontrol2->name,tcontrol2->x1,tcontrol2->x2);
	tcontrol2=tcontrol2->next;
} //maxy>tcontrol->y2
//button down on scrollbar right button connected to frame control - move controls on frame left
//if maxy>tcontrol->y2 - scroll all controls
maxx=tcontrol->x2;
tcontrol2=twin->icontrol;
	if (tcontrol2->FrameFTControl==tcontrol && !(tcontrol2->Bits2&CDoNotScrollX)) {
		if (tcontrol2->type==CTData) {  
			if (tcontrol2->TimeLineFTControl!=0) {
				//determine x1 position of data based on (data->starttime-timeline->StartTimeVisible) (s) / timescale s/pixel)
				tTimeLine=tcontrol2->TimeLineFTControl;
				et=tcontrol2->EndTime;
				stt=tTimeLine->StartTimeVisible;
				lx2=tTimeLine->x1+(i64)((et-stt)/tTimeLine->TimeScale); 
			if (tcontrol2->x2>maxx) {
				maxx=(i64)tcontrol2->x2;
tcontrol2=tcontrol2->next;
if (maxx>(i64)tcontrol->x2) {  //at least one control is farther to the right than frame control - scroll all frame controls left
//Note that ScrollPixelsX needs to be the same as tcontrol->TimeSpace
//use tcontrol->TimeSpace for data and timeline controls?
		numpix=tcontrol->x2-tcontrol->x1; //possibly should be in units of 10? so 10s time lines do not have one's digits
		numpix=PStatus.ScrollPixelsX;//tcontrol2->TimeSpace; //perhaps make tcontrol->TimeScale*tcontrol->nSamplesPerSecond;
//	if (maxx-numpix<(i64)tcontrol->x2) {
//		numpix=maxx-tcontrol->x2;
//	if ((i64)tcontrol->x1-numpix<0.0) {
//		numpix=tcontrol->x1-numpix;
			//fprintf(stderr,"maxx %lli > %lli tcontrol->x2 numpix=%d\n",maxx,(i64)tcontrol->x2,numpix);
	if (tcontrol->TimeLineFTControl!=0) {
		tTimeLine=tcontrol->TimeLineFTControl;
		inc=tTimeLine->TimeScale*(long double)numpix;
		//quantize tTimeLine->StartTimeVisible to TimeScale*TimeSpace
//		tTimeLine->StartTimeVisible-=fmodl(tTimeLine->StartTimeVisible,tTimeLine->TimeScale);
//		tTimeLine->StartTimeVisible=(long double)((i64)tTimeLine->StartTimeVisible/tTimeLine->TimeScale*tTimeLine->TimeSpace)*tTimeLine->TimeScale*tTimeLine->TimeSpace;
//		fprintf(stderr,"StartTimeVisible=%Lg\n",tTimeLine->StartTimeVisible);
		tTimeLine->StartTimeVisible+=inc; //move time, in s
//		fprintf(stderr,"StartTimeVisible=%Lg inc=%Lg divide by = %Lg\n",tTimeLine->StartTimeVisible,inc,tTimeLine->TimeScale*tTimeLine->TimeSpace);
//		fprintf(stderr,"remainder=%Lg fmodl=%Lg\n",remainderl(tTimeLine->StartTimeVisible,tTimeLine->TimeScale*tTimeLine->TimeSpace),fmodl(tTimeLine->StartTimeVisible,tTimeLine->TimeScale*tTimeLine->TimeSpace));
//fmodl and remainderl both return a remainder for 3e-05,1e-05
//		tTimeLine->StartTimeVisible-=remainderl(tTimeLine->StartTimeVisible,tTimeLine->TimeScale*tTimeLine->TimeSpace);
//		fprintf(stderr,"timeline st=%Lg numpix=%d +%Lg\n",tTimeLine->StartTimeVisible,numpix,tTimeLine->TimeScale*(long double)numpix);
//			fprintf(stderr,"after StartTimeVisible=%Lg inc=%Lg\n",tTimeLine->StartTimeVisible,inc);
	} //tcontrol->TimeLineFTControl!=0
	tcontrol2=twin->icontrol;
		if (tcontrol2->FrameFTControl==tcontrol && !(tcontrol2->Bits2&CDoNotScrollX)) {
//			fprintf(stderr,"Scrolling control %s\n",tcontrol2->name);
			if (tcontrol2->type==CTData) {
					if (tcontrol2->DataLabelFTControl!=0) {
						tlabel=tcontrol2->DataLabelFTControl;
						if (!(tlabel->Bits2&CDoNotScrollX)) {
							tlabel->x1-=numpix;
							tlabel->x2-=numpix;
				tcontrol2->x1-=numpix;
				tcontrol2->x2-=numpix;
//		fprintf(stderr,"Scroll %s right x1=%d x2=%d\n",tcontrol2->name,tcontrol2->x1,tcontrol2->x2);
	tcontrol2=tcontrol2->next;
} //maxy>tcontrol->y2
//this occurs when data is 1) open 2) moved 3) resized 4) cut 5) TimeScale is changed +-
if (tcontrol->TimeLineFTControl!=0) {
	tTimeLine=tcontrol->TimeLineFTControl;
	bw=tTimeLine->x2-tTimeLine->x1;
//	if (tTimeLine->EndTimeVisible<=tTimeLine->StartTimeVisible) { //TimeLine endtime was probably not set correctly
	tTimeLine->EndTimeVisible=tTimeLine->StartTimeVisible+bw*tTimeLine->TimeScale;
	st=tcontrol->StartTime;
	et=tcontrol->EndTime;
	stt=tTimeLine->StartTimeVisible;
	ett=tTimeLine->EndTimeVisible;
//	durt=ett-stt;
	//ett=stt+(long double)(tTimeLine->x2-tTimeLine->x1)*tTimeLine->TimeScale; 
		tcontrol->Bits|=CNotVisible;
		tcontrol->Bits|=CNotVisible;
	tcontrol->Bits&=~CNotVisible;
		tcontrol->StartTimeVisible=stt;
		tcontrol->StartTimeVisible=st;
	st=tcontrol->StartTimeVisible;
	//tcontrol->x1=tTimeLine->x1+(int)((st-stt)(long double)bw);
	tcontrol->x1=tTimeLine->x1+(int)((st-stt)/tTimeLine->TimeScale);  
		tcontrol->x2=tTimeLine->x2;
		tcontrol->x2=tcontrol->x1+(int)((et-st)/tTimeLine->TimeScale);
if (tcontrol->x2-tcontrol->x1<2) {
	tcontrol->x2=tcontrol->x1+2;
//if (tcontrol->Channel==0) {
//	fprintf(stderr,"x1=%d x2=%d st=%Lg et=%Lg stt=%Lg ett=%Lg\n",tcontrol->x1,tcontrol->x2,st,et,stt,ett);
} else { //tcontrol->TimeLineFTControl!=0
fprintf(stderr,"-h,--help Show this menu\n");
fprintf(stderr,"-i,--info Show info (solve error mode)\n"); 
